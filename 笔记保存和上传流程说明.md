# 笔记保存和上传流程说明

本文档详细说明从用户输入文本到上传服务器的完整流程，并在每一步标注需要添加的调试日志。

## 完整流程概览

### 阶段1：用户输入和内容变化检测

**1.1 用户输入文本**
- 位置：`RichTextEditorView` 或 `RichTextEditorWrapper`
- 用户通过键盘输入或粘贴内容到富文本编辑器
- **需要添加日志**：`[[调试]] 用户输入文本，编辑器内容长度: {length}`

**1.2 编辑器内容变化回调**
- 位置：`NoteDetailView.swift` - `RichTextEditorWrapper` 的 `onContentChange` 回调
- 当编辑器内容发生变化时触发
- **需要添加日志**：`[[调试]] 编辑器内容变化回调触发，RTF数据长度: {rtfData?.count ?? 0}`

**1.3 更新本地状态**
- 位置：`NoteDetailView.swift` - `onContentChange` 闭包内
- 更新 `editedRTFData` 和 `editedAttributedText`
- **需要添加日志**：`[[调试]] 更新本地状态，editedRTFData已更新: {editedRTFData != nil}, editedAttributedText长度: {editedAttributedText.characters.count}`

**1.4 内容变化检测**
- 位置：`NoteDetailView.swift` - `handleContentChange` 方法
- 比较新的 `AttributedString` 和 `originalAttributedText` 是否不同
- **需要添加日志**：`[[调试]] 内容变化检测，新内容长度: {newString.count}, 原始内容长度: {originalString.count}, 是否变化: {newString != originalString}`

### 阶段2：触发保存操作

**2.1 立即保存触发**
- 位置：`NoteDetailView.swift` - `handleContentChange` 方法
- 如果内容有变化，调用 `performSaveImmediately()`
- **需要添加日志**：`[[调试]] 触发立即保存，笔记ID: {note.id}`

**2.2 执行立即保存**
- 位置：`NoteDetailView.swift` - `performSaveImmediately` 方法
- 调用 `performSave(for: note)`
- **需要添加日志**：`[[调试]] 执行立即保存，笔记ID: {note.id}`

**2.3 执行保存操作（主流程）**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法
- 检查笔记ID匹配，设置保存状态
- **需要添加日志**：`[[调试]] 开始执行保存操作，笔记ID: {note.id}, 当前编辑笔记ID: {currentEditingNoteId}, 是否匹配: {note.id == currentEditingNoteId}`

### 阶段3：获取最新编辑器内容

**3.1 从编辑器上下文获取内容**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 如果使用 RichTextKit，从 `editorContext.attributedString` 获取最新内容
- **需要添加日志**：`[[调试]] 从editorContext获取内容，使用RichTextKit: {useRichTextKit}, context内容长度: {contextAttributedString.length}`

**3.2 转换为RTF数据**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 将 `NSAttributedString` 转换为 RTF 数据（使用 `.archivedData` 格式以支持图片）
- **需要添加日志**：`[[调试]] 转换为RTF数据，RTF数据长度: {archivedData.count}, 转换成功: {archivedData != nil}`

**3.3 更新本地RTF数据**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 更新 `editedRTFData` 和 `finalAttributedText`
- **需要添加日志**：`[[调试]] 更新本地RTF数据，finalRTFData长度: {finalRTFData?.count ?? 0}, finalAttributedText长度: {finalAttributedText.characters.count}`

### 阶段4：格式转换（AttributedString -> XML）

**4.1 转换为AttributedString**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 确保有 `finalAttributedText`（SwiftUI AttributedString）
- **需要添加日志**：`[[调试]] 准备转换为XML，AttributedString长度: {finalAttributedText.characters.count}`

**4.2 调用转换器**
- 位置：`AttributedStringConverter.swift` - `attributedStringToXML` 方法
- 将 `AttributedString` 转换为 `NSAttributedString`，然后调用 `MiNoteContentParser.parseToXML`
- **需要添加日志**：`[[调试]] 开始AttributedString到XML转换，输入AttributedString长度: {attributedString.characters.count}`

**4.3 转换为NSAttributedString**
- 位置：`AttributedStringConverter.swift` - `attributedStringToXML` 方法
- `NSAttributedString(attributedString)` 转换
- **需要添加日志**：`[[调试]] 转换为NSAttributedString，长度: {nsAttributedString.length}`

**4.4 调用XML解析器**
- 位置：`MiNoteContentParser.swift` - `parseToXML` 方法
- 将 `NSAttributedString` 解析为小米笔记XML格式
- **需要添加日志**：`[[调试]] 调用MiNoteContentParser.parseToXML，输入NSAttributedString长度: {attributedString.length}`

**4.5 XML转换完成**
- 位置：`AttributedStringConverter.swift` - `attributedStringToXML` 方法
- 清理XML内容（移除空段落，确保格式正确）
- **需要添加日志**：`[[调试]] XML转换完成，XML内容长度: {xmlContent.count}, 内容预览: {xmlContent.prefix(100)}`

**4.6 返回XML到保存流程**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 获得 `xmlContent` 用于创建 `Note` 对象
- **需要添加日志**：`[[调试]] 获得XML内容，长度: {xmlContent.count}, 笔记ID: {note.id}`

### 阶段5：创建更新的Note对象

**5.1 构建Note对象**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 创建包含新内容的 `Note` 对象（使用XML作为content，RTF作为rtfData）
- **需要添加日志**：`[[调试]] 构建更新的Note对象，ID: {note.id}, 标题: {editedTitle}, XML长度: {xmlContent.count}, RTF长度: {finalRTFData?.count ?? 0}`

**5.2 调用ViewModel更新**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法内
- 调用 `viewModel.updateNote(updatedNote)`
- **需要添加日志**：`[[调试]] 调用viewModel.updateNote，笔记ID: {updatedNote.id}`

### 阶段6：ViewModel处理更新

**6.1 进入updateNote方法**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 开始处理笔记更新
- **需要添加日志**：`[[调试]] [VIEWMODEL] 进入updateNote方法，笔记ID: {note.id}, 标题: {note.title}`

**6.2 保存到本地数据库**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 调用 `localStorage.saveNote(note)` 保存到SQLite数据库
- **需要添加日志**：`[[调试]] [VIEWMODEL] 保存到本地数据库，笔记ID: {note.id}`

**6.3 本地数据库保存**
- 位置：`DatabaseService.swift` - `saveNote` 方法
- 执行SQL INSERT OR REPLACE操作
- **需要添加日志**：`[[调试]] [Database] 保存笔记到数据库，ID: {note.id}, 标题: {note.title}, content长度: {note.content.count}, rtfData长度: {note.rtfData?.count ?? 0}`

**6.4 更新笔记列表**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 更新内存中的 `notes` 数组
- **需要添加日志**：`[[调试]] [VIEWMODEL] 更新笔记列表，笔记ID: {note.id}, 列表索引: {index ?? "新增"}`

**6.5 检查在线状态**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 检查是否在线且已登录
- **需要添加日志**：`[[调试]] [VIEWMODEL] 检查在线状态，isOnline: {isOnline}, isAuthenticated: {service.isAuthenticated()}`

**6.6 离线模式处理**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 如果离线，添加到离线队列
- **需要添加日志**：`[[调试]] [VIEWMODEL] 离线模式，添加到离线队列，笔记ID: {note.id}`

### 阶段7：获取云端最新信息（在线模式）

**7.1 获取现有tag**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 从本地 `rawData` 获取 `tag`，准备上传
- **需要添加日志**：`[[调试]] [VIEWMODEL] 获取现有tag，当前tag: {existingTag.isEmpty ? "空" : existingTag}`

**7.2 检查笔记是否存在于云端**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 调用 `service.fetchNoteDetails(noteId: note.id)` 检查笔记是否存在
- **需要添加日志**：`[[调试]] [VIEWMODEL] 检查笔记是否存在于云端，笔记ID: {note.id}`

**7.3 获取云端最新信息**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 如果笔记存在，从服务器响应中提取最新的 `tag` 和 `createDate`
- **需要添加日志**：`[[调试]] [VIEWMODEL] 从服务器获取最新信息，tag: {latestTag ?? "无"}, createDate: {latestCreateDate ?? "无"}`

**7.4 处理新建笔记**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 如果笔记不存在于云端，先调用 `service.createNote` 创建
- **需要添加日志**：`[[调试]] [VIEWMODEL] 笔记不存在于云端，尝试创建，笔记ID: {note.id}`

**7.5 创建笔记响应处理**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 处理创建响应，更新笔记ID和rawData（如果服务器返回新ID）
- **需要添加日志**：`[[调试]] [VIEWMODEL] 创建笔记响应，code: {code}, 新ID: {newNoteId ?? note.id}`

### 阶段8：准备上传数据

**8.1 提取图片信息**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 从 `rawData` 中提取 `setting.data`（图片信息）
- **需要添加日志**：`[[调试]] [VIEWMODEL] 提取图片信息，imageData数量: {imageData?.count ?? 0}`

**8.2 确保tag不为空**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 如果tag仍然为空，使用noteId作为fallback
- **需要添加日志**：`[[调试]] [VIEWMODEL] 确保tag不为空，最终tag: {existingTag}`

**8.3 调用服务层更新**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 调用 `service.updateNote` 上传到服务器
- **需要添加日志**：`[[调试]] [VIEWMODEL] 调用service.updateNote上传，笔记ID: {note.id}, title: {note.title}, content长度: {note.content.count}`

### 阶段9：服务层上传到服务器

**9.1 进入updateNote服务方法**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 开始构建上传请求
- **需要添加日志**：`[[调试]] [MiNoteService] 进入updateNote服务方法，noteId: {noteId}, title: {title}, content长度: {content.count}`

**9.2 构建extraInfo**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 构建 `extraInfoDict` 包含标题等信息
- **需要添加日志**：`[[调试]] [MiNoteService] 构建extraInfo，title: {title}`

**9.3 清理content**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 移除content中的 `<new-format/>` 前缀（上传时不需要）
- **需要添加日志**：`[[调试]] [MiNoteService] 清理content，原始长度: {content.count}, 清理后长度: {cleanedContent.count}`

**9.4 构建setting对象**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 构建包含图片信息的setting对象
- **需要添加日志**：`[[调试]] [MiNoteService] 构建setting对象，包含图片数据: {imageData != nil && !imageData!.isEmpty}`

**9.5 构建entry对象**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 构建完整的entry对象，包含所有字段
- **需要添加日志**：`[[调试]] [MiNoteService] 构建entry对象，id: {noteId}, tag: {existingTag}, content长度: {cleanedContent.count}`

**9.6 序列化为JSON**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 使用 `JSONSerialization` 将entry序列化为JSON字符串
- **需要添加日志**：`[[调试]] [MiNoteService] 序列化entry为JSON，JSON长度: {entryJson.count}`

**9.7 URL编码**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 使用 `encodeURIComponent` 对entry和serviceToken进行URL编码
- **需要添加日志**：`[[调试]] [MiNoteService] URL编码完成，entry编码后长度: {entryEncoded.count}`

**9.8 构建请求体**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 构建 `entry=...&serviceToken=...` 格式的请求体
- **需要添加日志**：`[[调试]] [MiNoteService] 构建请求体，body长度: {body.count}`

**9.9 创建HTTP请求**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 创建 `URLRequest`，设置headers和body
- **需要添加日志**：`[[调试]] [MiNoteService] 创建HTTP请求，URL: {urlString}, method: POST`

**9.10 发送网络请求**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 使用 `URLSession.shared.data(for: request)` 发送请求
- **需要添加日志**：`[[调试]] [MiNoteService] 发送网络请求，笔记ID: {noteId}`

**9.11 接收HTTP响应**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 检查HTTP状态码
- **需要添加日志**：`[[调试]] [MiNoteService] 接收HTTP响应，状态码: {httpResponse.statusCode}`

**9.12 处理401错误**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 如果返回401，调用 `handle401Error` 处理认证错误
- **需要添加日志**：`[[调试]] [MiNoteService] 处理401错误，需要重新认证`

**9.13 解析响应JSON**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 将响应数据解析为JSON对象
- **需要添加日志**：`[[调试]] [MiNoteService] 解析响应JSON，响应长度: {data.count}`

**9.14 返回响应**
- 位置：`MiNoteService.swift` - `updateNote` 方法
- 返回解析后的JSON字典
- **需要添加日志**：`[[调试]] [MiNoteService] 返回响应，code: {json["code"] ?? "无"}`

### 阶段10：处理服务器响应

**10.1 检查响应code**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 检查响应的 `code` 字段是否为0（成功）
- **需要添加日志**：`[[调试]] [VIEWMODEL] 检查响应code，code: {code}, 是否成功: {code == 0}`

**10.2 提取响应数据**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 从响应的 `data.entry` 中提取更新后的数据
- **需要添加日志**：`[[调试]] [VIEWMODEL] 提取响应数据，entry字段存在: {entry != nil}`

**10.3 更新rawData**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 合并服务器返回的数据到 `rawData`，更新 `tag` 和 `modifyDate`
- **需要添加日志**：`[[调试]] [VIEWMODEL] 更新rawData，tag: {updatedRawData["tag"] ?? "无"}, modifyDate: {updatedRawData["modifyDate"] ?? "无"}`

**10.4 更新笔记对象**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 更新 `updatedNote` 的 `rawData`、`updatedAt` 和 `content`（如果响应中包含）
- **需要添加日志**：`[[调试]] [VIEWMODEL] 更新笔记对象，updatedAt: {updatedNote.updatedAt}`

**10.5 保存更新后的笔记到本地**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 再次调用 `localStorage.saveNote(updatedNote)` 保存服务器返回的最新数据
- **需要添加日志**：`[[调试]] [VIEWMODEL] 保存更新后的笔记到本地，笔记ID: {updatedNote.id}`

**10.6 更新UI状态**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 更新 `notes` 数组和 `selectedNote`
- **需要添加日志**：`[[调试]] [VIEWMODEL] 更新UI状态，笔记ID: {updatedNote.id}`

**10.7 上传成功**
- 位置：`NotesViewModel.swift` - `updateNote` 方法
- 打印成功日志
- **需要添加日志**：`[[调试]] [VIEWMODEL] 笔记更新成功，笔记ID: {note.id}, tag: {updatedNote.rawData?["tag"] as? String ?? "无"}`

### 阶段11：错误处理

**11.1 网络错误处理**
- 位置：`NotesViewModel.swift` - `updateNote` 方法的catch块
- 如果是网络错误，添加到离线队列
- **需要添加日志**：`[[调试]] [VIEWMODEL] 网络错误，添加到离线队列，笔记ID: {note.id}, 错误: {error.localizedDescription}`

**11.2 Cookie失效处理**
- 位置：`NotesViewModel.swift` - `updateNote` 方法的catch块
- 如果是Cookie失效，添加到离线队列
- **需要添加日志**：`[[调试]] [VIEWMODEL] Cookie失效，添加到离线队列，笔记ID: {note.id}`

**11.3 其他错误处理**
- 位置：`NotesViewModel.swift` - `updateNote` 方法的catch块
- 静默处理其他错误
- **需要添加日志**：`[[调试]] [VIEWMODEL] 更新笔记失败，笔记ID: {note.id}, 错误: {error.localizedDescription}`

### 阶段12：保存完成回调

**12.1 更新原始值**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法
- 保存成功后，更新 `originalTitle` 和 `originalAttributedText`，避免重复保存
- **需要添加日志**：`[[调试]] 更新原始值，originalTitle: {originalTitle}, originalAttributedText长度: {originalAttributedText.characters.count}`

**12.2 显示保存成功提示**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法
- 设置 `showSaveSuccess = true`，显示成功提示
- **需要添加日志**：`[[调试]] 显示保存成功提示，笔记ID: {note.id}`

**12.3 保存完成**
- 位置：`NoteDetailView.swift` - `performSave(for: note)` 方法
- 设置 `isSaving = false` 和 `isUploading = false`
- **需要添加日志**：`[[调试]] 保存完成，笔记ID: {note.id}, title: {editedTitle}, content长度: {xmlContent.count}`

## 切换笔记时的保存流程

### 阶段13：切换笔记前的保存

**13.1 检测笔记切换**
- 位置：`NoteDetailView.swift` - `handleSelectedNoteChange` 方法
- 检测 `viewModel.selectedNote` 的变化
- **需要添加日志**：`[[调试]] 检测笔记切换，旧笔记ID: {oldNote?.id ?? "无"}, 新笔记ID: {newNote?.id ?? "无"}`

**13.2 检查是否需要保存**
- 位置：`NoteDetailView.swift` - `saveCurrentNoteBeforeSwitching` 方法
- 检查当前笔记是否有未保存的更改
- **需要添加日志**：`[[调试]] 检查是否需要保存，当前笔记ID: {currentNoteId}, 新笔记ID: {newNoteId}, 标题变化: {hasTitleChanges}, 内容变化: {hasContentChanges}`

**13.3 从编辑器获取最新内容（切换前）**
- 位置：`NoteDetailView.swift` - `saveCurrentNoteBeforeSwitching` 方法
- 如果使用RichTextKit，从 `editorContext` 获取最新内容
- **需要添加日志**：`[[调试]] 切换前从editorContext获取内容，context长度: {contextAttributedString.length}`

**13.4 执行切换前保存**
- 位置：`NoteDetailView.swift` - `saveCurrentNoteBeforeSwitching` 方法
- 调用 `performSave(for: currentNote)` 保存当前笔记
- **需要添加日志**：`[[调试]] 执行切换前保存，当前笔记ID: {currentNote.id}`

**13.5 等待保存完成**
- 位置：`NoteDetailView.swift` - `handleSelectedNoteChange` 方法
- 等待保存任务完成后再加载新笔记
- **需要添加日志**：`[[调试]] 等待切换前保存完成，保存任务存在: {saveTask != nil}`

**13.6 加载新笔记内容**
- 位置：`NoteDetailView.swift` - `loadNoteContent` 方法
- 加载新笔记的内容到编辑器
- **需要添加日志**：`[[调试]] 加载新笔记内容，笔记ID: {note.id}, 标题: {note.title}`

**13.7 从数据库加载RTF数据**
- 位置：`NoteDetailView.swift` - `loadNoteContent` 方法
- 优先从 `note.rtfData` 加载，否则从XML转换
- **需要添加日志**：`[[调试]] 从数据库加载RTF数据，rtfData存在: {note.rtfData != nil}, XML长度: {note.primaryXMLContent.count}`

**13.8 转换并设置编辑器内容**
- 位置：`NoteDetailView.swift` - `loadNoteContent` 方法
- 将RTF或XML转换为AttributedString，设置到编辑器
- **需要添加日志**：`[[调试]] 转换并设置编辑器内容，editedAttributedText长度: {editedAttributedText.characters.count}`

**13.9 初始化完成**
- 位置：`NoteDetailView.swift` - `loadNoteContent` 方法
- 设置 `isInitializing = false`，允许用户编辑
- **需要添加日志**：`[[调试]] 笔记加载完成，笔记ID: {note.id}, 初始化完成`

## 关键问题点

根据流程分析，可能导致"修改丢失"的问题点：

1. **切换笔记时保存时机**：在 `handleSelectedNoteChange` 中，保存任务可能没有正确等待完成
2. **编辑器内容获取**：从 `editorContext` 获取内容时可能获取到旧内容
3. **状态同步**：`editedRTFData`、`editedAttributedText` 和 `originalAttributedText` 可能不同步
4. **数据库保存**：虽然保存到数据库，但切换回来时可能从XML重新加载，丢失RTF格式

## 建议的日志添加位置

所有日志都应该以 `[[调试]]` 开头，方便在控制台中搜索和过滤。建议使用统一的日志格式：

```swift
print("[[调试]] [模块名] 操作描述，关键参数: {参数值}")
```

例如：
```swift
print("[[调试]] [NoteDetailView] 用户输入文本，编辑器内容长度: \(contextAttributedString.length)")
print("[[调试]] [VIEWMODEL] 保存到本地数据库，笔记ID: \(note.id)")
print("[[调试]] [MiNoteService] 发送网络请求，笔记ID: \(noteId)")
```

