# 格式逻辑对比分析

## 一、当前实现（editor.html - FormatManager）

### 核心架构
- **FormatManager 类**：统一管理所有格式操作
- **pendingFormats 对象**：存储"即将输入的格式状态"
- **formatCommands 映射**：定义每种格式的命令、标签、样式

### 格式状态管理逻辑

#### 1. 格式切换（toggleFormat）

**有选中文本时：**
- 调用 `toggleSelectedTextFormat(formatType, range)`
- 使用 `document.execCommand(formatConfig.command)` 切换选中文本的格式
- 高亮使用特殊处理：检查并添加/移除高亮 span

**无选中文本时：**
- 切换 `pendingFormats[formatType]` 状态
- 如果启用格式：调用 `insertFormatMarker()` 插入格式标记（零宽度空格 + 格式元素）
- 如果禁用格式：调用 `removeFormatMarker()` 移除格式标记或将光标移出格式元素

#### 2. 插入格式标记（insertFormatMarker）

**非高亮格式（加粗、斜体、下划线、删除线）：**
1. 检查光标位置是否已在格式元素内
2. 如果不在，插入零宽度空格文本节点
3. 使用 `document.execCommand()` 应用格式
4. 将光标移到格式元素内的文本节点

**高亮格式：**
1. 创建 `<span class="mi-note-highlight">` 元素
2. 插入零宽度空格文本节点
3. 将光标移到高亮 span 内

#### 3. 移除格式标记（removeFormatMarker）

**情况1：格式元素内只有零宽度空格**
- 移除格式元素
- 将光标移到父元素

**情况2：格式元素内有实际文本**
- 在格式元素后插入新的文本节点（零宽度空格）
- 将光标移到新文本节点
- 这样新输入的文本不会继承格式

#### 4. 输入时格式处理（input 事件）

**检查逻辑：**
- 遍历所有格式类型（highlight, bold, italic, underline, strikethrough）
- 对于每个格式：
  - **如果格式已启用**：检查文本节点是否在格式元素内，如果不在则创建格式元素并包裹
  - **如果格式已禁用**：检查文本节点是否在格式元素内，如果在则移出格式元素

**处理顺序：**
- 按优先级顺序处理：highlight → bold → italic → underline → strikethrough
- 外层格式优先（高亮在最外层）

#### 5. 格式状态检测（getCurrentFormatState）

**无选中文本时：**
- 返回 `pendingFormats` 状态（用户手动设置的状态）

**有选中文本时：**
- 向上遍历 DOM 树，检测格式元素（标签、类名、样式）
- 返回检测到的格式状态

### 潜在问题

1. **时序问题**：`insertFormatMarker` 中使用 `document.execCommand` 后，光标位置可能不准确
2. **DOM 操作复杂性**：在 `input` 事件中频繁检查和修复格式，可能导致性能问题
3. **多格式嵌套**：多个格式同时启用时，嵌套顺序可能不正确
4. **边界情况**：光标在格式元素边界时，行为可能不一致

---

## 二、CKEditor 5 实现（new_editor.html）

### 核心架构
- **数据模型（Model）**：使用独立的数据模型表示文档结构
- **视图（View）**：将数据模型渲染为 DOM
- **命令系统**：每个格式操作对应一个命令（Command）
- **状态管理**：格式状态存储在数据模型中，而不是 DOM

### 格式状态管理逻辑

#### 1. 格式切换

**CKEditor 5 的命令系统：**
- 每个格式（bold, italic, underline 等）都有对应的命令
- 命令检查当前选择位置的格式状态
- 如果格式已启用，则移除；如果未启用，则应用

**状态检测：**
- 使用数据模型检查格式属性，而不是 DOM 遍历
- 格式状态存储在模型节点上，查询速度快且准确

#### 2. 输入时格式处理

**CKEditor 5 的输入处理：**
- 输入时，新文本自动继承光标位置的格式属性
- 格式属性存储在数据模型中，不依赖 DOM 结构
- 输入后，模型自动更新，视图自动同步

#### 3. 格式状态检测

**CKEditor 5 的状态检测：**
- 直接从数据模型查询格式属性
- 不依赖 DOM 遍历，性能更好
- 状态检测准确，不受 DOM 结构影响

### 优势

1. **数据模型与视图分离**：格式状态存储在模型中，不依赖 DOM
2. **命令系统**：统一的命令接口，易于扩展和维护
3. **自动同步**：模型变化自动同步到视图，视图变化自动同步到模型
4. **性能优化**：不依赖 DOM 遍历，查询速度快
5. **状态一致性**：格式状态始终与数据模型一致，不会出现不一致的情况

---

## 三、关键差异对比

| 特性 | 当前实现（FormatManager） | CKEditor 5 |
|------|-------------------------|------------|
| **状态存储** | `pendingFormats` 对象 + DOM 结构 | 数据模型（Model） |
| **格式检测** | DOM 遍历（向上查找格式元素） | 模型属性查询 |
| **输入处理** | `input` 事件中检查和修复格式 | 模型自动继承格式属性 |
| **格式切换** | `document.execCommand` + DOM 操作 | 命令系统（Command） |
| **多格式嵌套** | 手动处理嵌套顺序 | 模型自动处理 |
| **状态一致性** | 依赖 DOM 和 `pendingFormats` 同步 | 模型和视图自动同步 |
| **性能** | DOM 操作较多，可能影响性能 | 模型操作，性能更好 |
| **复杂度** | 需要手动处理各种边界情况 | 框架自动处理 |

---

## 四、当前实现的问题分析

### 1. 偶现 Bug 的可能原因

**问题1：时序问题**
- `insertFormatMarker` 中，`document.execCommand` 是异步的
- 光标位置设置可能在格式应用完成前执行
- 导致光标位置不准确

**问题2：DOM 结构变化**
- `input` 事件中检查和修复格式时，DOM 可能正在变化
- `setTimeout` 延迟可能导致检查时机不准确
- 多个格式同时处理时，DOM 结构可能被多次修改

**问题3：格式元素嵌套**
- 多个格式同时启用时，嵌套顺序可能不正确
- 例如：加粗和斜体同时启用，可能出现 `<b><i>` 或 `<i><b>`，顺序不一致

**问题4：边界情况**
- 光标在格式元素边界时（如 `<b>AAA</b>|`），行为可能不一致
- 格式元素内只有零宽度空格时，移除逻辑可能不准确

### 2. 与 CKEditor 5 的差异

**CKEditor 5 的优势：**
1. **数据模型驱动**：格式状态存储在模型中，不依赖 DOM
2. **命令系统**：统一的命令接口，状态切换更可靠
3. **自动同步**：模型和视图自动同步，不会出现不一致
4. **性能优化**：不依赖 DOM 遍历，查询和操作更快

**当前实现的改进方向：**
1. **引入数据模型**：将格式状态从 DOM 中分离出来
2. **统一命令系统**：使用命令模式处理格式操作
3. **减少 DOM 操作**：在输入事件中减少格式检查和修复
4. **改进时序控制**：确保格式应用和光标设置的顺序正确

---

## 五、建议的改进方案

### 方案1：参考 CKEditor 5 的架构（推荐）

1. **引入轻量级数据模型**：
   - 维护一个格式状态对象，独立于 DOM
   - 输入时，根据格式状态应用格式，而不是检查 DOM

2. **改进命令系统**：
   - 统一使用命令处理格式操作
   - 命令负责状态更新和 DOM 操作

3. **优化输入处理**：
   - 在 `beforeinput` 事件中应用格式（而不是 `input` 事件）
   - 减少 DOM 检查和修复

### 方案2：改进当前实现（渐进式）

1. **改进时序控制**：
   - 使用 `requestAnimationFrame` 或 `MutationObserver` 确保 DOM 更新完成
   - 改进 `insertFormatMarker` 中的光标设置逻辑

2. **优化格式检测**：
   - 缓存格式状态，减少 DOM 遍历
   - 使用 `document.queryCommandState()` 检测格式（更可靠）

3. **改进输入处理**：
   - 减少 `input` 事件中的格式检查和修复
   - 只在必要时（格式状态变化时）进行检查



