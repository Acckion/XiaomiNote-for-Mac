# 小米笔记旧版图片格式调查报告

## 调查目标

调查小米笔记旧版图片格式 `☺ fileId<0/></>` 在以下场景中的处理逻辑：
1. 是否能正确显示在笔记列表的预览中
2. 能否在转换为标准格式时正确添加 setting.data
3. 其他相关的旧版格式处理逻辑

## 旧版图片格式说明

### 格式定义
- **旧版格式**: `☺ fileId<0/><description/>` 或 `☺ fileId<imgshow/><description/>`
- **新版格式**: `<img fileid="fileId" imgshow="0" imgdes="description" />`

### 格式特点
- 使用特殊字符 `☺` 作为标记
- fileId 后跟 `<0/>` 或 `<imgshow/>` 标记
- description 可以是 `</>` (空描述)、`<[description]/>` (方括号包裹) 或 `<description/>` (标签名即内容)
- **关键问题**: 旧版格式不在 setting.data 中，只存在于 content 字段

## 调查结果

### 1. 笔记列表预览显示

#### 1.1 预览文本提取逻辑

**位置**: `Sources/View/SwiftUIViews/Note/NotesListView.swift`

```swift
private static func extractPreviewText(from xmlContent: String) -> String {
    guard !xmlContent.isEmpty else {
        return ""
    }
    
    // 移除 XML 标签，提取纯文本
    var text = xmlContent
        .replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression)
        .replacingOccurrences(of: "&amp;", with: "&")
        .replacingOccurrences(of: "&lt;", with: "<")
        .replacingOccurrences(of: "&gt;", with: ">")
        .replacingOccurrences(of: "&quot;", with: "\"")
        .replacingOccurrences(of: "&apos;", with: "'")
        .trimmingCharacters(in: .whitespacesAndNewlines)
    
    // 限制长度
    let maxLength = 50
    if text.count > maxLength {
        text = String(text.prefix(maxLength)) + "..."
    }
    
    return text
}
```

**问题**: 
- ✅ 旧版格式 `☺ fileId<0/></>` 会被正则表达式 `<[^>]+>` 移除标签部分
- ❌ 但是 `☺` 字符和 fileId 会残留在预览文本中
- ❌ 预览文本会显示类似 "☺ 1315204657.WoQvt7-vevfMveZJFbPN4g" 这样的内容

#### 1.2 图片缩略图显示逻辑

**位置**: `Sources/View/SwiftUIViews/Note/NotesListView.swift`

```swift
private func getFirstImageInfo(from note: Note) -> (fileId: String, fileType: String)? {
    guard let rawData = note.rawData,
          let setting = rawData["setting"] as? [String: Any],
          let settingData = setting["data"] as? [[String: Any]] else {
        return nil
    }
    
    // 查找第一张图片
    for imgData in settingData {
        if let fileId = imgData["fileId"] as? String,
           let mimeType = imgData["mimeType"] as? String,
           mimeType.hasPrefix("image/") {
            let fileType = String(mimeType.dropFirst("image/".count))
            return (fileId: fileId, fileType: fileType)
        }
    }
    
    return nil
}
```

**问题**:
- ❌ **完全依赖 setting.data**：只从 `rawData["setting"]["data"]` 中提取图片信息
- ❌ **旧版格式无法显示缩略图**：因为旧版格式不在 setting.data 中，所以无法提取图片信息
- ❌ **不会尝试从 content 中解析图片**：没有回退逻辑去解析 content 中的旧版格式

### 2. 旧版格式转换逻辑

#### 2.1 XML 规范化器 (XMLNormalizer)

**位置**: `Sources/Service/Editor/XMLNormalizer.swift`

```swift
private func normalizeImageFormat(_ xml: String) -> String {
    var result = xml
    
    // 1. 处理旧版图片格式：☺ fileId<0/><description/> 或 ☺ fileId<imgshow/><description/>
    // 正则表达式匹配旧版格式
    let oldFormatPattern = "☺\\s+([^<]+)<(0|imgshow)\\s*/><([^>]*)\\s*/>"
    
    if let regex = try? NSRegularExpression(pattern: oldFormatPattern, options: []) {
        let nsString = result as NSString
        let matches = regex.matches(in: result, options: [], range: NSRange(location: 0, length: nsString.length))
        
        // 从后往前替换，避免索引变化
        for match in matches.reversed() {
            let fullRange = match.range
            let fileIdRange = match.range(at: 1)
            let imgshowRange = match.range(at: 2)
            let descriptionRange = match.range(at: 3)
            
            let fileId = nsString.substring(with: fileIdRange).trimmingCharacters(in: .whitespaces)
            let imgshow = nsString.substring(with: imgshowRange)
            var description = nsString.substring(with: descriptionRange)
            
            // 处理描述：移除方括号
            if description.hasPrefix("[") && description.hasSuffix("]") {
                description = String(description.dropFirst().dropLast())
            }
            
            // 转换为新版格式
            var normalized = "<img fileid=\"\(fileId)\" imgshow=\"\(imgshow)\""
            if !description.isEmpty {
                normalized += " imgdes=\"\(description)\""
            }
            normalized += " />"
            
            result = (result as NSString).replacingCharacters(in: fullRange, with: normalized)
        }
    }
    
    return result
}
```

**功能**:
- ✅ **能够识别旧版格式**：正则表达式可以匹配 `☺ fileId<0/><description/>`
- ✅ **转换为新版格式**：将旧版格式转换为 `<img fileid="..." imgshow="..." imgdes="..." />`
- ✅ **保留描述信息**：正确提取并保留 description 字段
- ⚠️ **但不添加 setting.data**：只是格式转换，不会自动添加到 setting.data

#### 2.2 XML 解析器 (XMLTokenizer)

**位置**: `Sources/Service/Editor/Parser/XMLTokenizer.swift`

```swift
private func parseLegacyImage() throws -> XMLToken {
    // 跳过 ☺ 字符
    advance()
    
    // 跳过空白
    skipWhitespace()
    
    // 提取 fileId（直到 <0/> 标记）
    var fileId = ""
    while !isAtEnd {
        let char = currentChar
        
        // 检查是否到达 <0/> 标记
        if char == "<" {
            // 检查后续是否为 "0/>"
            let savedIndex = currentIndex
            advance()
            
            if !isAtEnd && currentChar == "0" {
                advance()
                if !isAtEnd && currentChar == "/" {
                    advance()
                    if !isAtEnd && currentChar == ">" {
                        advance()
                        // 找到 <0/> 标记
                        break
                    }
                }
            }
            
            // 不是 <0/> 标记，恢复位置并继续
            currentIndex = savedIndex
            fileId.append(char)
            advance()
        } else {
            fileId.append(char)
            advance()
        }
    }
    
    // 验证 fileId 不为空
    let trimmedFileId = fileId.trimmingCharacters(in: .whitespaces)
    guard !trimmedFileId.isEmpty else {
        throw TokenizerError.invalidLegacyImageFormat("缺少 fileId")
    }
    
    // 提取 description（支持三种格式）
    // 1. </>：空描述
    // 2. <[description]/>：方括号包裹的描述
    // 3. <description/>：标签名就是描述内容
    var description = ""
    
    // ... 解析 description 的逻辑 ...
    
    return .image(fileId: trimmedFileId, description: description, imgshow: "0")
}
```

**功能**:
- ✅ **能够解析旧版格式**：完整支持三种 description 格式
- ✅ **转换为 ImageNode**：解析后生成标准的 ImageNode AST 节点
- ✅ **保留所有信息**：fileId、description、imgshow 都被正确提取

#### 2.3 XML 生成器 (XMLGenerator)

**位置**: `Sources/Service/Editor/Generator/XMLGenerator.swift`

```swift
private func generateImage(_ node: ImageNode) -> String {
    var attributes: [String] = []
    
    // 优先使用 fileId（小米笔记格式）
    if let fileId = node.fileId {
        attributes.append("fileid=\"\(encodeXMLEntities(fileId))\"")
        
        // 添加描述（只在有值时添加，避免生成空属性）
        if let description = node.description, !description.isEmpty {
            attributes.append("imgdes=\"\(encodeXMLEntities(description))\"")
        }
        
        // 使用实际的 imgshow 值，如果没有则默认为 "0"
        let imgshowValue = node.imgshow ?? "0"
        attributes.append("imgshow=\"\(imgshowValue)\"")
    }
    
    return "<img \(attributes.joined(separator: " ")) />"
}
```

**功能**:
- ✅ **生成新版格式**：总是生成 `<img fileid="..." />` 格式
- ✅ **不会生成旧版格式**：即使输入是旧版格式，输出也是新版格式
- ⚠️ **但不添加 setting.data**：只负责 XML 生成，不处理 setting.data

### 3. 图片下载逻辑

#### 3.1 旧版格式图片下载

**位置**: `Sources/Service/Sync/SyncService.swift`

```swift
/// 从content中提取并下载旧版格式的图片
/// 旧版格式: ☺ fileId<0/></>
private func downloadLegacyFormatImages(from content: String, forceRedownload: Bool) async {
    print("[SYNC] 检查旧版格式图片...")
    
    // 使用正则表达式提取旧版格式的图片ID
    // 格式: ☺ fileId<0/></>
    let pattern = "☺ ([^<]+)<0/></>"
    guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else {
        return
    }
    
    let nsContent = content as NSString
    let matches = regex.matches(in: content, options: [], range: NSRange(location: 0, length: nsContent.length))
    
    if matches.isEmpty {
        print("[SYNC] 未找到旧版格式图片")
        return
    }
    
    print("[SYNC] 找到 \(matches.count) 个旧版格式图片")
    
    for match in matches {
        let fileIdRange = match.range(at: 1)
        let fileId = nsContent.substring(with: fileIdRange).trimmingCharacters(in: .whitespaces)
        
        print("[SYNC] 处理旧版格式图片: \(fileId)")
        
        // 检查图片是否已存在且有效
        var imageExists = false
        let formats = ["jpeg", "jpg", "png", "gif", "webp"]
        for format in formats {
            if localStorage.validateImage(fileId: fileId, fileType: format) {
                print("[SYNC] 旧版格式图片已存在且有效，跳过下载: \(fileId).\(format)")
                imageExists = true
                break
            }
        }
        
        if imageExists && !forceRedownload {
            continue
        }
        
        // 下载图片
        do {
            print("[SYNC] 开始下载旧版格式图片: \(fileId)")
            let imageData = try await downloadImageWithRetry(fileId: fileId, type: "note_img")
            print("[SYNC] 旧版格式图片下载完成，大小: \(imageData.count) 字节")
            
            // 默认保存为 jpeg 格式
            try localStorage.saveImage(imageData: imageData, fileId: fileId, fileType: "jpeg")
            print("[SYNC] 旧版格式图片保存成功: \(fileId).jpeg")
        } catch {
            print("[SYNC] 旧版格式图片下载失败: \(fileId), 错误: \(error.localizedDescription)")
        }
    }
}
```

**功能**:
- ✅ **能够识别旧版格式**：使用正则表达式从 content 中提取 fileId
- ✅ **下载图片文件**：调用 API 下载图片并保存到本地
- ✅ **避免重复下载**：检查本地是否已存在
- ❌ **但不更新 setting.data**：只下载文件，不会将图片信息添加到 setting.data

#### 3.2 调用时机

**位置**: `Sources/Service/Sync/SyncService.swift`

```swift
// 在 downloadNoteImages 方法中调用
// 首先尝试从 content 中提取旧版格式的图片
if let content = entry["content"] as? String {
    await downloadLegacyFormatImages(from: content, forceRedownload: forceRedownload)
}
```

**问题**:
- ✅ **会自动下载**：同步笔记时会自动检测并下载旧版格式图片
- ❌ **不会更新 setting.data**：下载后不会将图片信息添加到 setting.data
- ❌ **导致缩略图无法显示**：因为列表视图依赖 setting.data 来显示缩略图

### 4. 测试覆盖情况

#### 4.1 旧版格式解析测试

**位置**: `Tests/NativeEditorTests/LegacyImageFormatTests.swift`

```swift
/// 测试标准旧格式图片解析（带描述）
func testParseLegacyFormat_WithDescription() throws {
    let xml = "☺ 1315204657.HNpRlTMs5W8A92Ia-FARIw<0/><[我的照片]/>"
    let result = try parser.parse(xml)
    let document = result.value
    
    XCTAssertEqual(document.blocks.count, 1, "应该解析出一个块级节点")
    
    guard let imageNode = document.blocks.first as? ImageNode else {
        XCTFail("应该是 ImageNode 类型")
        return
    }
    
    XCTAssertEqual(imageNode.fileId, "1315204657.HNpRlTMs5W8A92Ia-FARIw", "fileId 应该正确提取")
    XCTAssertEqual(imageNode.description, "我的照片", "description 应该正确提取")
}
```

**覆盖范围**:
- ✅ 旧版格式解析
- ✅ 带描述、空描述、特殊字符
- ✅ 新旧格式混合
- ❌ **未测试 setting.data 生成**
- ❌ **未测试列表预览显示**

#### 4.2 XML 规范化测试

**位置**: `Tests/NativeEditorTests/XMLNormalizerTests.swift`

```swift
/// 测试：旧版图片格式转换
func testOldImageFormatConversion() {
    let oldFormat = "☺ 123<0/><图片描述/>"
    
    let normalized = normalizer.normalize(oldFormat)
    
    // 验证转换为新版格式
    XCTAssertTrue(normalized.contains("<img"), "应该转换为新版 img 标签")
    XCTAssertTrue(normalized.contains("fileid=\"123\""), "应该包含 fileid 属性")
    XCTAssertTrue(normalized.contains("imgshow=\"0\""), "应该包含 imgshow 属性")
    XCTAssertTrue(normalized.contains("imgdes=\"图片描述\""), "应该包含 imgdes 属性")
}
```

**覆盖范围**:
- ✅ 格式转换正确性
- ✅ 属性保留
- ❌ **未测试 setting.data 生成**

## 问题总结

### 核心问题

1. **列表预览文本显示异常**
   - 旧版格式的 `☺ fileId` 会残留在预览文本中
   - 应该被完全过滤掉，或者显示为 "[图片]" 占位符

2. **列表缩略图无法显示**
   - `getFirstImageInfo` 完全依赖 `setting.data`
   - 旧版格式不在 `setting.data` 中，导致无法提取图片信息
   - 即使图片文件已下载到本地，也无法显示缩略图

3. **setting.data 不会自动生成**
   - XML 规范化器只做格式转换，不生成 `setting.data`
   - 图片下载逻辑只下载文件，不更新 `setting.data`
   - 导致旧版格式图片永远无法在列表中显示缩略图

4. **格式转换不完整**
   - 旧版格式可以被解析和转换为新版格式
   - 但转换只发生在编辑器层面（AST → XML）
   - 不会同步更新笔记的 `rawData` 和 `setting.data`

### 影响范围

1. **笔记列表视图**
   - ❌ 预览文本显示异常（包含 fileId）
   - ❌ 缩略图无法显示
   - ❌ 图片信息哈希值为 "no_images"

2. **笔记编辑器**
   - ✅ 可以正确解析和显示旧版格式图片
   - ✅ 保存时会转换为新版格式
   - ⚠️ 但不会更新 setting.data

3. **同步服务**
   - ✅ 会自动下载旧版格式图片文件
   - ❌ 不会更新 setting.data
   - ❌ 导致列表视图无法显示

## 建议修复方案

### 方案 1: 在同步时自动生成 setting.data（推荐）

**位置**: `Sources/Service/Sync/SyncService.swift`

在 `downloadLegacyFormatImages` 方法中，下载图片后自动更新 `setting.data`：

```swift
private func downloadLegacyFormatImages(from content: String, forceRedownload: Bool) async -> [[String: Any]]? {
    // ... 现有的下载逻辑 ...
    
    var settingDataEntries: [[String: Any]] = []
    
    for match in matches {
        let fileId = // ... 提取 fileId ...
        
        // 下载图片
        do {
            let imageData = try await downloadImageWithRetry(fileId: fileId, type: "note_img")
            try localStorage.saveImage(imageData: imageData, fileId: fileId, fileType: "jpeg")
            
            // 生成 setting.data 条目
            let entry: [String: Any] = [
                "fileId": fileId,
                "mimeType": "image/jpeg",
                "size": imageData.count
            ]
            settingDataEntries.append(entry)
        } catch {
            // ... 错误处理 ...
        }
    }
    
    return settingDataEntries.isEmpty ? nil : settingDataEntries
}
```

然后在调用处合并到现有的 `setting.data`：

```swift
// 下载旧版格式图片，并获取生成的 setting.data
if let content = entry["content"] as? String,
   let legacyImageData = await downloadLegacyFormatImages(from: content, forceRedownload: forceRedownload) {
    // 合并到现有的 setting.data
    var existingData = updatedSettingData ?? []
    existingData.append(contentsOf: legacyImageData)
    updatedSettingData = existingData
}
```

### 方案 2: 在列表视图中添加回退逻辑

**位置**: `Sources/View/SwiftUIViews/Note/NotesListView.swift`

修改 `getFirstImageInfo` 方法，添加从 content 解析旧版格式的回退逻辑：

```swift
private func getFirstImageInfo(from note: Note) -> (fileId: String, fileType: String)? {
    // 首先尝试从 setting.data 获取
    if let rawData = note.rawData,
       let setting = rawData["setting"] as? [String: Any],
       let settingData = setting["data"] as? [[String: Any]] {
        for imgData in settingData {
            if let fileId = imgData["fileId"] as? String,
               let mimeType = imgData["mimeType"] as? String,
               mimeType.hasPrefix("image/") {
                let fileType = String(mimeType.dropFirst("image/".count))
                return (fileId: fileId, fileType: fileType)
            }
        }
    }
    
    // 回退：从 content 中解析旧版格式
    let pattern = "☺\\s+([^<]+)<0/>"
    if let regex = try? NSRegularExpression(pattern: pattern, options: []),
       let match = regex.firstMatch(in: note.content, options: [], range: NSRange(location: 0, length: (note.content as NSString).length)) {
        let fileId = (note.content as NSString).substring(with: match.range(at: 1)).trimmingCharacters(in: .whitespaces)
        
        // 尝试多种格式
        let formats = ["jpeg", "jpg", "png", "gif", "webp"]
        for format in formats {
            if LocalStorageService.shared.validateImage(fileId: fileId, fileType: format) {
                return (fileId: fileId, fileType: format)
            }
        }
    }
    
    return nil
}
```

### 方案 3: 改进预览文本提取

**位置**: `Sources/View/SwiftUIViews/Note/NotesListView.swift`

修改 `extractPreviewText` 方法，过滤旧版图片格式：

```swift
private static func extractPreviewText(from xmlContent: String) -> String {
    guard !xmlContent.isEmpty else {
        return ""
    }
    
    // 先移除旧版图片格式
    var text = xmlContent
    let legacyImagePattern = "☺\\s+[^<]+<[^>]+>"
    text = text.replacingOccurrences(of: legacyImagePattern, with: "[图片]", options: .regularExpression)
    
    // 然后移除其他 XML 标签
    text = text
        .replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression)
        .replacingOccurrences(of: "&amp;", with: "&")
        .replacingOccurrences(of: "&lt;", with: "<")
        .replacingOccurrences(of: "&gt;", with: ">")
        .replacingOccurrences(of: "&quot;", with: "\"")
        .replacingOccurrences(of: "&apos;", with: "'")
        .trimmingCharacters(in: .whitespacesAndNewlines)
    
    // 限制长度
    let maxLength = 50
    if text.count > maxLength {
        text = String(text.prefix(maxLength)) + "..."
    }
    
    return text
}
```

## 推荐实施顺序

1. **立即修复**: 方案 3（改进预览文本提取）
   - 影响最小，风险最低
   - 立即改善用户体验

2. **短期修复**: 方案 1（同步时生成 setting.data）
   - 根本解决问题
   - 确保数据完整性
   - 需要测试同步逻辑

3. **长期优化**: 方案 2（列表视图回退逻辑）
   - 作为兜底方案
   - 处理历史数据
   - 提高系统健壮性

## 测试建议

1. **添加集成测试**
   - 测试旧版格式笔记的完整流程
   - 从同步 → 列表显示 → 编辑 → 保存

2. **添加 UI 测试**
   - 验证列表预览文本正确性
   - 验证缩略图显示

3. **添加数据迁移测试**
   - 验证旧版格式自动转换
   - 验证 setting.data 正确生成

## 结论

旧版图片格式 `☺ fileId<0/></>` 的处理存在以下问题：

1. ❌ **列表预览显示异常**：fileId 会残留在预览文本中
2. ❌ **缩略图无法显示**：因为不在 setting.data 中
3. ✅ **编辑器可以正确处理**：解析、显示、转换都正常
4. ✅ **图片文件会自动下载**：同步时会下载到本地
5. ❌ **setting.data 不会自动生成**：导致列表视图无法使用

建议按照上述方案进行修复，优先解决预览文本显示问题，然后在同步时自动生成 setting.data，最后添加列表视图的回退逻辑作为兜底。
