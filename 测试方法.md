# 窗口管理重构 - 第一、二步骤测试方法

## 已完成的工作

### 第一步：创建窗口状态数据类型 ✅
已创建以下四个状态类文件：
1. `Sources/MiNoteLibrary/Window/MainWindowState.swift` - 主窗口状态
2. `Sources/MiNoteLibrary/Window/SidebarWindowState.swift` - 侧边栏窗口状态
3. `Sources/MiNoteLibrary/Window/NotesListWindowState.swift` - 笔记列表窗口状态
4. `Sources/MiNoteLibrary/Window/NoteDetailWindowState.swift` - 笔记详情窗口状态

所有类都实现了 `NSSecureCoding` 协议，支持安全的序列化和反序列化。

### 第二步：实现 NSWindow 扩展 ✅
已创建 `Sources/MiNoteLibrary/Extensions/NSWindow+MiNote.swift`，包含以下功能：
1. `setPointAndSizeAdjustingForScreen(point:size:minimumSize:)` - 调整窗口位置和大小以适应屏幕
2. `centerOnScreen(size:)` - 将窗口居中显示
3. `isFullyOnScreen` - 检查窗口是否完全在屏幕内
4. `adjustToFitScreen()` - 将窗口调整到屏幕内
5. `savableState` - 获取窗口的保存状态
6. `restoreState(from:)` - 从保存的状态恢复窗口

## 测试方法

### 1. 编译测试
首先验证项目是否可以正常编译：

```bash
cd /Users/acckion/Desktop/SwiftUI-MiNote-for-Mac
xcodebuild -project MiNoteMac.xcodeproj -scheme MiNoteMac build
```

预期结果：编译成功，只有一些无关的警告。

### 2. 状态类功能测试
运行概念验证测试脚本：

```bash
cd /Users/acckion/Desktop/SwiftUI-MiNote-for-Mac
# 由于测试脚本需要访问项目模块，建议在 Xcode 中创建单元测试
# 或者使用以下命令编译并运行测试：
swiftc -o test_window_state test_window_state.swift -F . -framework MiNoteLibrary 2>/dev/null || echo "需要 Xcode 项目环境"
```

更推荐的方法是在 Xcode 中创建单元测试：

### 3. Xcode 单元测试步骤
1. 打开 Xcode 项目：`MiNoteMac.xcodeproj`
2. 导航到测试导航器（⌘+6）
3. 创建新的测试文件：`WindowStateTests.swift`
4. 添加以下测试用例：

```swift
import XCTest
@testable import MiNoteLibrary

class WindowStateTests: XCTestCase {
    
    func testMainWindowStateCreation() {
        let state = MainWindowState.defaultState()
        XCTAssertFalse(state.isFullScreen)
        XCTAssertEqual(state.splitViewWidths, [200, 300, 600])
        XCTAssertFalse(state.isSidebarHidden)
    }
    
    func testSidebarWindowStateSerialization() {
        let sidebarState = SidebarWindowState(
            selectedFolderId: "test-folder",
            expandedFolderIds: ["folder1", "folder2"]
        )
        
        let data = try! NSKeyedArchiver.archivedData(
            withRootObject: sidebarState,
            requiringSecureCoding: true
        )
        
        let decodedState = try! NSKeyedUnarchiver.unarchivedObject(
            ofClass: SidebarWindowState.self,
            from: data
        )
        
        XCTAssertEqual(decodedState?.selectedFolderId, "test-folder")
        XCTAssertEqual(decodedState?.expandedFolderIds.count, 2)
    }
    
    func testMainWindowStateSerialization() {
        let mainState = MainWindowState(
            isFullScreen: true,
            splitViewWidths: [250, 350, 700],
            isSidebarHidden: true,
            sidebarWindowState: SidebarWindowState(
                selectedFolderId: "folder1",
                expandedFolderIds: []
            ),
            notesListWindowState: NotesListWindowState(
                selectedNoteId: "note1",
                scrollPosition: 100.0
            ),
            noteDetailWindowState: NoteDetailWindowState(
                scrollPosition: 50.0,
                isShowingExtractedContent: true
            )
        )
        
        let data = try! NSKeyedArchiver.archivedData(
            withRootObject: mainState,
            requiringSecureCoding: true
        )
        
        let decodedState = try! NSKeyedUnarchiver.unarchivedObject(
            ofClass: MainWindowState.self,
            from: data
        )
        
        XCTAssertTrue(decodedState?.isFullScreen ?? false)
        XCTAssertEqual(decodedState?.splitViewWidths, [250, 350, 700])
        XCTAssertTrue(decodedState?.isSidebarHidden ?? false)
    }
}
```

### 4. NSWindow 扩展功能测试
创建另一个测试文件测试 NSWindow 扩展：

```swift
import XCTest
import AppKit
@testable import MiNoteLibrary

class NSWindowExtensionTests: XCTestCase {
    
    func testWindowCentering() {
        let window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 800, height: 600),
            styleMask: [.titled, .closable, .miniaturizable, .resizable],
            backing: .buffered,
            defer: false
        )
        
        window.centerOnScreen(size: NSSize(width: 1000, height: 700))
        
        // 验证窗口在屏幕内
        XCTAssertTrue(window.isFullyOnScreen)
    }
    
    func testWindowAdjustment() {
        let window = NSWindow(
            contentRect: NSRect(x: -1000, y: -1000, width: 5000, height: 5000),
            styleMask: [.titled, .closable, .miniaturizable, .resizable],
            backing: .buffered,
            defer: false
        )
        
        window.adjustToFitScreen()
        
        // 验证窗口在屏幕内
        XCTAssertTrue(window.isFullyOnScreen)
    }
}
```

### 5. 手动功能测试
1. **状态序列化测试**：
   - 创建各种状态对象
   - 序列化为 Data
   - 反序列化回对象
   - 验证数据一致性

2. **NSWindow 扩展测试**：
   - 创建测试窗口
   - 调用 `setPointAndSizeAdjustingForScreen` 方法
   - 验证窗口位置和大小符合预期
   - 测试边缘情况（窗口超出屏幕边界）

### 6. 集成测试
在应用启动时添加临时代码测试状态管理：

```swift
// 在 AppDelegate 的 applicationDidFinishLaunching 中添加
let testState = MainWindowState.defaultState()
print("测试状态创建成功: \(testState.splitViewWidths)")

// 测试序列化
if let data = try? NSKeyedArchiver.archivedData(withRootObject: testState, requiringSecureCoding: true) {
    print("序列化成功，数据大小: \(data.count) 字节")
    
    if let decoded = try? NSKeyedUnarchiver.unarchivedObject(ofClass: MainWindowState.self, from: data) {
        print("反序列化成功，宽度: \(decoded.splitViewWidths)")
    }
}
```

## 测试验证要点

1. ✅ **状态类创建**：所有状态类都能正常实例化
2. ✅ **属性访问**：所有属性都能正确读写
3. ✅ **序列化/反序列化**：支持 NSSecureCoding 协议
4. ✅ **默认状态**：`defaultState()` 和 `emptyState()` 方法正常工作
5. ✅ **NSWindow 扩展**：所有扩展方法都能正常调用
6. ✅ **边界处理**：窗口位置和大小调整正确处理屏幕边界

## 下一步建议

完成测试后，可以继续实施：
1. **第三步：修改 AppDelegate** - 修改窗口关闭行为
2. **第四步：重构 MainWindowController** - 集成状态管理
3. **第五步：为视图控制器添加状态管理** - 完善状态恢复

测试通过后，请告知我继续实施后续步骤。
