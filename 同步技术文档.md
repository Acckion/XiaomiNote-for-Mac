# MiNote for Mac 同步系统技术文档

## 概述

MiNote for Mac 同步系统负责管理本地笔记与小米笔记云端的双向同步。系统设计为支持离线操作、冲突解决和高效增量同步。

## 架构设计

### 核心组件

1. **SyncService** - 同步服务主类
   - 管理所有同步操作
   - 维护同步状态
   - 处理冲突解决

2. **MiNoteService** - 小米笔记API服务
   - 处理所有网络请求
   - 管理认证状态（Cookie和ServiceToken）
   - 解析API响应

3. **LocalStorageService** - 本地存储服务
   - 管理本地笔记和文件夹
   - 处理图片下载和存储
   - 维护同步状态

4. **DatabaseService** - 数据库服务
   - SQLite数据库操作
   - 笔记和文件夹的CRUD操作
   - 同步状态持久化

5. **OfflineOperationQueue** - 离线操作队列
   - 管理网络断开时的操作
   - 支持操作重试
   - 确保数据一致性

## 同步类型

### 1. 完整同步 (Full Sync)

**触发条件**：
- 首次登陆账号同步
- 手动触发完整同步
- 同步状态丢失或损坏

**执行流程**：
1. 清除所有本地数据
2. 分页拉取云端所有笔记和文件夹
3. 下载笔记完整内容和图片
4. 保存同步状态（包括syncTag）

**API端点**：
- `/note/full/page` - 分页获取笔记

**关键特性**：
- 保证数据一致性
- 网络流量大
- 执行时间长

### 2. 增量同步 (Incremental Sync)

**触发条件**：
- 启动应用首次同步
- 用户手动触发增量同步

**执行流程**：
1. 分页拉取云端所有笔记和文件夹
2. 通过modifydate获取更新的笔记
3. 依次请求每一项更改的文件夹和笔记，并保存到本地(覆盖旧的内容)
4. 更新同步状态（包括syncTag）

**API端点**：
- `/note/full/page` - 使用syncTag获取增量数据

**冲突解决策略**：
- 时间戳比较：较新的版本优先
- 本地较新：添加到上传队列
- 云端较新：下载并覆盖本地
- 时间相同：比较内容，不同则使用云端版本

**与完整同步的区别**：
- 增量同步：通过判断时间戳来部分保存笔记
- 完整同步：保存全部笔记
- 相同点：API相同

### 3. 轻量级增量同步 (Lightweight Incremental Sync)

**触发条件**：
- 定时增量同步

**执行流程**：
1. 获取synctag
1.1. 如果没有synctag则执行增量同步来获取synctag
1.2. 如果数据库中有synctag则直接获取
3. 使用syncTag获取自上次同步以来的更改
3. 依次请求每一项更改的文件夹和笔记，并保存到本地
4. 支持删除同步

**API端点**：
- `/note/sync/full/` - 轻量级增量同步API

**优势**：
- 网络流量小
- 响应速度快
- 支持删除操作同步


## 同步状态管理

### SyncStatus 结构

```swift
struct SyncStatus: Codable {
    var lastSyncTime: Date?      // 上次同步时间
    var syncTag: String?         // 同步标记（用于增量同步）
    var lastPageSyncTime: Date?  // 上次分页同步时间
}
```

### syncTag 机制

**作用**：
- 标识同步位置
- 支持断点续传
- 确保数据一致性

**提取逻辑**：
1. 尝试旧API格式：`response["syncTag"]`
2. 尝试网页版API格式：`data.note_view.data.syncTag`
3. 尝试其他可能格式

**保存时机**：
- 完整同步完成时
- 增量同步完成时
- 每次API响应包含新syncTag时

## 冲突解决策略

### 时间戳比较策略

```swift
if localNote.updatedAt > cloudNote.updatedAt {
    // 本地较新，添加到上传队列
} else if cloudNote.updatedAt > localNote.updatedAt {
    // 云端较新，下载并覆盖本地
} else {
    // 时间相同，比较内容
    if localNote.content != cloudNote.content {
        // 内容不同，使用云端版本
    }
}
```

### 误差处理
- 允许2秒时间戳误差
- 误差内视为相同时间
- 需要比较完整内容

## 离线操作处理

### 操作类型

```swift
enum OfflineOperationType {
    case createNote      // 创建笔记
    case updateNote      // 更新笔记
    case deleteNote      // 删除笔记
    case createFolder    // 创建文件夹
    case renameFolder    // 重命名文件夹
    case deleteFolder    // 删除文件夹
}
```

### 队列管理

1. **添加操作**：网络失败时自动添加到队列
2. **重试机制**：网络恢复时自动重试
3. **状态持久化**：操作队列保存到数据库
4. **冲突避免**：避免重复操作

### 同步时机
- 应用启动时
- 网络恢复时
- 手动同步时

## 图片同步

### 图片信息提取

从笔记的 `setting.data` 字段提取：
- `fileId` - 文件ID
- `mimeType` - 文件类型
- 其他元数据

### 下载流程

1. 检查图片是否已存在本地
2. 下载图片数据
3. 保存到本地缓存目录
4. 更新笔记的 `setting.data` 字段

### 缓存策略
- 按 `fileId` 和文件类型存储
- 避免重复下载
- 支持离线访问

## 错误处理

### 错误类型

```swift
enum SyncError: LocalizedError {
    case alreadySyncing      // 同步正在进行中
    case notAuthenticated    // 未认证
    case invalidNoteData     // 笔记数据无效
    case cookieExpired       // Cookie过期
    case networkError(Error) // 网络错误
    case storageError(Error) // 存储错误
}
```

### 恢复策略

1. **认证错误**：提示用户重新登录
2. **网络错误**：添加到离线队列，稍后重试
3. **数据错误**：跳过错误条目，继续同步
4. **存储错误**：记录日志，尝试修复

### 重试机制
- 指数退避重试
- 最大重试次数限制
- 用户手动重试选项

## 性能优化

### 1. 分批处理
- 分页获取数据
- 限制单次请求数量
- 异步并发处理

### 2. 缓存策略
- 内存缓存频繁访问的数据
- 本地缓存图片和笔记内容
- 减少网络请求

### 3. 增量更新
- 只同步有变化的条目
- 避免全量数据比较
- 使用syncTag机制

### 4. 异步操作
- 使用Swift Concurrency
- 非阻塞UI操作
- 后台同步支持

## 调试和日志

### 日志级别

1. **INFO** - 正常操作日志
2. **WARNING** - 警告信息
3. **ERROR** - 错误信息
4. **DEBUG** - 调试信息

### 关键日志点

```swift
// 同步开始和结束
print("[SYNC] 开始执行完整同步")
print("[SYNC] 完整同步完成")

// syncTag提取
print("[SYNC] 🔍 开始提取syncTag，响应键: \(response.keys)")
print("[SYNC] ✅ 从旧API格式提取syncTag: \(oldSyncTag)")

// 数据库操作
print("[Database] 🔄 开始保存同步状态: syncTag=\(status.syncTag ?? "nil")")

// 图片下载
print("[SYNC] 开始下载图片: \(fileId).\(fileType)")
print("[SYNC] 图片下载完成，大小: \(imageData.count) 字节")
```

### 调试工具

1. **网络日志**：记录所有API请求和响应
2. **同步状态查看**：显示当前同步状态和syncTag
3. **离线队列监控**：查看待处理的操作
4. **性能统计**：同步时间和数据量统计

## 数据库设计

### sync_status 表

```sql
CREATE TABLE sync_status (
    id INTEGER PRIMARY KEY,
    last_sync_time REAL,      -- 上次同步时间（时间戳）
    sync_tag TEXT,            -- 同步标记
    last_page_sync_time REAL  -- 上次分页同步时间
);
```

### 笔记和文件夹表
- 支持快速查询和更新
- 维护时间戳信息
- 支持软删除

## 安全考虑

### 1. 数据加密
- 传输层使用HTTPS
- 敏感数据本地加密
- 认证信息安全存储

### 2. 权限控制
- 用户认证后才能同步
- Cookie自动刷新机制
- 访问令牌管理

### 3. 数据完整性
- 同步状态一致性检查
- 数据验证和清理
- 备份和恢复机制

## 未来改进

### 1. 实时同步
- WebSocket支持
- 推送通知
- 即时更新

### 2. 智能同步
- 基于使用频率的优先级
- 预测性预加载
- 自适应同步策略

### 3. 多设备同步
- 设备间冲突解决
- 选择性同步
- 设备管理

### 4. 性能监控
- 同步性能分析
- 资源使用监控
- 自动优化建议

## 附录

### API参考

#### 完整同步
- 端点：`/note/full/page`
- 参数：`syncTag`（可选，用于分页）
- 响应：包含笔记列表和新的syncTag

#### 增量同步
- 端点：`/note/sync/full/`
- 参数：`syncTag`（必需）
- 响应：包含有修改的条目和新的syncTag

#### 笔记详情
- 端点：`/note/detail`
- 参数：`noteId`
- 响应：笔记完整内容和图片信息

### 错误代码

| 代码 | 描述 | 处理建议 |
|------|------|----------|
| 0    | 成功 | - |
| 401  | 未认证 | 重新登录 |
| 403  | 权限不足 | 检查账号权限 |
| 404  | 资源不存在 | 清理本地数据 |
| 500  | 服务器错误 | 稍后重试 |

### 配置参数

```swift
// 同步配置
let syncConfig = [
    "maxRetryCount": 3,          // 最大重试次数
    "retryDelay": 5.0,           // 重试延迟（秒）
    "pageSize": 50,              // 每页大小
    "timeout": 30.0,             // 请求超时（秒）
    "enableBackgroundSync": true // 后台同步
]
```

---

*文档版本：1.0*
*最后更新：2026年1月6日*
*维护者：SyncService开发团队*
