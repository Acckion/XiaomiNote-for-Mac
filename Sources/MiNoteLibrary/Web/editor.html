<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>小米笔记编辑器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 浅色模式颜色变量 */
        :root {
            --bg-color: #fff;
            --text-color: #333;
            --bullet-color: #666;
            --quote-border: #ccc;
            --quote-text: #666;
            --hr-color: #ddd;
            --placeholder-color: #999;
        }
        
        /* 深色模式颜色变量 */
        html[data-color-scheme="dark"],
        :root[data-color-scheme="dark"] {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --bullet-color: #858585;
            --quote-border: #5a5a5a;
            --quote-text: #858585;
            --hr-color: #3e3e42;
            --placeholder-color: #6a6a6a;
            }
        }
        
        /* 确保body也应用深色模式 */
        html[data-color-scheme="dark"] body,
        :root[data-color-scheme="dark"] body {
            background-color: var(--bg-color);
            color: var(--text-color);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 0;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        
        #editor-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #editor-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            outline: none;
            min-height: 200px;
            color: var(--text-color);
            background-color: var(--bg-color);
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        
        /* 小米笔记样式 */
        .mi-note-text {
            margin-bottom: 8px;
            padding-left: 0;
        }
        
        .mi-note-text.indent-1 { padding-left: 0; }
        .mi-note-text.indent-2 { padding-left: 20px; }
        .mi-note-text.indent-3 { padding-left: 40px; }
        .mi-note-text.indent-4 { padding-left: 60px; }
        .mi-note-text.indent-5 { padding-left: 80px; }
        
        .mi-note-bullet, .mi-note-order, .mi-note-checkbox {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        
        .mi-note-bullet::before {
            content: "•";
            margin-right: 8px;
            color: var(--bullet-color);
            flex-shrink: 0;
        }
        
        .mi-note-order::before {
            content: attr(data-number) ".";
            margin-right: 8px;
            color: var(--bullet-color);
            min-width: 20px;
            text-align: right;
            flex-shrink: 0;
        }
        
        /* 确保有序列表和无序列表项即使为空也有可见的光标 */
        .mi-note-order:empty::after,
        .mi-note-bullet:empty::after {
            content: "\u200B"; /* 零宽度空格，确保光标可见 */
            display: inline;
        }
        
        /* 确保列表项内容区域可以正确显示光标 */
        .mi-note-order > *,
        .mi-note-bullet > * {
            flex: 1;
            min-width: 0;
        }
        
        .mi-note-checkbox {
            display: flex;
            align-items: center;
            position: relative;
        }
        
        .mi-note-checkbox input[type="checkbox"] {
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        /* 确保 checkbox 内容区域可以正确显示光标 */
        .mi-note-checkbox > *:not(input[type="checkbox"]) {
            flex: 1;
            min-width: 0;
        }
        
        .mi-note-hr {
            height: 1px;
            background-color: var(--hr-color);
            margin: 16px 0;
            border: none;
            transition: background-color 0.2s ease;
        }
        
        .mi-note-quote {
            border-left: 3px solid var(--quote-border);
            padding-left: 12px;
            margin: 8px 0;
            color: var(--quote-text);
            transition: border-color 0.2s ease, color 0.2s ease;
        }
        
        .mi-note-text.center {
            text-align: center;
        }
        
        .mi-note-text.right {
            text-align: right;
        }
        
        /* 富文本样式 */
        .mi-note-text b, .mi-note-text strong {
            font-weight: bold;
        }
        
        .mi-note-text i, .mi-note-text em {
            font-style: italic;
        }
        
        .mi-note-text u {
            text-decoration: underline;
        }
        
        .mi-note-text delete {
            text-decoration: line-through;
        }
        
        .mi-note-text .size-large {
            font-size: 24px;
            font-weight: bold;
        }
        
        .mi-note-text .size-mid {
            font-size: 20px;
            font-weight: bold;
        }
        
        .mi-note-text .size-h3 {
            font-size: 18px;
            font-weight: bold;
        }
        
        /* 图片样式 */
        .mi-note-image {
            max-width: 100%;
            height: auto;
            margin: 8px 0;
        }
        
        /* 占位符 */
        .placeholder {
            color: var(--placeholder-color);
        }
        
        /* 确保所有文本元素使用正确的颜色 */
        .mi-note-text,
        .mi-note-bullet,
        .mi-note-order,
        .mi-note-checkbox {
            color: var(--text-color);
        }
        
        /* 焦点样式 */
        #editor-content:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="editor-content" contenteditable="true" spellcheck="false" style="white-space: pre-wrap;">
            <!-- 内容将在这里动态加载 -->
        </div>
    </div>

    <script>
        // 全局变量
        let currentContent = '';
        let isInitialized = false;
        let isComposing = false; // 是否正在输入法组合输入（中文输入等）
        let isLoadingContent = false; // 是否正在从Swift加载内容（避免触发内容变化通知）
        let isFixingCursor = false; // 是否正在修复光标位置（避免触发内容变化通知）
        let orderCounter = 1;
        
        // 与Swift通信的桥接
        window.MiNoteWebEditor = {
            // 从Swift接收XML内容并渲染到编辑器
            loadContent: function(xmlContent) {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    console.error('[loadContent] ❌ 无法找到编辑器元素');
                    return '编辑器元素不存在';
                }
                
                console.log('[loadContent] ========== 开始加载内容 ==========');
                console.log('[loadContent] 传入XML长度:', xmlContent ? xmlContent.length : 0);
                console.log('[loadContent] 当前currentContent长度:', currentContent ? currentContent.length : 0);
                console.log('[loadContent] isInitialized:', isInitialized);
                
                // 如果内容没有实际变化，不需要重新加载，保持光标位置
                if (currentContent === xmlContent) {
                    console.log('[loadContent] ⚠️ 内容未变化，跳过加载');
                    return '内容未变化';
                }
                
                // 检查当前编辑器内容转换后的XML是否与传入的XML相同
                // 如果相同，说明内容来自用户编辑，不需要重新渲染
                // 但是，如果编辑器是空的或只有占位符，必须加载内容
                const currentHTML = editor.innerHTML.trim();
                const hasPlaceholder = currentHTML.includes('开始输入...') || currentHTML === '' || currentHTML === '<div class="placeholder">开始输入...</div>';
                console.log('[loadContent] 当前HTML长度:', currentHTML.length);
                console.log('[loadContent] 是否有占位符:', hasPlaceholder);
                
                // 如果编辑器是空的或只有占位符，或者还没有初始化，必须加载内容
                if (!hasPlaceholder && isInitialized) {
                    // 编辑器有实际内容且已初始化，检查是否与传入的XML相同
                    try {
                        const currentXML = convertHTMLToXML(editor);
                        console.log('[loadContent] 当前编辑器XML长度:', currentXML.length);
                        if (currentXML === xmlContent) {
                            // 内容相同，只是更新 currentContent，不重新渲染
                            currentContent = xmlContent;
                            console.log('[loadContent] ⚠️ 内容相同，跳过重新渲染');
                            return '内容相同，跳过重新渲染';
                        } else {
                            console.log('[loadContent] 内容不同，需要重新渲染');
                            console.log('[loadContent]   当前XML预览:', currentXML.substring(0, 100));
                            console.log('[loadContent]   传入XML预览:', xmlContent.substring(0, 100));
                        }
                    } catch (e) {
                        // 转换失败，继续加载
                        console.warn('[loadContent] ⚠️ 转换当前HTML到XML失败，继续加载:', e);
                    }
                } else {
                    console.log('[loadContent] 编辑器为空或未初始化，必须加载内容');
                }
                
                // 设置加载标志，避免在加载过程中触发内容变化通知
                isLoadingContent = true;
                console.log('[loadContent] 开始渲染XML到编辑器...');
                
                // 保存当前光标位置
                const savedSelection = saveSelection();
                
                currentContent = xmlContent;
                renderXMLToEditor(xmlContent);
                isInitialized = true;
                
                // 恢复光标位置并确保编辑器焦点
                if (savedSelection) {
                    // 延迟恢复，确保DOM已完全渲染
                    setTimeout(function() {
                        const editor = document.getElementById('editor-content');
                        restoreSelection(savedSelection);
                        // 确保编辑器保持焦点，这样 Enter 键才能正常工作
                        editor.focus();
                        
                        // 延迟重置加载标志，确保所有相关的事件都已处理
                        setTimeout(function() {
                            isLoadingContent = false;
                        }, 100);
                    }, 0);
                } else {
                    // 即使没有保存的选择，也确保编辑器有焦点
                    setTimeout(function() {
                        const editor = document.getElementById('editor-content');
                        editor.focus();
                        
                        // 延迟重置加载标志
                        setTimeout(function() {
                            isLoadingContent = false;
                        }, 100);
                    }, 0);
                }
                
                return '内容已加载';
            },
            
            // 获取当前编辑器的内容并转换为XML
            getContent: function() {
                const htmlContent = document.getElementById('editor-content').innerHTML;
                const xmlContent = convertHTMLToXML(htmlContent);
                console.log('转换为XML:', xmlContent.substring(0, 100) + '...');
                // 注意：不要在这里更新 currentContent，应该在 notifyContentChanged 中更新
                // 这样可以正确比较内容是否变化
                return xmlContent;
            },
            
            // 强制立即保存当前内容（用于切换笔记前）
            forceSaveContent: function() {
                console.log('[Editor] 强制保存当前内容');
                forceNotifyContentChanged();
                return '内容已强制保存';
            },
            
            // 执行格式操作（从原生工具栏调用）
            executeFormatAction: function(action, value) {
                console.log('执行格式操作:', action, value);
                return executeFormatCommand(action, value);
            },
            
            // 插入图片
            insertImage: function(imageUrl, altText) {
                console.log('插入图片:', imageUrl);
                return insertImageAtCursor(imageUrl, altText);
            },
            
            // 设置颜色方案（深色/浅色模式）
            setColorScheme: function(scheme) {
                console.log('[WebEditor] ========== 设置颜色方案 ==========');
                console.log('[WebEditor] 请求的方案:', scheme);
                
                const root = document.documentElement;
                const body = document.body;
                const oldScheme = root.getAttribute('data-color-scheme');
                console.log('[WebEditor] 当前颜色方案:', oldScheme, '-> 新方案:', scheme);
                
                // 设置属性到html和body元素
                if (scheme === 'dark') {
                    root.setAttribute('data-color-scheme', 'dark');
                    if (body) {
                        body.setAttribute('data-color-scheme', 'dark');
                    }
                    console.log('[WebEditor] ✅ 已设置为深色模式');
                } else {
                    root.setAttribute('data-color-scheme', 'light');
                    if (body) {
                        body.setAttribute('data-color-scheme', 'light');
                    }
                    console.log('[WebEditor] ✅ 已设置为浅色模式');
                }
                
                // 验证设置是否生效
                const actualScheme = root.getAttribute('data-color-scheme');
                console.log('[WebEditor] 验证: data-color-scheme =', actualScheme);
                
                // 检查CSS变量值
                const computedStyle = getComputedStyle(root);
                const bgColor = computedStyle.getPropertyValue('--bg-color').trim();
                const textColor = computedStyle.getPropertyValue('--text-color').trim();
                console.log('[WebEditor] CSS变量值:', {
                    '--bg-color': bgColor || '(未设置)',
                    '--text-color': textColor || '(未设置)',
                    'body背景色': body ? getComputedStyle(body).backgroundColor : 'N/A',
                    'body文字色': body ? getComputedStyle(body).color : 'N/A'
                });
                
                // 强制重新计算样式（触发重排）
                if (body) {
                    const display = body.style.display;
                    body.style.display = 'none';
                    void body.offsetHeight; // 触发重排
                    body.style.display = display;
                }
                
                // 再次检查CSS变量
                const bgColorAfter = getComputedStyle(root).getPropertyValue('--bg-color').trim();
                const textColorAfter = getComputedStyle(root).getPropertyValue('--text-color').trim();
                console.log('[WebEditor] 重排后CSS变量:', {
                    '--bg-color': bgColorAfter || '(未设置)',
                    '--text-color': textColorAfter || '(未设置)'
                });
                
                console.log('[WebEditor] =================================');
                return '颜色方案已设置为: ' + scheme;
            },
            
            // 检查编辑器状态
            getStatus: function() {
                return {
                    isInitialized: isInitialized,
                    hasContent: currentContent.length > 0,
                    selection: getSelectionInfo()
                };
            }
        };
        
        // 初始化编辑器
        document.addEventListener('DOMContentLoaded', function() {
            // 重写 console 方法以发送日志到 Swift
            function createLogSender(level) {
                const original = console[level];
                return function(...args) {
                    original.apply(console, args);
                    const message = args.map(arg => {
                        if (typeof arg === 'object') {
                            try { return JSON.stringify(arg); } catch(e) { return String(arg); }
                        }
                        return String(arg);
                    }).join(' ');
                    
                    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                        window.webkit.messageHandlers.editorBridge.postMessage({
                            type: 'log',
                            level: level,
                            message: message
                        });
                    }
                };
            }
            
            console.log = createLogSender('log');
            console.warn = createLogSender('warn');
            console.error = createLogSender('error');
            
            // 确保控制台能正常显示 - 输出大量测试日志
            console.log('Web编辑器已加载 (JS日志桥接已启用)');
            console.log('========================================');
            console.log('控制台测试日志 - 如果你看到这条消息，说明控制台工作正常');
            console.log('当前时间:', new Date().toLocaleString());
            console.log('用户代理:', navigator.userAgent);
            console.log('窗口大小:', window.innerWidth, 'x', window.innerHeight);
            console.log('========================================');
            
            setupEditor();
            
            // 初始化时使用浅色模式（Swift会在加载完成后设置正确的模式）
            document.documentElement.setAttribute('data-color-scheme', 'light');
            
            // 通知Swift编辑器已准备就绪
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                window.webkit.messageHandlers.editorBridge.postMessage({
                    type: 'editorReady',
                    timestamp: Date.now()
                });
            }
        });
        
        // 设置编辑器事件
        function setupEditor() {
            const editor = document.getElementById('editor-content');
            
            // 输入事件
            editor.addEventListener('input', function(e) {
                // 如果正在修复光标，不处理输入事件，避免循环
                if (isFixingCursor) {
                    return;
                }
                
                // 检查是否是 Enter 键导致的输入（换行）
                const isEnterInput = e.inputType === 'insertParagraph' || 
                                     e.inputType === 'insertLineBreak' ||
                                     (e.inputType && e.inputType.includes('paragraph'));
                
                // 如果是换行，立即确保光标位置正确（不等待防抖）
                if (isEnterInput && !isComposing) {
                    setTimeout(function() {
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            const range = selection.getRangeAt(0);
                            const editor = document.getElementById('editor-content');
                            
                            // 确保光标在编辑器中且位置正确
                            if (!editor.contains(range.commonAncestorContainer)) {
                                range.selectNodeContents(editor);
                                range.collapse(false);
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                            
                            // 确保编辑器保持焦点
                            editor.focus();
                        }
                    }, 0);
                }
                
                // 只有在非组合输入状态下才触发内容变化
                if (!isComposing && !isFixingCursor) {
                debounceContentChange();
                }
            });
            
            // 输入法组合开始（中文输入开始）
            editor.addEventListener('compositionstart', function(e) {
                isComposing = true;
                console.log('[Editor] 开始输入法组合输入');
            });
            
            // 输入法组合更新（中文输入过程中）
            editor.addEventListener('compositionupdate', function(e) {
                // 组合输入过程中，不触发内容变化
                // isComposing 已经在 compositionstart 中设置为 true
            });
            
            // 输入法组合结束（中文输入完成）
            editor.addEventListener('compositionend', function(e) {
                isComposing = false;
                console.log('[Editor] 输入法组合输入结束');
                // 组合输入结束后，延迟一点再触发内容变化，确保输入已完成
                setTimeout(function() {
                    debounceContentChange();
                }, 50);
            });
            
            // 选择变化事件
            document.addEventListener('selectionchange', function() {
                updateSelectionState();
                
                // 延迟检查列表项光标可见性（不在删除操作时立即检查）
                // 使用防抖，避免频繁检查
                clearTimeout(window.cursorCheckTimeout);
                window.cursorCheckTimeout = setTimeout(function() {
                    ensureListItemsHaveVisibleCursor();
                }, 100);
            });
            
            // 粘贴事件处理（特别是图片）
            editor.addEventListener('paste', function(e) {
                handlePaste(e);
            });
            
            // 按键事件
            editor.addEventListener('keydown', function(e) {
                handleKeyDown(e);
            });
            
            // 点击事件（处理checkbox等）
            editor.addEventListener('click', function(e) {
                handleClick(e);
            });
        }
        
        // 防抖内容变化
        let contentChangeTimeout;
        function debounceContentChange() {
            // 如果正在组合输入，不触发内容变化通知
            if (isComposing) {
                console.log('[Editor] 正在组合输入，跳过内容变化通知');
                return;
            }
            
            clearTimeout(contentChangeTimeout);
            contentChangeTimeout = setTimeout(function() {
                // 再次检查是否正在组合输入
                if (!isComposing) {
                notifyContentChanged();
                } else {
                    console.log('[Editor] 组合输入中，延迟通知内容变化');
                }
            }, 500);
        }
        
        // 强制立即通知内容变化（用于切换笔记前保存）
        function forceNotifyContentChanged() {
            console.log('[Editor] 强制立即通知内容变化');
            // 清除防抖延迟
            clearTimeout(contentChangeTimeout);
            // 立即通知，不检查 isLoadingContent（因为这是主动保存）
            if (!isInitialized) {
                console.log('[Editor] 编辑器未初始化，跳过通知');
                return;
            }
            
            const xmlContent = window.MiNoteWebEditor.getContent();
            
            // 更新当前内容
            currentContent = xmlContent;
            
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                window.webkit.messageHandlers.editorBridge.postMessage({
                    type: 'contentChanged',
                    content: xmlContent,
                    timestamp: Date.now(),
                    force: true // 标记为强制保存
                });
            }
        }
        
        // 通知Swift内容已更改
        function notifyContentChanged() {
            console.log('[保存流程] notifyContentChanged: 开始');
            
            if (!isInitialized) {
                console.log('[保存流程] ⚠️ notifyContentChanged: 编辑器未初始化');
                return;
            }
            
            // 如果正在修复光标位置，不触发内容变化通知，避免抖动
            if (isFixingCursor) {
                console.log('[保存流程] ⚠️ notifyContentChanged: 正在修复光标，跳过内容变化通知');
                return;
            }
            
            console.log('[保存流程] notifyContentChanged 步骤1: 获取当前内容');
            const xmlContent = window.MiNoteWebEditor.getContent();
            console.log('[保存流程] notifyContentChanged 步骤2: 获取到XML内容，长度: ' + xmlContent.length);
            console.log('[保存流程]   上次保存的currentContent长度: ' + (currentContent ? currentContent.length : 0));
            
            // 保存旧的 currentContent 用于比较和日志
            const oldContent = currentContent;
            
            // 如果内容和当前保存的内容相同，也不触发通知
            // 注意：这里比较的是转换后的 XML，如果用户只是改变了格式但内容相同，可能会被跳过
            // 但这是合理的，因为 XML 是内容的规范化表示
            if (xmlContent === oldContent) {
                console.log('[保存流程] ⚠️ notifyContentChanged 步骤3: 内容未变化（XML相同），跳过通知');
                console.log('[保存流程]   旧内容预览: ' + (oldContent ? oldContent.substring(0, 100) : 'null') + '...');
                console.log('[保存流程]   新内容预览: ' + xmlContent.substring(0, 100) + '...');
                
                // 即使 XML 相同，也检查一下 HTML 是否真的相同（用于调试）
                const htmlContent = document.getElementById('editor-content').innerHTML;
                console.log('[保存流程]   当前HTML长度: ' + htmlContent.length);
                
                return;
            }
            
            console.log('[保存流程] notifyContentChanged 步骤3: 内容有变化，继续通知');
            console.log('[保存流程]   内容差异: 旧长度=' + (oldContent ? oldContent.length : 0) + ', 新长度=' + xmlContent.length);
            
            // 更新当前内容（在发送通知之前更新，避免重复通知）
            currentContent = xmlContent;
            
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                console.log('[保存流程] notifyContentChanged 步骤4: 发送消息到Swift');
                window.webkit.messageHandlers.editorBridge.postMessage({
                    type: 'contentChanged',
                    content: xmlContent,
                    timestamp: Date.now()
                });
                console.log('[保存流程] ✅ notifyContentChanged: 消息已发送，XML长度: ' + xmlContent.length);
            } else {
                console.log('[保存流程] ⚠️ notifyContentChanged: editorBridge 不存在');
            }
        }
        
        // 更新选择状态
        function updateSelectionState() {
            // 可以在这里实现选择状态跟踪
        }
        
        // 保存当前光标位置
        function saveSelection() {
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                return null;
            }
            
            const range = selection.getRangeAt(0);
            const editor = document.getElementById('editor-content');
            
            try {
                // 使用 Range 的 cloneContents 和比较位置来保存选择
                // 保存开始和结束的节点和偏移量
                const startContainer = range.startContainer;
                const endContainer = range.endContainer;
                const startOffset = range.startOffset;
                const endOffset = range.endOffset;
                
                // 计算在编辑器中的字符偏移量
                const editorRange = document.createRange();
                editorRange.selectNodeContents(editor);
                editorRange.setEnd(range.startContainer, range.startOffset);
                const startCharOffset = editorRange.toString().length;
                
                editorRange.setEnd(range.endContainer, range.endOffset);
                const endCharOffset = editorRange.toString().length;
                
                return {
                    startCharOffset: startCharOffset,
                    endCharOffset: endCharOffset,
                    collapsed: range.collapsed
                };
            } catch (e) {
                console.error('保存选择位置失败:', e);
                return null;
            }
        }
        
        // 恢复光标位置
        function restoreSelection(savedSelection) {
            if (!savedSelection) {
                return false;
            }
            
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            
            try {
                // 使用更简单的方法：通过遍历文本节点找到字符偏移量对应的位置
                function getNodeAndOffsetAtCharOffset(node, targetOffset) {
                    let charCount = 0;
                    
                    function walk(node) {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const textLength = node.textContent.length;
                            if (charCount + textLength >= targetOffset) {
                                return {
                                    node: node,
                                    offset: targetOffset - charCount
                                };
                            }
                            charCount += textLength;
                        } else {
                            for (let i = 0; i < node.childNodes.length; i++) {
                                const result = walk(node.childNodes[i]);
                                if (result) {
                                    return result;
                                }
                            }
                        }
                        return null;
                    }
                    
                    return walk(node);
                }
                
                // 查找起始位置
                const startResult = getNodeAndOffsetAtCharOffset(editor, savedSelection.startCharOffset);
                const endResult = getNodeAndOffsetAtCharOffset(editor, savedSelection.endCharOffset);
                
                if (startResult && endResult) {
                    const range = document.createRange();
                    range.setStart(startResult.node, Math.min(startResult.offset, startResult.node.textContent.length));
                    
                    // 如果保存的位置超过了节点长度（可能由于内容变化），调整到节点末尾
                    const maxEndOffset = endResult.node.textContent.length;
                    range.setEnd(endResult.node, Math.min(endResult.offset, maxEndOffset));
                    
                    // 如果原本是折叠的（光标），确保也是折叠的
                    if (savedSelection.collapsed) {
                        range.collapse(true);
                    }
                    
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // 确保编辑器获得焦点并滚动到光标位置
                    editor.focus();
                    
                    // 滚动到可见区域
                    try {
                        const rect = range.getBoundingClientRect();
                        if (rect) {
                            rect.top -= 100; // 留一些上边距
                            editor.scrollTop = editor.scrollTop + rect.top;
                        }
                    } catch (e) {
                        // 忽略滚动错误
                    }
                    
                    return true;
                } else {
                    console.warn('无法恢复选择位置: 找不到对应的节点', {
                        startOffset: savedSelection.startCharOffset,
                        endOffset: savedSelection.endCharOffset,
                        editorTextLength: editor.textContent.length
                    });
                    // 如果找不到精确位置，将光标移到最接近的位置（编辑器末尾）
                    const range = document.createRange();
                    range.selectNodeContents(editor);
                    range.collapse(false);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    editor.focus();
                    return false;
                }
            } catch (e) {
                console.error('恢复选择位置失败:', e);
                return false;
            }
        }
        
        // 处理粘贴
        function handlePaste(e) {
            const items = e.clipboardData.items;
            let hasImage = false;
            
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    hasImage = true;
                    const blob = items[i].getAsFile();
                    const reader = new FileReader();
                    
                    reader.onload = function(event) {
                        const base64Data = event.target.result;
                        
                        // 通知Swift处理图片
                        if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                            window.webkit.messageHandlers.editorBridge.postMessage({
                                type: 'imagePasted',
                                imageData: base64Data,
                                timestamp: Date.now()
                            });
                        }
                    };
                    
                    reader.readAsDataURL(blob);
                    e.preventDefault();
                    break;
                }
            }
            
            // 如果没有图片，允许默认粘贴行为
            if (!hasImage) {
                // 延迟处理文本粘贴，以便DOM更新
                setTimeout(function() {
                    notifyContentChanged();
                }, 0);
            }
        }
        
        // 处理按键
        function handleKeyDown(e) {
            const editor = document.getElementById('editor-content');
            
            // Enter键处理
            if (e.key === 'Enter' || e.keyCode === 13) {
                // 确保编辑器有焦点
                if (document.activeElement !== editor) {
                    editor.focus();
                }
                
                // 保存当前光标位置（在换行之前）
                const selection = window.getSelection();
                let savedRange = null;
                if (selection.rangeCount > 0) {
                    savedRange = selection.getRangeAt(0).cloneRange();
                }
                
                // 不阻止默认行为，让浏览器自然插入换行（<br> 或 <div>）
                // Enter 键的默认行为应该自动插入换行
                // 注意：这里不调用 e.preventDefault()，让浏览器处理换行
                
                // 延迟处理，确保换行已经被浏览器插入
                setTimeout(function() {
                    const selection = window.getSelection();
                    
                    // 如果选择存在，确保它在编辑器中
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const container = range.commonAncestorContainer;
                        
                        // 确保光标在编辑器中
                        if (!editor.contains(container)) {
                            // 光标不在编辑器中，移到编辑器末尾
                            range.selectNodeContents(editor);
                            range.collapse(false);
                            selection.removeAllRanges();
                            selection.addRange(range);
                        } else {
                            // 光标在编辑器中，确保它在新行的正确位置
                            // 如果浏览器插入的是 <br>，光标应该在 <br> 之后
                            // 如果浏览器插入的是 <div>，光标应该在 <div> 内部
                            const containerNode = container.nodeType === Node.TEXT_NODE 
                                ? container.parentNode 
                                : container;
                            
                            // 检查光标位置是否合理
                            if (range.collapsed) {
                                // 光标是折叠的（单点），这是正常的
                                // 但需要确保它在正确的位置
                                let currentNode = range.startContainer;
                                
                                // 如果当前节点是文本节点，检查是否需要调整
                                if (currentNode.nodeType === Node.TEXT_NODE) {
                                    // 文本节点，光标位置应该正常
                                } else {
                                    // 非文本节点，可能需要调整
                                    // 如果是一个空的块元素（如新创建的 <div>），将光标放在里面
                                    if (currentNode.nodeType === Node.ELEMENT_NODE && 
                                        currentNode.tagName && 
                                        (currentNode.tagName === 'DIV' || currentNode.tagName === 'P') &&
                                        currentNode.textContent === '') {
                                        // 空的块元素，将光标放在里面
                                        range.setStart(currentNode, 0);
                                        range.collapse(true);
                                        selection.removeAllRanges();
                                        selection.addRange(range);
                                    }
                                }
                            }
                        }
                        
                        // 确保编辑器保持焦点
                        editor.focus();
                    } else {
                        // 没有选择，创建新的选择到编辑器末尾
                        const range = document.createRange();
                        range.selectNodeContents(editor);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        editor.focus();
                    }
                    
                    // 通知内容变化
                    notifyContentChanged();
                }, 20); // 增加延迟，确保浏览器完成换行插入
            }
            
            // Tab键处理（缩进）
            if (e.key === 'Tab' || e.keyCode === 9) {
                e.preventDefault();
                // 可以在这里实现缩进逻辑
                notifyContentChanged();
            }
        }
        
        // 处理点击（特别是checkbox）
        function handleClick(e) {
            if (e.target.type === 'checkbox') {
                // checkbox状态变化
                setTimeout(function() {
                    notifyContentChanged();
                }, 0);
            }
        }
        
        // 确保列表项在为空时有可见的光标
        // 只在光标移动或点击时检查，不在删除操作时立即检查，避免干扰删除
        function ensureListItemsHaveVisibleCursor() {
            // 如果正在修复光标，跳过，避免循环
            if (isFixingCursor) {
                return;
            }
            
            // 设置标志，避免修改 DOM 时触发内容变化通知
            isFixingCursor = true;
            
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            
            // 获取当前光标位置
            let currentCursorInListItem = null;
            let isCheckbox = false;
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const container = range.commonAncestorContainer;
                // 查找光标所在的列表项
                const listItem = container.nodeType === Node.TEXT_NODE 
                    ? container.parentElement 
                    : container;
                if (listItem) {
                    if (listItem.classList.contains('mi-note-order') || listItem.classList.contains('mi-note-bullet')) {
                        currentCursorInListItem = listItem;
                    } else if (listItem.classList.contains('mi-note-checkbox')) {
                        currentCursorInListItem = listItem;
                        isCheckbox = true;
                    }
                }
            }
            
            // 只处理光标所在的列表项，避免修改所有列表项导致抖动
            if (currentCursorInListItem) {
                const item = currentCursorInListItem;
                
                if (isCheckbox) {
                    // Checkbox 的特殊处理：内容在 checkbox input 后面
                    // 查找 checkbox input 元素
                    const checkboxInput = item.querySelector('input[type="checkbox"]');
                    
                    // 获取 checkbox 之后的所有内容（排除 checkbox input 本身）
                    let textContent = '';
                    for (let i = 0; i < item.childNodes.length; i++) {
                        const child = item.childNodes[i];
                        if (child !== checkboxInput && child.nodeType === Node.TEXT_NODE) {
                            textContent += child.textContent;
                        } else if (child !== checkboxInput && child.nodeType === Node.ELEMENT_NODE) {
                            textContent += child.textContent;
                        }
                    }
                    
                    const hasOnlyWhitespace = textContent.replace(/\u200B/g, '').trim() === '';
                    
                    // 如果为空或只有空白，且没有零宽度空格，添加一个
                    if (hasOnlyWhitespace && !textContent.includes('\u200B')) {
                        // 查找 checkbox 后面的文本节点
                        let textNode = null;
                        let foundCheckbox = false;
                        for (let i = 0; i < item.childNodes.length; i++) {
                            const child = item.childNodes[i];
                            if (child === checkboxInput) {
                                foundCheckbox = true;
                                continue;
                            }
                            if (foundCheckbox && child.nodeType === Node.TEXT_NODE) {
                                textNode = child;
                                // 如果文本节点为空，添加零宽度空格
                                if (textNode.textContent.trim() === '') {
                                    textNode.textContent = '\u200B';
                                }
                                break;
                            }
                        }
                        
                        // 如果没有文本节点，在 checkbox 后面创建一个
                        if (!textNode) {
                            textNode = document.createTextNode('\u200B');
                            if (checkboxInput && checkboxInput.nextSibling) {
                                item.insertBefore(textNode, checkboxInput.nextSibling);
                            } else {
                                item.appendChild(textNode);
                            }
                        }
                        
                        // 设置光标位置
                        const range = document.createRange();
                        range.setStart(textNode, textNode.textContent.length);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } else {
                    // 普通列表项（有序列表或无序列表）的处理
                    const textContent = item.textContent || '';
                    const hasOnlyWhitespace = textContent.replace(/\u200B/g, '').trim() === '';
                    
                    // 如果为空或只有空白，且没有零宽度空格，添加一个
                    if (hasOnlyWhitespace && !textContent.includes('\u200B')) {
                        // 检查是否已经有文本节点
                        let textNode = null;
                        for (let i = 0; i < item.childNodes.length; i++) {
                            if (item.childNodes[i].nodeType === Node.TEXT_NODE) {
                                textNode = item.childNodes[i];
                                // 如果文本节点为空，添加零宽度空格
                                if (textNode.textContent.trim() === '') {
                                    textNode.textContent = '\u200B';
                                }
                                break;
                            }
                        }
                        
                        // 如果没有文本节点，创建一个
                        if (!textNode) {
                            textNode = document.createTextNode('\u200B');
                            item.appendChild(textNode);
                        }
                        
                        // 设置光标位置
                        const range = document.createRange();
                        range.setStart(textNode, textNode.textContent.length);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                }
            }
            
            // 重置标志
            setTimeout(function() {
                isFixingCursor = false;
            }, 10);
        }
        
        // 执行格式命令
        function executeFormatCommand(action, value) {
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            
            if (!selection.rangeCount) return '无选中文本';
            
            document.execCommand('styleWithCSS', false, true);
            
            switch(action) {
                case 'bold':
                    document.execCommand('bold', false, null);
                    break;
                case 'italic':
                    document.execCommand('italic', false, null);
                    break;
                case 'underline':
                    document.execCommand('underline', false, null);
                    break;
                case 'strikethrough':
                    document.execCommand('strikethrough', false, null);
                    break;
                case 'heading':
                    // 处理标题
                    const headingLevel = parseInt(value) || 1;
                    applyHeading(headingLevel);
                    break;
                case 'textAlignment':
                    document.execCommand('justify' + value, false, null);
                    break;
                case 'bulletList':
                    toggleBulletList();
                    break;
                case 'orderList':
                    toggleOrderList();
                    break;
                case 'checkbox':
                    insertCheckbox();
                    break;
                case 'horizontalRule':
                    insertHorizontalRule();
                    break;
                case 'quote':
                    toggleQuote();
                    break;
                case 'indent':
                    changeIndent(value);
                    break;
                default:
                    console.warn('未知格式操作:', action);
            }
            
            notifyContentChanged();
            return '格式已应用: ' + action;
        }
        
        // 应用标题
        function applyHeading(level) {
            const tagName = level === 1 ? 'h1' : level === 2 ? 'h2' : 'h3';
            document.execCommand('formatBlock', false, tagName);
        }
        
        // 切换无序列表
        function toggleBulletList() {
            document.execCommand('insertUnorderedList', false, null);
        }
        
        // 切换有序列表
        function toggleOrderList() {
            document.execCommand('insertOrderedList', false, null);
        }
        
        // 插入复选框
        function insertCheckbox() {
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            
            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'mi-note-checkbox';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            
            const textSpan = document.createElement('span');
            textSpan.textContent = '待办事项';
            textSpan.contentEditable = true;
            
            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(textSpan);
            
            range.insertNode(checkboxContainer);
            range.setStartAfter(checkboxContainer);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // 插入水平分割线
        function insertHorizontalRule() {
            const hr = document.createElement('hr');
            hr.className = 'mi-note-hr';
            
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            
            range.insertNode(hr);
            
            // 在分割线后插入换行
            const br = document.createElement('br');
            range.setStartAfter(hr);
            range.insertNode(br);
            
            // 移动光标到新行
            range.setStartAfter(br);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // 切换引用块
        function toggleQuote() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            
            const range = selection.getRangeAt(0);
            const selectedText = range.toString();
            
            if (selectedText) {
                // 如果有选中文本，将其包裹在引用块中
                const quoteElement = document.createElement('blockquote');
                quoteElement.className = 'mi-note-quote';
                quoteElement.textContent = selectedText;
                
                range.deleteContents();
                range.insertNode(quoteElement);
            } else {
                // 如果没有选中文本，在当前行插入引用块
                document.execCommand('formatBlock', false, 'blockquote');
            }
        }
        
        // 改变缩进
        function changeIndent(direction) {
            if (direction === 'increase') {
                document.execCommand('indent', false, null);
            } else {
                document.execCommand('outdent', false, null);
            }
        }
        
        // 插入图片
        function insertImageAtCursor(imageUrl, altText) {
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = altText || '图片';
            img.className = 'mi-note-image';
            
            const editor = document.getElementById('editor-content');
            const selection = window.getSelection();
            
            if (selection.rangeCount) {
                const range = selection.getRangeAt(0);
                range.insertNode(img);
                
                // 在图片后插入空格以便继续输入
                const space = document.createTextNode(' ');
                range.setStartAfter(img);
                range.insertNode(space);
                
                // 移动光标到空格后
                range.setStartAfter(space);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            } else {
                editor.appendChild(img);
            }
            
            notifyContentChanged();
            return '图片已插入';
        }
        
        // 获取选择信息
        function getSelectionInfo() {
            const selection = window.getSelection();
            return {
                hasSelection: selection.rangeCount > 0,
                selectedText: selection.toString(),
                rangeCount: selection.rangeCount
            };
        }
        
        // ==================== XML/HTML转换函数 ====================
        
        // 将小米笔记XML渲染为HTML
        function renderXMLToEditor(xmlContent) {
            console.log('[renderXMLToEditor] ========== 开始渲染XML ==========');
            console.log('[renderXMLToEditor] XML内容长度:', xmlContent ? xmlContent.length : 0);
            console.log('[renderXMLToEditor] XML内容预览:', xmlContent ? xmlContent.substring(0, 500) : '(null)');
            
            const editor = document.getElementById('editor-content');
            if (!editor) {
                console.error('[renderXMLToEditor] ❌ 无法找到编辑器元素');
                return;
            }
            
            if (!xmlContent || xmlContent.trim() === '') {
                console.log('[renderXMLToEditor] XML内容为空，显示占位符');
                editor.innerHTML = '<div class="placeholder">开始输入...</div>';
                isInitialized = true; // 即使内容为空，也标记为已初始化
                return;
            }
            
            try {
                // 解析XML行
                const lines = xmlContent.split('\n').filter(line => line.trim() !== '');
                console.log('[renderXMLToEditor] 解析后的行数:', lines.length);
                console.log('[renderXMLToEditor] 前10行:', lines.slice(0, 10));
                
                let html = '';
                let inQuote = false;
                let quoteContent = '';
                let orderListNumber = 1;
                let isInOrderList = false;
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    const originalLine = line;
                    
                    console.log(`[renderXMLToEditor] 处理第 ${i + 1} 行:`, line.substring(0, 100));
                    
                    // 处理引用块开始
                    if (line.startsWith('<quote>')) {
                        console.log('[renderXMLToEditor] 检测到引用块开始');
                        inQuote = true;
                        quoteContent = '';
                        // 移除 <quote> 标签，获取内容
                        line = line.replace('<quote>', '').trim();
                        if (line) {
                            quoteContent += line + '\n';
                        }
                        continue;
                    }
                    
                    // 处理引用块结束
                    if (line.includes('</quote>')) {
                        console.log('[renderXMLToEditor] 检测到引用块结束');
                        // 移除 </quote> 标签
                        line = line.replace('</quote>', '').trim();
                        if (line) {
                            quoteContent += line + '\n';
                        }
                        // 处理完整的引用内容
                        if (quoteContent.trim()) {
                            console.log('[renderXMLToEditor] 引用块内容:', quoteContent);
                            html += parseQuoteElement(quoteContent);
                        }
                        inQuote = false;
                        quoteContent = '';
                        isInOrderList = false;
                        continue;
                    }
                    
                    // 如果正在引用块中，累积内容
                    if (inQuote) {
                        console.log('[renderXMLToEditor] 在引用块中，累积内容:', line);
                        quoteContent += line + '\n';
                        continue;
                    }
                    
                    // 处理各种XML元素
                    if (line.startsWith('<text')) {
                        const parsed = parseTextElement(line);
                        console.log('[renderXMLToEditor] 解析文本元素，结果长度:', parsed.length);
                        html += parsed;
                        isInOrderList = false;
                    } else if (line.startsWith('<bullet')) {
                        const parsed = parseBulletElement(line);
                        console.log('[renderXMLToEditor] 解析无序列表，结果长度:', parsed.length);
                        html += parsed;
                        isInOrderList = false;
                    } else if (line.startsWith('<order')) {
                        const result = parseOrderElement(line, isInOrderList ? orderListNumber : 1);
                        console.log('[renderXMLToEditor] 解析有序列表，结果长度:', result.html.length, '下一个序号:', result.nextNumber);
                        html += result.html;
                        orderListNumber = result.nextNumber;
                        isInOrderList = true;
                    } else if (line.startsWith('<input type="checkbox"')) {
                        const parsed = parseCheckboxElement(line);
                        console.log('[renderXMLToEditor] 解析复选框，结果长度:', parsed.length);
                        html += parsed;
                        isInOrderList = false;
                    } else if (line.startsWith('<hr')) {
                        const parsed = parseHRElement(line);
                        console.log('[renderXMLToEditor] 解析分割线');
                        html += parsed;
                        isInOrderList = false;
                    } else if (line.startsWith('<img')) {
                        const parsed = parseImageElement(line);
                        console.log('[renderXMLToEditor] 解析图片');
                        html += parsed;
                        isInOrderList = false;
                    } else if (line) {
                        console.log('[renderXMLToEditor] ⚠️ 未识别的行:', line);
                    }
                }
                
                console.log('[renderXMLToEditor] 生成的HTML长度:', html.length);
                console.log('[renderXMLToEditor] 生成的HTML预览:', html.substring(0, 500));
                
                if (!editor) {
                    console.error('[renderXMLToEditor] ❌ 编辑器元素不存在，无法设置内容');
                    return;
                }
                
                editor.innerHTML = html;
                
                // 验证内容是否已设置
                console.log('[renderXMLToEditor] 设置后的编辑器内容长度:', editor.innerHTML.length);
                console.log('[renderXMLToEditor] 设置后的编辑器子元素数量:', editor.children.length);
                
                // 重新初始化编辑器状态
                isInitialized = true;
                console.log('[renderXMLToEditor] ✅ XML内容已成功渲染为HTML，isInitialized=true');
                console.log('[renderXMLToEditor] =================================');
                
            } catch (error) {
                console.error('[renderXMLToEditor] ❌ 渲染XML时出错:', error);
                console.error('[renderXMLToEditor] 错误堆栈:', error.stack);
                if (editor) {
                editor.innerHTML = '<div class="placeholder">渲染内容时出错，请检查XML格式</div>';
                }
                isInitialized = true; // 即使出错，也标记为已初始化，避免无限循环
            }
        }
        
        // 解析文本元素 <text indent="1">内容</text>
        function parseTextElement(line) {
            // 提取属性
            const indentMatch = line.match(/indent="(\d+)"/);
            const indent = indentMatch ? parseInt(indentMatch[1]) : 1;
            
            // 提取内容（去除外层text标签）
            const contentStart = line.indexOf('>') + 1;
            const contentEnd = line.lastIndexOf('<');
            let content = line.substring(contentStart, contentEnd);
            
            // 检查是否有对齐标签（<center>或<right>）
            let alignClass = '';
            if (content.includes('<center>')) {
                alignClass = 'center';
                // 移除对齐标签，因为processRichTextTags会处理它们
            } else if (content.includes('<right>')) {
                alignClass = 'right';
            }
            
            // 处理富文本标签（包括对齐标签）
            content = processRichTextTags(content);
            
            // 构建HTML
            let className = `mi-note-text indent-${indent}`;
            if (alignClass) {
                className += ` ${alignClass}`;
            }
            
            return `<div class="${className}">${content}</div>`;
        }
        
        // 解析无序列表元素 <bullet indent="1" />内容 或 <bullet indent="1">内容</bullet>
        function parseBulletElement(line) {
            const indentMatch = line.match(/indent="(\d+)"/);
            const indent = indentMatch ? parseInt(indentMatch[1]) : 1;
            
            let content = '';
            
            // 检查是否是自闭合标签 <bullet ... />
            const selfClosingMatch = line.match(/<bullet[^>]*\/>/);
            if (selfClosingMatch) {
                // 自闭合标签，内容在标签后面
                const tagEnd = line.indexOf('/>') + 2;
                content = line.substring(tagEnd).trim();
            } else {
                // 普通标签 <bullet ...>内容</bullet>
            const contentStart = line.indexOf('>') + 1;
                const contentEnd = line.lastIndexOf('</bullet>');
                if (contentEnd > contentStart) {
                    content = line.substring(contentStart, contentEnd);
                }
            }
            
            content = processRichTextTags(content);
            
            // 如果内容为空，添加零宽度空格确保光标可见
            if (content.trim() === '') {
                content = '\u200B';
            }
            
            return `<div class="mi-note-bullet indent-${indent}">${content}</div>`;
        }
        
        // 解析有序列表元素 <order indent="1" inputNumber="0" />内容 或 <order indent="1" inputNumber="0">内容</order>
        function parseOrderElement(line, currentNumber) {
            const indentMatch = line.match(/indent="(\d+)"/);
            const inputNumberMatch = line.match(/inputNumber="(\d+)"/);
            const indent = indentMatch ? parseInt(indentMatch[1]) : 1;
            const inputNumber = inputNumberMatch ? parseInt(inputNumberMatch[1]) : 0;
            
            let content = '';
            
            // 检查是否是自闭合标签 <order ... />
            const selfClosingMatch = line.match(/<order[^>]*\/>/);
            if (selfClosingMatch) {
                // 自闭合标签，内容在标签后面
                const tagEnd = line.indexOf('/>') + 2;
                content = line.substring(tagEnd).trim();
            } else {
                // 普通标签 <order ...>内容</order>
            const contentStart = line.indexOf('>') + 1;
                const contentEnd = line.lastIndexOf('</order>');
                if (contentEnd > contentStart) {
                    content = line.substring(contentStart, contentEnd);
                }
            }
            
            content = processRichTextTags(content);
            
            // 如果内容为空，添加零宽度空格确保光标可见
            if (content.trim() === '') {
                content = '\u200B';
            }
            
            // 根据小米笔记格式示例的规则：
            // - 如果inputNumber为0，使用当前计数器
            // - 如果inputNumber不为0，使用实际值，并重置计数器
            let displayNumber;
            if (inputNumber === 0) {
                displayNumber = currentNumber;
            } else {
                displayNumber = inputNumber;
                // 重置计数器为inputNumber + 1
                currentNumber = inputNumber + 1;
            }
            
            const html = `<div class="mi-note-order indent-${indent}" data-number="${displayNumber}">${content}</div>`;
            
            return {
                html: html,
                nextNumber: currentNumber + 1
            };
        }
        
        // 解析复选框元素 <input type="checkbox" indent="1" level="3" />内容 或 <input type="checkbox" indent="1" level="3">内容</input>
        function parseCheckboxElement(line) {
            const checkedMatch = line.match(/checked="(\w+)"/);
            const indentMatch = line.match(/indent="(\d+)"/);
            const levelMatch = line.match(/level="(\d+)"/);
            
            const checked = checkedMatch ? (checkedMatch[1] === 'true') : false;
            const indent = indentMatch ? parseInt(indentMatch[1]) : 1;
            const level = levelMatch ? parseInt(levelMatch[1]) : 3;
            
            let content = '';
            
            // 检查是否是自闭合标签 <input type="checkbox" ... />
            const selfClosingMatch = line.match(/<input[^>]*type="checkbox"[^>]*\/>/);
            if (selfClosingMatch) {
                // 自闭合标签，内容在标签后面
                const tagEnd = line.indexOf('/>') + 2;
                content = line.substring(tagEnd).trim();
            } else {
                // 普通标签 <input type="checkbox" ...>内容</input>
            const contentStart = line.indexOf('>') + 1;
                const contentEnd = line.lastIndexOf('</input>');
                if (contentEnd > contentStart) {
                    content = line.substring(contentStart, contentEnd);
                }
            }
            
            content = processRichTextTags(content);
            
            // 如果内容为空，添加零宽度空格确保光标可见
            if (content.trim() === '') {
                content = '\u200B';
            }
            
            const checkedAttr = checked ? 'checked' : '';
            return `<div class="mi-note-checkbox indent-${indent}"><input type="checkbox" ${checkedAttr}>${content}</div>`;
        }
        
        // 解析水平分割线 <hr/>
        function parseHRElement(line) {
            return '<hr class="mi-note-hr">';
        }
        
        // 解析引用块内容（可能包含多行，每行可能是 <text> 标签）
        function parseQuoteElement(quoteContent) {
            console.log('[parseQuoteElement] ========== 开始解析引用块 ==========');
            console.log('[parseQuoteElement] 原始内容:', quoteContent);
            
            // 引用块内容可能包含多行，每行可能是 <text> 标签
            const lines = quoteContent.split('\n').filter(line => line.trim() !== '');
            console.log('[parseQuoteElement] 引用块行数:', lines.length);
            
            let htmlContent = '';
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                console.log(`[parseQuoteElement] 处理引用块第 ${i + 1} 行:`, line);
                
                if (line.startsWith('<text')) {
                    // 解析文本元素
                    const parsed = parseTextElement(line);
                    console.log(`[parseQuoteElement] 解析文本元素，结果:`, parsed);
                    htmlContent += parsed;
                } else if (line) {
                    // 普通文本，直接添加
                    console.log(`[parseQuoteElement] 普通文本:`, line);
                    const processed = processRichTextTags(line);
                    htmlContent += `<div class="mi-note-text indent-1">${processed}</div>`;
                }
            }
            
            const result = `<blockquote class="mi-note-quote">${htmlContent}</blockquote>`;
            console.log('[parseQuoteElement] 最终HTML:', result);
            console.log('[parseQuoteElement] =================================');
            
            return result;
        }
        
        // 解析图片元素 <img src="..." alt="..."/>
        function parseImageElement(line) {
            const srcMatch = line.match(/src="([^"]+)"/);
            const altMatch = line.match(/alt="([^"]*)"/);
            const src = srcMatch ? srcMatch[1] : '';
            const alt = altMatch ? altMatch[1] : '图片';
            
            return `<img src="${src}" alt="${alt}" class="mi-note-image">`;
        }
        
        // 处理富文本标签
        function processRichTextTags(content) {
            // 替换小米笔记标签为标准HTML标签
            content = content.replace(/<b>/g, '<b>').replace(/<\/b>/g, '</b>');
            content = content.replace(/<i>/g, '<i>').replace(/<\/i>/g, '</i>');
            content = content.replace(/<u>/g, '<u>').replace(/<\/u>/g, '</u>');
            content = content.replace(/<delete>/g, '<delete>').replace(/<\/delete>/g, '</delete>');
            
            // 处理标题标签（根据小米笔记格式示例）
            content = content.replace(/<size>/g, '<span class="size-large">').replace(/<\/size>/g, '</span>');
            content = content.replace(/<mid-size>/g, '<span class="size-mid">').replace(/<\/mid-size>/g, '</span>');
            content = content.replace(/<h3-size>/g, '<span class="size-h3">').replace(/<\/h3-size>/g, '</span>');
            
            // 处理对齐标签
            content = content.replace(/<center>/g, '<span style="text-align: center; display: block;">').replace(/<\/center>/g, '</span>');
            content = content.replace(/<right>/g, '<span style="text-align: right; display: block;">').replace(/<\/right>/g, '</span>');
            
            return content;
        }
        
        // 将HTML转换回小米笔记XML
        function convertHTMLToXML(htmlContent) {
            if (!htmlContent || htmlContent.trim() === '') {
                return '';
            }
            
            console.log('[convertHTMLToXML] 开始转换HTML到XML，HTML长度:', htmlContent.length);
            
            // 创建临时div来解析HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlContent;
            
            let xmlLines = [];
            
            // 状态变量，用于跟踪有序列表的连续性
            let lastOrderListIndent = null; // 上一个有序列表的缩进级别
            let lastOrderListNumber = null; // 上一个有序列表的序号
            let isInContinuousOrderList = false; // 是否在连续的有序列表中
            
            // 遍历所有子节点（包括嵌套的元素）
            const processNode = (node) => {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    const tagName = node.tagName ? node.tagName.toLowerCase() : '';
                    const className = node.className || '';
                    
            // 检查是否是特殊元素（列表、分割线、引用等）
            // 支持我们自己的 mi-note- 前缀，以及小米笔记的 pm- 前缀，以及标准HTML标签
            const isSpecialElement = className.includes('mi-note-bullet') ||
                                           className.includes('mi-note-order') ||
                                           className.includes('mi-note-checkbox') ||
                                           className.includes('mi-note-hr') ||
                                           className.includes('mi-note-quote') ||
                                           className.includes('mi-note-image') ||
                                           className.includes('pm-bullet-list') ||
                                           className.includes('pm-order-list') ||
                                           className.includes('pm-checklist') ||
                                           tagName === 'hr' ||
                                           tagName === 'blockquote' ||
                                           tagName === 'img' ||
                                           tagName === 'ul' ||
                                           tagName === 'ol' ||
                                           tagName === 'li';
                    
                    if (isSpecialElement) {
                        // 直接转换特殊元素
                        const xmlLine = convertNodeToXML(node, {
                            lastOrderListIndent: lastOrderListIndent,
                            lastOrderListNumber: lastOrderListNumber,
                            isInContinuousOrderList: isInContinuousOrderList
                        });
                        
                    if (xmlLine) {
                        xmlLines.push(xmlLine);
                            
                            // 更新有序列表状态
                            if (className.includes('mi-note-order') || className.includes('pm-order-list') || tagName === 'li') {
                                // 检查父元素是否是ol或有序列表
                                const parent = node.parentElement;
                                const parentTag = parent ? parent.tagName.toLowerCase() : '';
                                const parentClass = parent ? parent.className || '' : '';
                                
                                if (parentTag === 'ol' || parentClass.includes('mi-note-order') || parentClass.includes('pm-order-list') ||
                                    className.includes('mi-note-order') || className.includes('pm-order-list')) {
                                    // 这是一个有序列表项
                                    const indent = getIndentFromClass(className) || getIndentFromDataAttr(node) || '1';
                                    const numberAttr = node.getAttribute('data-number') || node.getAttribute('data-start') || '1';
                                    const number = parseInt(numberAttr, 10);
                                    
                                    // 检查是否是连续的有序列表
                                    if (lastOrderListIndent === indent) {
                                        // 相同缩进级别，可能是连续列表
                                        isInContinuousOrderList = true;
                                        lastOrderListNumber = number;
                                    } else {
                                        // 不同缩进级别，不是连续列表
                                        isInContinuousOrderList = false;
                                        lastOrderListIndent = indent;
                                        lastOrderListNumber = number;
                                    }
                                } else {
                                    // 不是有序列表项，重置状态
                                    isInContinuousOrderList = false;
                                    lastOrderListIndent = null;
                                    lastOrderListNumber = null;
                                }
                            } else {
                                // 不是有序列表项，重置状态
                                isInContinuousOrderList = false;
                                lastOrderListIndent = null;
                                lastOrderListNumber = null;
                            }
                        }
                    } else if (className.includes('mi-note-text') || tagName === 'div' || tagName === 'p') {
                        // 处理文本元素，检查是否包含嵌套的特殊元素
                        const hasSpecialChildren = node.querySelector('.mi-note-bullet, .mi-note-order, .mi-note-checkbox, .mi-note-hr, .mi-note-quote, .mi-note-image, .pm-bullet-list, .pm-order-list, .pm-checklist, hr, blockquote, img');
                        
                        if (hasSpecialChildren) {
                            // 如果包含特殊子元素，递归处理子节点
                            const children = node.childNodes;
                            for (let child of children) {
                                processNode(child);
                            }
                        } else {
                            // 普通文本元素
                            const xmlLine = convertNodeToXML(node, {
                                lastOrderListIndent: lastOrderListIndent,
                                lastOrderListNumber: lastOrderListNumber,
                                isInContinuousOrderList: isInContinuousOrderList
                            });
                            if (xmlLine) {
                                xmlLines.push(xmlLine);
                                // 文本元素会中断有序列表的连续性
                                isInContinuousOrderList = false;
                                lastOrderListIndent = null;
                                lastOrderListNumber = null;
                            }
                        }
                    } else {
                        // 其他元素，递归处理子节点
                        const children = node.childNodes;
                        for (let child of children) {
                            processNode(child);
                        }
                    }
                } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                    // 处理纯文本节点（可能是占位符）
                    if (!node.textContent.includes('开始输入...')) {
                        xmlLines.push(`<text indent="1" align="left">${escapeXML(node.textContent)}</text>`);
                        // 文本节点会中断有序列表的连续性
                        isInContinuousOrderList = false;
                        lastOrderListIndent = null;
                        lastOrderListNumber = null;
                    }
                }
            };
            
            // 处理所有直接子节点
            const nodes = tempDiv.childNodes;
            for (let node of nodes) {
                processNode(node);
            }
            
            const result = xmlLines.join('\n');
            console.log('[convertHTMLToXML] 转换完成，XML行数:', xmlLines.length, '，XML长度:', result.length);
            console.log('[convertHTMLToXML] XML内容预览:', result.substring(0, 200));
            
            return result;
        }
        
        // 将DOM节点转换为XML行
        function convertNodeToXML(node, context) {
            const tagName = node.tagName ? node.tagName.toLowerCase() : '';
            const className = node.className || '';
            
            // 如果没有提供上下文，使用默认值
            const lastOrderListIndent = context ? context.lastOrderListIndent : null;
            const lastOrderListNumber = context ? context.lastOrderListNumber : null;
            const isInContinuousOrderList = context ? context.isInContinuousOrderList : false;
            
            console.log('[convertNodeToXML] 处理节点:', tagName, className, '上下文:', { lastOrderListIndent, lastOrderListNumber, isInContinuousOrderList });
            
            // 处理文本元素（支持 mi-note-text 和普通 p 标签）
            if (className.includes('mi-note-text') || (tagName === 'p' && !className.includes('pm-block'))) {
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node) || '1';
                const align = getAlignFromClass(className);
                const content = extractContentWithRichText(node);
                
                // 处理高亮（pm-highlight）
                let processedContent = content;
                if (content.includes('pm-highlight')) {
                    // 如果内容包含高亮标记，需要在提取时处理
                    // 这里先提取内容，高亮会在extractContentWithRichText中处理
                }
                
                const result = `<text indent="${indent}" align="${align}">${processedContent}</text>`;
                console.log('[convertNodeToXML] 文本元素:', result);
                return result;
            }
            
            // 处理标题元素（pm-size-middle, pm-size-h3等）
            if (className.includes('pm-size-middle')) {
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node) || '1';
                const content = extractContentWithRichText(node);
                // 二级标题使用 <mid-size> 标签
                const result = `<text indent="${indent}" align="left"><mid-size>${content}</mid-size></text>`;
                console.log('[convertNodeToXML] 二级标题:', result);
                return result;
            }
            
            if (className.includes('pm-size-h3')) {
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node) || '1';
                const content = extractContentWithRichText(node);
                // 三级标题使用 <h3-size> 标签
                const result = `<text indent="${indent}" align="left"><h3-size>${content}</h3-size></text>`;
                console.log('[convertNodeToXML] 三级标题:', result);
                return result;
            }
            
            // 处理无序列表（支持 mi-note-bullet 和 pm-bullet-list）
            if (className.includes('mi-note-bullet') || className.includes('pm-bullet-list')) {
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node);
                const content = extractContentWithRichText(node);
                // 注意：Swift端期望格式为 <bullet ... />文本内容
                const result = `<bullet indent="${indent}" />${content}`;
                console.log('[convertNodeToXML] 无序列表:', result, 'content长度:', content.length);
                return result;
            }
            
            // 处理有序列表（支持 mi-note-order 和 pm-order-list）
            if (className.includes('mi-note-order') || className.includes('pm-order-list')) {
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node);
                // 支持 data-number 和 data-start 属性
                const numberAttr = node.getAttribute('data-number') || node.getAttribute('data-start') || '1';
                const number = parseInt(numberAttr, 10);
                
                // 根据小米笔记格式示例的规则：
                // 连续多行的有序列表，第一行的inputNumber是实际值，后续行的inputNumber都是0
                let zeroBasedNumber;
                
                if (isInContinuousOrderList && lastOrderListIndent === indent) {
                    // 在连续的有序列表中，且缩进级别相同
                    // 这是后续行，inputNumber应该为0
                    zeroBasedNumber = 0;
                    console.log('[convertNodeToXML] 连续有序列表的后续行，设置inputNumber=0');
                } else {
                    // 第一行或不同缩进级别，使用实际值
                    // 小米笔记 XML 中 inputNumber 是 0-based，所以需要减 1
                    zeroBasedNumber = Math.max(0, number - 1);
                    console.log('[convertNodeToXML] 有序列表第一行或不同缩进，使用实际值:', zeroBasedNumber);
                }
                
                const content = extractContentWithRichText(node);
                // 注意：Swift端期望格式为 <order ... />文本内容
                const result = `<order indent="${indent}" inputNumber="${zeroBasedNumber}" />${content}`;
                console.log('[convertNodeToXML] 有序列表:', result, 'content长度:', content.length);
                return result;
            }
            
            // 处理复选框（支持 mi-note-checkbox 和 pm-checklist）
            if (className.includes('mi-note-checkbox') || className.includes('pm-checklist')) {
                const checkbox = node.querySelector('input[type="checkbox"]');
                // 支持 data-checked 属性
                const dataChecked = node.getAttribute('data-checked');
                const checked = dataChecked === 'true' || (checkbox ? checkbox.checked : false);
                const indent = getIndentFromClass(className) || getIndentFromDataAttr(node);
                const level = node.getAttribute('data-level') || '3';
                
                // 提取内容时，确保不包含 checkbox 本身
                // extractContentWithRichText 已经处理了移除 checkbox input 元素
                let content = extractContentWithRichText(node);
                
                // 如果 content 为空，尝试 textContent
                if (!content.trim()) {
                    console.log('[convertNodeToXML] 复选框 content 为空，尝试 clone.textContent');
                    // 克隆节点并移除 checkbox
                    const clone = node.cloneNode(true);
                    const cb = clone.querySelector('input[type="checkbox"]');
                    if (cb) cb.parentNode.removeChild(cb);
                    content = clone.textContent || '';
                }
                
                // 无论如何，先匹配 Swift 端的格式
                const result = `<input type="checkbox" indent="${indent}" level="${level}" />${content}`;
                console.log('[convertNodeToXML] 复选框:', result, 'content长度:', content.length);
                return result;
            }
            
            // 处理水平分割线
            if (className.includes('mi-note-hr') || tagName === 'hr') {
                console.log('[convertNodeToXML] 水平分割线');
                return '<hr />';
            }
            
            // 处理引用块（支持 mi-note-quote 和 blockquote.quote）
            if (className.includes('mi-note-quote') || (tagName === 'blockquote' && className.includes('quote'))) {
                // 对于引用块，需要处理内部的段落
                let quoteContent = '';
                const children = node.childNodes;
                for (let child of children) {
                    if (child.nodeType === Node.ELEMENT_NODE) {
                        const childTag = child.tagName ? child.tagName.toLowerCase() : '';
                        const childClass = child.className || '';
                        if (childTag === 'p' || childClass.includes('mi-note-text')) {
                            const indent = getIndentFromClass(childClass) || getIndentFromDataAttr(child) || '1';
                            const content = extractContentWithRichText(child);
                            quoteContent += `<text indent="${indent}" align="left">${content}</text>\n`;
                        }
                    }
                }
                quoteContent = quoteContent.trim();
                const result = `<quote>${quoteContent}</quote>`;
                console.log('[convertNodeToXML] 引用块:', result);
                return result;
            }
            
            // 处理图片
            if (className.includes('mi-note-image') || tagName === 'img') {
                const src = node.getAttribute('src') || '';
                const alt = node.getAttribute('alt') || '';
                const fileId = node.getAttribute('fileid') || ''; // 小米笔记特有属性
                
                // 如果有 fileId，使用小米笔记的 img 标签格式
                // <img fileid="fileId" ... />
                if (fileId) {
                     return `<img fileid="${fileId}" src="${src}" alt="${alt}" />`;
                }
                
                const result = `<img src="${src}" alt="${alt}" />`;
                console.log('[convertNodeToXML] 图片:', result);
                return result;
            }
            
            // 处理标准HTML列表项（<li>标签）
            if (tagName === 'li') {
                // 检查父元素是<ul>还是<ol>
                const parent = node.parentElement;
                const parentTag = parent ? parent.tagName.toLowerCase() : '';
                const parentClass = parent ? parent.className || '' : '';
                
                // 确定缩进级别（基于嵌套深度）
                let indent = '1';
                let current = node;
                let depth = 0;
                while (current.parentElement) {
                    const parentTag = current.parentElement.tagName.toLowerCase();
                    if (parentTag === 'ul' || parentTag === 'ol') {
                        depth++;
                    }
                    current = current.parentElement;
                }
                if (depth > 0) {
                    indent = Math.min(depth, 5).toString(); // 最大缩进5级
                }
                
                const content = extractContentWithRichText(node);
                
                if (parentTag === 'ul' || parentClass.includes('mi-note-bullet') || parentClass.includes('pm-bullet-list')) {
                    // 无序列表
                    const result = `<bullet indent="${indent}">${content}</bullet>`;
                    console.log('[convertNodeToXML] 标准HTML无序列表项:', result);
                    return result;
                } else if (parentTag === 'ol' || parentClass.includes('mi-note-order') || parentClass.includes('pm-order-list')) {
                    // 有序列表
                    // 尝试从data-start或data-number属性获取序号
                    const startAttr = parent ? parent.getAttribute('start') : null;
                    const dataStart = parent ? parent.getAttribute('data-start') : null;
                    const dataNumber = node.getAttribute('data-number');
                    
                    let number = '1';
                    if (dataNumber) {
                        number = dataNumber;
                    } else if (dataStart) {
                        number = dataStart;
                    } else if (startAttr) {
                        number = startAttr;
                    }
                    
                    const result = `<order indent="${indent}" inputNumber="${number}">${content}</order>`;
                    console.log('[convertNodeToXML] 标准HTML有序列表项:', result);
                    return result;
                }
            }
            
            // 处理标准HTML列表容器（<ul>和<ol>标签）
            if (tagName === 'ul' || tagName === 'ol') {
                // 对于列表容器，我们需要处理其子元素（<li>）
                // 返回null，让convertHTMLToXML递归处理子节点
                console.log('[convertNodeToXML] 处理标准HTML列表容器:', tagName);
                return null;
            }
            
            // 处理标准HTML元素（如p, div等），但只有在没有特殊class时才处理
            if ((tagName === 'p' || tagName === 'div') && !className.includes('mi-note-')) {
                const content = extractContentWithRichText(node);
                if (content.trim() !== '') {
                    const result = `<text indent="1" align="left">${content}</text>`;
                    console.log('[convertNodeToXML] 标准HTML元素:', result);
                    return result;
                }
            }
            
            // 如果无法识别，返回null（不应该到达这里，因为convertHTMLToXML已经过滤了）
            console.warn('[convertNodeToXML] 无法识别的节点:', tagName, className, node);
            return null;
        }
        
        // 从class名中提取缩进级别
        function getIndentFromClass(className) {
            if (!className) return null;
            const match = className.match(/indent-(\d+)/);
            return match ? match[1] : null;
        }
        
        // 从data-indentation属性中提取缩进级别
        function getIndentFromDataAttr(node) {
            const indentation = node.getAttribute('data-indentation');
            return indentation || '1';
        }
        
        // 从class名中提取对齐方式
        function getAlignFromClass(className) {
            if (className.includes('center')) return 'center';
            if (className.includes('right')) return 'right';
            return 'left';
        }
        
        // 提取内容并保留富文本标签
        function extractContentWithRichText(node) {
            let content = '';
            
            // 克隆节点以避免修改原始DOM
            const clone = node.cloneNode(true);
            
            // 移除不需要的属性
            clone.removeAttribute('class');
            clone.removeAttribute('data-number');
            
            // 处理复选框容器
            // 移除所有checkbox input元素（避免重复）
            const checkboxes = clone.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.parentNode) {
                    cb.parentNode.removeChild(cb);
                }
            });
            
            // 处理列表标记
            if (clone.classList && clone.classList.contains('mi-note-bullet')) {
                // 移除伪元素内容
                clone.style.setProperty('--bullet-content', '""');
                // 移除可能存在的 <bullet> 标签（不应该存在，但为了安全）
                const bulletTags = clone.querySelectorAll('bullet');
                bulletTags.forEach(tag => tag.remove());
            }
            
            if (clone.classList && clone.classList.contains('mi-note-order')) {
                clone.removeAttribute('data-number');
                // 移除可能存在的 <order> 标签（不应该存在，但为了安全）
                const orderTags = clone.querySelectorAll('order');
                orderTags.forEach(tag => tag.remove());
            }
            
            // 转换HTML标签回小米笔记标签
            content = clone.innerHTML;
            
            // 如果内容为空，尝试使用 textContent 作为后备
            if (!content || content.trim() === '') {
                content = clone.textContent || '';
                console.log('[extractContentWithRichText] 内容为空，使用 textContent:', content);
            }
            
            // 转换标准HTML标签为小米笔记标签（保持不变）
            content = content.replace(/<b>/g, '<b>').replace(/<\/b>/g, '</b>');
            content = content.replace(/<i>/g, '<i>').replace(/<\/i>/g, '</i>');
            content = content.replace(/<u>/g, '<u>').replace(/<\/u>/g, '</u>');
            content = content.replace(/<delete>/g, '<delete>').replace(/<\/delete>/g, '</delete>');
            content = content.replace(/<del>/g, '<delete>').replace(/<\/del>/g, '</delete>');
            
            // 处理高亮（pm-highlight）
            // 使用正则表达式匹配完整的span标签对
            content = content.replace(/<span class="pm-highlight[^"]*">(.*?)<\/span>/g, '<highlight>$1</highlight>');
            
            // 转换标题类（根据小米笔记格式示例）
            content = content.replace(/<span class="size-large">/g, '<size>');
            content = content.replace(/<span class="size-mid">/g, '<mid-size>');
            content = content.replace(/<span class="size-h3">/g, '<h3-size>');
            
            // 转换对齐样式
            content = content.replace(/<span style="text-align: center; display: block;">/g, '<center>');
            content = content.replace(/<span style="text-align: right; display: block;">/g, '<right>');
            
            // 替换所有span结束标签（但要保留已转换的标签）
            // 先标记已转换的标签
            content = content.replace(/<\/highlight>/g, '[[HIGHLIGHT_END]]');
            content = content.replace(/<\/size>/g, '[[SIZE_END]]');
            content = content.replace(/<\/mid-size>/g, '[[MIDSIZE_END]]');
            content = content.replace(/<\/h3-size>/g, '[[H3SIZE_END]]');
            content = content.replace(/<\/center>/g, '[[CENTER_END]]');
            content = content.replace(/<\/right>/g, '[[RIGHT_END]]');
            
            // 删除剩余的span标签
            content = content.replace(/<span[^>]*>/g, '');
            content = content.replace(/<\/span>/g, '');
            
            // 恢复标记的标签
            content = content.replace(/\[\[HIGHLIGHT_END\]\]/g, '</highlight>');
            content = content.replace(/\[\[SIZE_END\]\]/g, '</size>');
            content = content.replace(/\[\[MIDSIZE_END\]\]/g, '</mid-size>');
            content = content.replace(/\[\[H3SIZE_END\]\]/g, '</h3-size>');
            content = content.replace(/\[\[CENTER_END\]\]/g, '</center>');
            content = content.replace(/\[\[RIGHT_END\]\]/g, '</right>');
            
            // 清理多余的空白span标签
            content = content.replace(/<span[^>]*>\s*<\/span>/g, '');
            
            return content;
        }
        
        // 转义XML特殊字符
        function escapeXML(text) {
                return text
                    .replace(/&/g, '&amp;')    // & 转义为 &amp;
                    .replace(/</g, '&lt;')     // < 转义为 &lt;
                    .replace(/>/g, '&gt;')     // > 转义为 &gt;
                    .replace(/"/g, '&quot;')   // " 转义为 &quot;
                    .replace(/'/g, '&apos;');  // ' 转义为 &apos;
            }

        
        // 初始化完成
        console.log('小米笔记Web编辑器已初始化完成');
    </script>
</body>
</html>
