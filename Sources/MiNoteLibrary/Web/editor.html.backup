<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="color-scheme" content="light dark">
    <title>小米笔记编辑器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 浅色模式颜色变量 */
        :root {
            --bg-color: #fff;
            --text-color: #333;
            --bullet-color: #666;
            --quote-border: #ccc;
            --quote-text: #666;
            --hr-color: #ddd;
            --placeholder-color: #999;
        }
        
        /* 深色模式颜色变量 */
        html[data-color-scheme="dark"],
        :root[data-color-scheme="dark"] {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --bullet-color: #858585;
            --quote-border: #5a5a5a;
            --quote-text: #858585;
            --hr-color: #3e3e42;
            --placeholder-color: #6a6a6a;
            }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
            background-color: var(--bg-color);
            padding: 0;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        
        #editor-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #editor-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            outline: none;
            min-height: 200px;
            color: var(--text-color);
            background-color: var(--bg-color);
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        
        /* 小米笔记样式 */
        .mi-note-highlight {
            background-color: rgba(154, 255, 232, 0.69); /* #9affe8af */
            padding: 0 2px;
            border-radius: 2px;
        }
        
        .mi-note-text {
            margin-bottom: 8px;
            padding-left: 0;
        }
        
        .mi-note-text.indent-1 { padding-left: 0; }
        .mi-note-text.indent-2 { padding-left: 20px; }
        .mi-note-text.indent-3 { padding-left: 40px; }
        .mi-note-text.indent-4 { padding-left: 60px; }
        .mi-note-text.indent-5 { padding-left: 80px; }
        
        .mi-note-bullet, .mi-note-order, .mi-note-checkbox {
            margin-bottom: 8px;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        
        .mi-note-bullet::before {
            content: "•";
            margin-right: 8px;
            color: var(--bullet-color);
            flex-shrink: 0;
        }
        
        .mi-note-order::before {
            content: attr(data-number) ".";
            margin-right: 8px;
            color: var(--bullet-color);
            min-width: 20px;
            text-align: right;
            flex-shrink: 0;
        }
        
        .mi-note-order:empty,
        .mi-note-bullet:empty {
            min-height: 1.5em;
        }
        
        /* 零宽度空格用于保持光标可见，但不应该显示出来 */
        .mi-note-order,
        .mi-note-bullet,
        .mi-note-checkbox span {
            white-space: pre-wrap;
        }
        
        /* 确保零宽度空格不可见 */
        .mi-note-order *,
        .mi-note-bullet *,
        .mi-note-checkbox span * {
            font-size: inherit;
        }
        
        .mi-note-checkbox {
            display: flex;
            align-items: center;
            position: relative;
        }
        
        .mi-note-checkbox input[type="checkbox"] {
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .mi-note-checkbox > *:not(input[type="checkbox"]) {
            flex: 1;
            min-width: 0;
        }
        
        .mi-note-hr {
            height: 1px;
            background-color: var(--hr-color);
            margin: 16px 0;
            border: none;
            transition: background-color 0.2s ease;
        }
        
        .mi-note-quote {
            border-left: 3px solid var(--quote-border);
            padding-left: 12px;
            margin: 8px 0;
            color: var(--quote-text);
            transition: border-color 0.2s ease, color 0.2s ease;
        }
        
        .mi-note-text.center {
            text-align: center;
        }
        
        .mi-note-text.right {
            text-align: right;
        }
        
        /* 富文本样式 */
        .mi-note-text b, .mi-note-text strong {
            font-weight: bold;
        }
        
        .mi-note-text i, .mi-note-text em {
            font-style: italic;
        }
        
        .mi-note-text u {
            text-decoration: underline;
        }
        
        .mi-note-text s, .mi-note-text del {
            text-decoration: line-through;
        }
        
        .mi-note-text .mi-note-size {
            font-size: 24px;
            font-weight: bold;
        }
        
        .mi-note-text .mi-note-mid-size {
            font-size: 20px;
            font-weight: bold;
        }
        
        .mi-note-text .mi-note-h3-size {
            font-size: 18px;
            font-weight: bold;
        }
        
        /* 图片样式 */
        .mi-note-image {
            max-width: 100%;
            height: auto;
            margin: 8px 0;
        }
        
        .mi-note-image-container {
            margin: 8px 0;
        }
        
        /* 占位符 */
        .placeholder {
            color: var(--placeholder-color);
        }
        
        /* 确保所有文本元素使用正确的颜色 */
        .mi-note-text,
        .mi-note-bullet,
        .mi-note-order,
        .mi-note-checkbox {
            color: var(--text-color);
        }
        
        /* 焦点样式 */
        #editor-content:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="editor-content" contenteditable="true" spellcheck="false" style="white-space: pre-wrap;">
            <!-- 内容将在这里动态加载 -->
        </div>
    </div>

    <!-- 引入格式转换模块 -->
    <script src="xml-to-html.js"></script>
    <script src="html-to-xml.js"></script>

    <!-- ==================== 模块化加载 ==================== -->
    <!-- 按依赖顺序加载模块 -->
    <script src="modules/core/logger.js"></script>
    <script src="modules/core/constants.js"></script>
    <script src="modules/core/utils.js"></script>
    <script src="modules/command/command.js"></script>
    <script src="modules/command/format-commands.js"></script>
    <script src="modules/dom/dom-writer.js"></script>
    <script src="modules/converter/converter.js"></script>
    <script src="modules/editor/cursor.js"></script>
    <script src="modules/editor/editor-core.js"></script>
    <script src="modules/editor/editor-api.js"></script>
    <script src="modules/editor/editor-init.js"></script>
    
    <!-- 模块加载错误处理 -->
    <script>
        window.addEventListener('error', function(e) {
            if (e.filename && e.filename.includes('modules/')) {
                console.error('[Module Load Error]', e.filename, e.lineno, e.message);
                // 可以显示友好的错误提示
            }
        }, true);
    </script>

    <script>
        // ==================== 日志系统 ====================
        // 注意：Logger 已移至 modules/core/logger.js
        // 以下代码保留作为备份，将在所有模块提取完成后删除
        /*
        /**
         * 统一日志系统：分级日志和配置
         * 参考 CKEditor 5 的日志系统设计
         * 
         * 日志级别：
         * - debug: 详细的调试信息，用于开发调试
         * - info: 一般信息，记录正常操作流程
         * - warn: 警告信息，不影响功能但需要注意
         * - error: 错误信息，功能异常或失败
         * 
         * 日志格式：[级别] [模块] 消息 [上下文]
         * 示例：[DEBUG] [Editor] 加载内容完成 {xmlLength: 1234}
         */
        class Logger {
            constructor() {
                this.level = 'info'; // debug, info, warn, error
                this.enabled = true;
                this.levels = {
                    debug: 0,
                    info: 1,
                    warn: 2,
                    error: 3
                };
                this.enabledModules = new Set(); // 空集合表示所有模块都启用
                this.timers = new Map(); // 用于性能计时
                this.logHistory = []; // 日志历史记录（可选，用于调试）
                this.maxHistorySize = 100; // 最大历史记录数
            }
            
            /**
             * 设置日志级别
             * @param {string} level - 日志级别 (debug, info, warn, error)
             */
            setLevel(level) {
                if (this.levels.hasOwnProperty(level)) {
                    const oldLevel = this.level;
                    this.level = level;
                    // 使用原生 console 避免循环调用
                    if (oldLevel !== level) {
                        this._rawLog('info', `[Logger] 日志级别从 ${oldLevel} 更改为 ${level}`);
                    }
                } else {
                    this._rawLog('warn', `[Logger] 无效的日志级别: ${level}，有效值: ${Object.keys(this.levels).join(', ')}`);
                }
            }
            
            /**
             * 启用日志
             */
            enable() {
                if (!this.enabled) {
                    this.enabled = true;
                    this._rawLog('info', '[Logger] 日志已启用');
                }
            }
            
            /**
             * 禁用日志
             */
            disable() {
                if (this.enabled) {
                    this.enabled = false;
                    // 禁用时使用原生 console，因为 logger 已禁用
                    console.info('[Logger] 日志已禁用');
                }
            }
            
            /**
             * 启用特定模块的日志
             * @param {string|string[]} modules - 模块名称或模块名称数组
             */
            enableModules(modules) {
                const moduleArray = Array.isArray(modules) ? modules : [modules];
                moduleArray.forEach(module => {
                    this.enabledModules.add(module);
                });
            }
            
            /**
             * 禁用特定模块的日志
             * @param {string|string[]} modules - 模块名称或模块名称数组
             */
            disableModules(modules) {
                const moduleArray = Array.isArray(modules) ? modules : [modules];
                moduleArray.forEach(module => {
                    this.enabledModules.delete(module);
                });
            }
            
            /**
             * 检查模块是否启用
             * @param {string} module - 模块名称
             * @returns {boolean}
             */
            _isModuleEnabled(module) {
                // 如果 enabledModules 为空，所有模块都启用
                if (this.enabledModules.size === 0) {
                    return true;
                }
                return this.enabledModules.has(module);
            }
            
            /**
             * 格式化日志消息
             * @param {string} level - 日志级别
             * @param {string} module - 模块名称
             * @param {string} message - 消息
             * @param {object} context - 上下文对象（可选）
             * @returns {string}
             */
            _formatMessage(level, module, message, context) {
                const levelUpper = level.toUpperCase();
                const modulePart = module ? `[${module}]` : '';
                let formatted = `[${levelUpper}] ${modulePart} ${message}`;
                
                if (context && Object.keys(context).length > 0) {
                    try {
                        const contextStr = JSON.stringify(context, null, 0);
                        formatted += ` ${contextStr}`;
                    } catch (e) {
                        formatted += ` [上下文序列化失败: ${e.message}]`;
                    }
                }
                
                return formatted;
            }
            
            /**
             * 原始日志输出（避免循环调用）
             * @private
             */
            _rawLog(level, message, ...args) {
                const method = level === 'error' ? 'error' : 
                              level === 'warn' ? 'warn' : 
                              level === 'debug' ? 'debug' : 'info';
                console[method](message, ...args);
            }
            
            /**
             * 记录日志（内部方法）
             * @private
             */
            _log(level, module, message, context, ...args) {
                if (!this.enabled || !this._shouldLog(level) || !this._isModuleEnabled(module)) {
                    return;
                }
                
                const formattedMessage = this._formatMessage(level, module, message, context);
                
                // 根据级别选择输出方法
                const consoleMethod = level === 'error' ? 'error' : 
                                     level === 'warn' ? 'warn' : 
                                     level === 'debug' ? 'debug' : 'info';
                
                console[consoleMethod](formattedMessage, ...args);
                
                // 可选：保存到历史记录
                if (this.logHistory.length >= this.maxHistorySize) {
                    this.logHistory.shift();
                }
                this.logHistory.push({
                    timestamp: new Date().toISOString(),
                    level,
                    module,
                    message,
                    context,
                    args: args.length > 0 ? args : undefined
                });
            }
            
            /**
             * 调试日志
             * @param {string} module - 模块名称
             * @param {string} message - 消息
             * @param {object} context - 上下文对象（可选）
             * @param {...any} args - 额外参数
             */
            debug(module, message, context, ...args) {
                if (typeof module === 'string' && typeof message === 'string') {
                    this._log('debug', module, message, context, ...args);
                } else {
                    // 兼容旧格式：logger.debug('[Module] message', ...args)
                    this._log('debug', '', module, message, ...args);
                }
            }
            
            /**
             * 信息日志
             * @param {string} module - 模块名称
             * @param {string} message - 消息
             * @param {object} context - 上下文对象（可选）
             * @param {...any} args - 额外参数
             */
            info(module, message, context, ...args) {
                if (typeof module === 'string' && typeof message === 'string') {
                    this._log('info', module, message, context, ...args);
                } else {
                    // 兼容旧格式：logger.info('[Module] message', ...args)
                    this._log('info', '', module, message, ...args);
                }
            }
            
            /**
             * 警告日志
             * @param {string} module - 模块名称
             * @param {string} message - 消息
             * @param {object} context - 上下文对象（可选）
             * @param {...any} args - 额外参数
             */
            warn(module, message, context, ...args) {
                if (typeof module === 'string' && typeof message === 'string') {
                    this._log('warn', module, message, context, ...args);
                } else {
                    // 兼容旧格式：logger.warn('[Module] message', ...args)
                    this._log('warn', '', module, message, ...args);
                }
            }
            
            /**
             * 错误日志
             * @param {string} module - 模块名称
             * @param {string} message - 消息
             * @param {object} context - 上下文对象（可选）
             * @param {...any} args - 额外参数
             */
            error(module, message, context, ...args) {
                if (typeof module === 'string' && typeof message === 'string') {
                    this._log('error', module, message, context, ...args);
                } else {
                    // 兼容旧格式：logger.error('[Module] message', ...args)
                    this._log('error', '', module, module, message, ...args);
                }
            }
            
            /**
             * 开始性能计时
             * @param {string} module - 模块名称
             * @param {string} label - 计时标签
             */
            time(module, label) {
                const timerKey = `${module}:${label}`;
                this.timers.set(timerKey, performance.now());
                this.debug(module, `开始计时: ${label}`);
            }
            
            /**
             * 结束性能计时并输出
             * @param {string} module - 模块名称
             * @param {string} label - 计时标签
             */
            timeEnd(module, label) {
                const timerKey = `${module}:${label}`;
                const startTime = this.timers.get(timerKey);
                if (startTime !== undefined) {
                    const duration = performance.now() - startTime;
                    this.debug(module, `计时结束: ${label}`, { duration: `${duration.toFixed(2)}ms` });
                    this.timers.delete(timerKey);
                } else {
                    this.warn(module, `未找到计时器: ${label}`);
                }
            }
            
            /**
             * 开始日志分组
             * @param {string} module - 模块名称
             * @param {string} label - 分组标签
             */
            group(module, label) {
                if (this.enabled && this._shouldLog('debug') && this._isModuleEnabled(module)) {
                    console.group(`[${module}] ${label}`);
                }
            }
            
            /**
             * 结束日志分组
             */
            groupEnd() {
                if (this.enabled && this._shouldLog('debug')) {
                    console.groupEnd();
                }
            }
            
            /**
             * 获取日志历史
             * @param {number} count - 获取最近 N 条日志
             * @returns {Array}
             */
            getHistory(count) {
                if (count) {
                    return this.logHistory.slice(-count);
                }
                return this.logHistory.slice();
            }
            
            /**
             * 清空日志历史
             */
            clearHistory() {
                this.logHistory = [];
            }
            
            /**
             * 检查是否应该记录该级别的日志
             * @private
             */
            _shouldLog(level) {
                return this.levels[level] >= this.levels[this.level];
            }
        }
        
        // 全局日志实例
        const logger = new Logger();
        
        // 从 URL 参数或 localStorage 读取日志配置
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // 日志级别
            const logLevel = urlParams.get('logLevel') || localStorage.getItem('editorLogLevel') || 'info';
            logger.setLevel(logLevel);
            
            // 启用的模块（逗号分隔）
            const enabledModules = urlParams.get('logModules') || localStorage.getItem('editorLogModules');
            if (enabledModules) {
                logger.enableModules(enabledModules.split(',').map(m => m.trim()));
            }
            
            // 禁用的模块（逗号分隔）
            const disabledModules = urlParams.get('logDisableModules') || localStorage.getItem('editorLogDisableModules');
            if (disabledModules) {
                logger.disableModules(disabledModules.split(',').map(m => m.trim()));
            }
        })();
        
        // 导出到全局，方便调试
        window.MiNoteLogger = logger;
        
        // ==================== 日志模块常量 ====================
        /**
         * 日志模块名称常量
         * 用于统一标识不同的功能模块
         */
        const LOG_MODULES = {
            EDITOR: 'Editor',           // 编辑器核心
            DOM_WRITER: 'DOMWriter',   // DOM 操作
            CONVERTER: 'Converter',     // XML/HTML 转换
            CURSOR: 'Cursor',           // 光标管理
            FORMAT: 'Format',           // 格式操作
            HISTORY: 'History',         // 撤销/重做
            IMAGE: 'Image',             // 图片处理
            LIST: 'List',               // 列表操作
            SELECTION: 'Selection',     // 选择管理
            SYNC: 'Sync',               // 状态同步
            INIT: 'Init',               // 初始化
            EVENT: 'Event',             // 事件处理
            UTILS: 'Utils'              // 工具函数
        };
        
        /**
         * 日志辅助函数：简化日志调用
         * 使用方式：
         *   log.debug(LOG_MODULES.EDITOR, '消息', {context: 'value'})
         *   log.info(LOG_MODULES.EDITOR, '消息')
         *   log.warn(LOG_MODULES.EDITOR, '消息', error)
         *   log.error(LOG_MODULES.EDITOR, '消息', {error: error.message})
         */
        const log = {
            debug: (module, message, context, ...args) => logger.debug(module, message, context, ...args),
            info: (module, message, context, ...args) => logger.info(module, message, context, ...args),
            warn: (module, message, context, ...args) => logger.warn(module, message, context, ...args),
            error: (module, message, context, ...args) => logger.error(module, message, context, ...args),
            time: (module, label) => logger.time(module, label),
            timeEnd: (module, label) => logger.timeEnd(module, label),
            group: (module, label) => logger.group(module, label),
            groupEnd: () => logger.groupEnd()
        };
        
        // ==================== 操作类型枚举 ====================
        /**
         * 操作类型枚举
         * 用于分类和合并操作
         */
        const OPERATION_TYPES = {
            INPUT: 'input',           // 文本输入
            DELETE: 'delete',         // 删除操作
            FORMAT: 'format',         // 格式操作（加粗、斜体等）
            FORMAT_REMOVE: 'format_remove', // 移除格式
            HEADING: 'heading',       // 标题
            ALIGNMENT: 'alignment',   // 对齐
            LIST: 'list',             // 列表
            CHECKBOX: 'checkbox',     // 复选框
            QUOTE: 'quote',           // 引用
            IMAGE: 'image',           // 图片
            INDENT: 'indent',         // 缩进
            HR: 'hr',                 // 水平线
            BATCH: 'batch',           // 批量操作
            OTHER: 'other'            // 其他操作
        };
        
        // ==================== 命令系统 ====================
        /**
         * 命令基类
         * 参考 CKEditor 5 的命令系统设计
         * 统一所有操作的接口，支持执行、撤销、状态检查
         */
        class Command {
            /**
             * 创建命令
             * @param {string} name - 命令名称
             * @param {Object} options - 命令选项
             * @param {Function} options.execute - 执行函数
             * @param {Function} options.undo - 撤销函数（可选）
             * @param {Function} options.canExecute - 是否可执行检查函数（可选）
             * @param {Function} options.getState - 获取状态函数（可选）
             * @param {string} options.type - 操作类型（用于历史记录）
             */
            constructor(name, options = {}) {
                this.name = name;
                this.executeFn = options.execute;
                this.undoFn = options.undo;
                this.canExecuteFn = options.canExecute;
                this.getStateFn = options.getState;
                this.type = options.type || OPERATION_TYPES.OTHER;
                this.state = null; // 命令执行后的状态（用于撤销）
                this.metadata = options.metadata || {}; // 命令元数据
                
                if (!this.executeFn) {
                    throw new Error(`Command ${name} must have an execute function`);
                }
            }
            
            /**
             * 执行命令
             * @param {Object} context - 执行上下文
             * @returns {*} 执行结果
             */
            execute(context = {}) {
                // 检查是否可执行
                if (!this.canExecute(context)) {
                    const error = new Error(`Command ${this.name} cannot be executed in current context`);
                    log.warn(LOG_MODULES.FORMAT, '命令无法执行', { 
                        command: this.name, 
                        context 
                    });
                    throw error;
                }
                
                try {
                    // 执行命令
                    this.state = this.executeFn(context);
                    
                    log.debug(LOG_MODULES.FORMAT, '命令执行成功', { 
                        command: this.name,
                        type: this.type
                    });
                    
                    return this.state;
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '命令执行失败', { 
                        command: this.name, 
                        error: error.message,
                        stack: error.stack
                    });
                    throw error;
                }
            }
            
            /**
             * 撤销命令
             * @param {Object} context - 执行上下文
             * @returns {*} 撤销结果
             */
            undo(context = {}) {
                if (!this.undoFn) {
                    throw new Error(`Command ${this.name} does not support undo`);
                }
                
                if (this.state === null) {
                    throw new Error(`Command ${this.name} has no state to undo`);
                }
                
                try {
                    const result = this.undoFn(context, this.state);
                    
                    log.debug(LOG_MODULES.FORMAT, '命令撤销成功', { 
                        command: this.name 
                    });
                    
                    return result;
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '命令撤销失败', { 
                        command: this.name, 
                        error: error.message 
                    });
                    throw error;
                }
            }
            
            /**
             * 检查命令是否可执行
             * @param {Object} context - 执行上下文
             * @returns {boolean} 是否可执行
             */
            canExecute(context = {}) {
                if (!this.canExecuteFn) {
                    return true; // 默认可以执行
                }
                
                try {
                    return this.canExecuteFn(context);
                } catch (error) {
                    log.warn(LOG_MODULES.FORMAT, '命令可执行性检查失败', { 
                        command: this.name, 
                        error: error.message 
                    });
                    return false;
                }
            }
            
            /**
             * 获取命令状态
             * @param {Object} context - 执行上下文
             * @returns {*} 命令状态
             */
            getState(context = {}) {
                if (!this.getStateFn) {
                    return null;
                }
                
                try {
                    return this.getStateFn(context);
                } catch (error) {
                    log.warn(LOG_MODULES.FORMAT, '获取命令状态失败', { 
                        command: this.name, 
                        error: error.message 
                    });
                    return null;
                }
            }
        }
        
        /**
         * 命令管理器
         * 负责命令的注册、执行和管理
         */
        class CommandManager {
            constructor(domWriter) {
                this.domWriter = domWriter;
                this.commands = new Map(); // 命令注册表
                this.commandHistory = []; // 命令执行历史
                this.historyIndex = -1;
                this.stateCache = new Map(); // 状态缓存
                this.stateCacheTimeout = 50; // 状态缓存超时时间（毫秒）
            }
            
            /**
             * 注册命令
             * @param {string} name - 命令名称
             * @param {Command|Object} command - 命令对象或命令选项
             */
            register(name, command) {
                if (command instanceof Command) {
                    this.commands.set(name, command);
                } else {
                    // 如果是选项对象，创建命令
                    this.commands.set(name, new Command(name, command));
                }
                
                log.debug(LOG_MODULES.FORMAT, '注册命令', { command: name });
            }
            
            /**
             * 执行命令
             * @param {string} name - 命令名称
             * @param {Object} context - 执行上下文
             * @returns {*} 执行结果
             */
            execute(name, context = {}) {
                const command = this.commands.get(name);
                if (!command) {
                    throw new Error(`Command ${name} is not registered`);
                }
                
                // 执行命令
                const result = command.execute(context);
                
                // 如果命令支持撤销，记录到历史
                if (command.undoFn) {
                    this._addToCommandHistory(name, command, context);
                }
                
                return result;
            }
            
            /**
             * 撤销上一个命令
             * @returns {boolean} 是否成功撤销
             */
            undo() {
                if (this.historyIndex < 0) {
                    return false;
                }
                
                const historyItem = this.commandHistory[this.historyIndex];
                const command = this.commands.get(historyItem.name);
                
                if (!command || !command.undoFn) {
                    return false;
                }
                
                try {
                    command.undo(historyItem.context);
                    this.historyIndex--;
                    return true;
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '撤销命令失败', { 
                        command: historyItem.name, 
                        error: error.message 
                    });
                    return false;
                }
            }
            
            /**
             * 检查命令是否可执行
             * @param {string} name - 命令名称
             * @param {Object} context - 执行上下文
             * @returns {boolean} 是否可执行
             */
            canExecute(name, context = {}) {
                const command = this.commands.get(name);
                if (!command) {
                    return false;
                }
                
                return command.canExecute(context);
            }
            
            /**
             * 获取命令状态
             * @param {string} name - 命令名称
             * @param {Object} context - 执行上下文
             * @param {boolean} useCache - 是否使用缓存（默认 true）
             * @returns {*} 命令状态
             */
            getState(name, context = {}, useCache = true) {
                const command = this.commands.get(name);
                if (!command) {
                    return null;
                }
                
                // 检查缓存
                if (useCache && this.stateCache.has(name)) {
                    const cached = this.stateCache.get(name);
                    const now = Date.now();
                    if (now - cached.timestamp < this.stateCacheTimeout) {
                        return cached.state;
                    }
                }
                
                // 获取新状态
                const state = command.getState(context);
                
                // 更新缓存
                if (useCache) {
                    this.stateCache.set(name, {
                        state: state,
                        timestamp: Date.now()
                    });
                }
                
                return state;
            }
            
            /**
             * 批量获取多个命令的状态
             * @param {string[]} names - 命令名称数组
             * @param {Object} context - 执行上下文
             * @returns {Object} 命令状态映射
             */
            getStates(names, context = {}) {
                const states = {};
                names.forEach(name => {
                    states[name] = this.getState(name, context);
                });
                return states;
            }
            
            /**
             * 清除状态缓存
             * @param {string} name - 命令名称（可选，不提供则清除所有缓存）
             */
            clearStateCache(name = null) {
                if (name) {
                    this.stateCache.delete(name);
                } else {
                    this.stateCache.clear();
                }
            }
            
            /**
             * 检查命令是否可执行（批量检查）
             * @param {string[]} names - 命令名称数组
             * @param {Object} context - 执行上下文
             * @returns {Object} 命令可执行性映射
             */
            canExecuteBatch(names, context = {}) {
                const results = {};
                names.forEach(name => {
                    results[name] = this.canExecute(name, context);
                });
                return results;
            }
            
            /**
             * 添加到命令历史
             * @private
             */
            _addToCommandHistory(name, command, context) {
                // 如果当前不在历史末尾，删除后面的记录
                if (this.historyIndex < this.commandHistory.length - 1) {
                    this.commandHistory = this.commandHistory.slice(0, this.historyIndex + 1);
                }
                
                this.commandHistory.push({
                    name: name,
                    command: command,
                    context: context,
                    timestamp: Date.now()
                });
                
                this.historyIndex = this.commandHistory.length - 1;
            }
        }
        
        // ==================== 命令注册函数 ====================
        /**
         * 注册格式命令
         * @param {CommandManager} cmdManager - 命令管理器
         * @param {DOMWriter} domWriter - DOM 写入器
         */
        function _registerFormatCommands(cmdManager, domWriter) {
            const editor = document.getElementById('editor-content');
            if (!editor) {
                log.warn(LOG_MODULES.FORMAT, '编辑器元素不存在，无法注册格式命令');
                return;
            }
            
            // 格式命令：加粗、斜体、下划线、删除线、高亮
            const formatCommands = ['bold', 'italic', 'underline', 'strikethrough', 'highlight'];
            
            formatCommands.forEach(format => {
                cmdManager.register(`format:${format}`, {
                    type: OPERATION_TYPES.FORMAT,
                    execute: (context) => {
                        // 使用现有的 applyFormat 方法
                        const result = window.MiNoteWebEditor.applyFormat(format);
                        
                        // 返回状态（用于撤销）
                        return {
                            format: format,
                            result: result
                        };
                    },
                    canExecute: (context) => {
                        // 检查是否有选择内容
                        const selection = window.getSelection();
                        return selection && selection.rangeCount > 0;
                    },
                    getState: (context) => {
                        // 检查当前格式状态
                        const selection = window.getSelection();
                        if (!selection || selection.rangeCount === 0) {
                            return { active: false };
                        }
                        
                        const range = selection.getRangeAt(0);
                        const isActive = window.MiNoteWebEditor.checkFormatState(range, format);
                        return { active: isActive };
                    },
                    metadata: {
                        format: format,
                        category: 'text-format'
                    }
                });
            });
            
            log.info(LOG_MODULES.FORMAT, '格式命令注册完成', { 
                count: formatCommands.length 
            });
        }
        
        // ==================== 全局变量 ====================
        let xmlToHtmlConverter = null;
        let htmlToXmlConverter = null;
        let currentContent = '';
        let isInitialized = false;
        let isLoadingContent = false;
        let contentChangeTimer = null;
        let formatStateSyncTimer = null; // 格式状态同步定时器
        let isComposing = false; // 是否正在组合输入（IME 输入法输入中）
        let commandManager = null; // 命令管理器（将在 DOMWriter 初始化后创建）

        // ==================== 初始化 ====================
        document.addEventListener('DOMContentLoaded', function() {
            // 初始化转换器
            xmlToHtmlConverter = new XMLToHTMLConverter();
            htmlToXmlConverter = new HTMLToXMLConverter();

            const editor = document.getElementById('editor-content');
            if (!editor) {
                log.error(LOG_MODULES.EDITOR, '无法找到编辑器元素');
                    return;
                }
                
            // 初始化 DOM Writer（统一 DOM 操作接口）
            domWriter = new DOMWriter(editor);
            
            // 初始化命令管理器
            commandManager = new CommandManager(domWriter);
            
            // 注册格式命令
            _registerFormatCommands(commandManager, domWriter);
                
            // 设置占位符
            if (!editor.innerHTML.trim()) {
                editor.innerHTML = '<div class="placeholder">开始输入...</div>';
            }

            // 组合输入开始（IME 输入法开始输入，如中文输入）
            editor.addEventListener('compositionstart', function() {
                isComposing = true;
                log.debug(LOG_MODULES.EDITOR, '组合输入开始');
                // 清除待处理的定时器，避免在组合输入期间触发
                clearTimeout(contentChangeTimer);
                clearTimeout(formatStateSyncTimer);
            });

            // 组合输入更新（IME 输入法输入过程中）
            editor.addEventListener('compositionupdate', function() {
                // 保持 isComposing 为 true
                isComposing = true;
            });

            // 组合输入结束（IME 输入法输入完成）
            editor.addEventListener('compositionend', function() {
                isComposing = false;
                log.debug(LOG_MODULES.EDITOR, '组合输入结束');
                // 组合输入结束后，延迟触发内容变化通知（等待 DOM 更新）
                setTimeout(function() {
                    if (!isLoadingContent && !isComposing) {
                        notifyContentChanged();
                    }
                }, 50); // 50ms 延迟，确保 DOM 更新完成
            });

            // 内容变化监听（防抖处理）
            // 注意：在组合输入期间不触发，避免打断输入
            editor.addEventListener('input', function(e) {
                if (isLoadingContent || isComposing) {
                    return;
                }
                clearTimeout(contentChangeTimer);
                contentChangeTimer = setTimeout(function() {
                    if (!isComposing) {
                        notifyContentChanged();
                    }
                }, 300); // 300ms 防抖
            });

            // 选择变化监听（用于同步格式状态）
            // 参考 CKEditor 5：在 selectionchange 时同步所有格式状态
            // 注意：不要在这里修复光标位置，避免与格式操作冲突导致光标跳动
            // 注意：在组合输入期间不触发，避免打断输入
            document.addEventListener('selectionchange', function() {
                if (isLoadingContent || !isInitialized || isComposing) {
                    return;
                }
                // 延迟同步，避免频繁更新
                // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                clearTimeout(formatStateSyncTimer);
                formatStateSyncTimer = setTimeout(function() {
                    if (!isComposing) {
                        requestAnimationFrame(() => {
                            if (!isComposing && !isLoadingContent) {
                                syncFormatState();
                            }
                        });
                    }
                }, 30); // 减少防抖延迟到 30ms，提高响应速度
            });

            // 输入事件时也同步格式状态（参考 CKEditor 5）
            // 注意：在组合输入期间不触发，避免打断输入
            editor.addEventListener('input', function() {
                if (isLoadingContent || !isInitialized || isComposing) {
                    return;
                }
                // 延迟同步，避免频繁更新
                // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                clearTimeout(formatStateSyncTimer);
                formatStateSyncTimer = setTimeout(function() {
                    if (!isComposing) {
                        requestAnimationFrame(() => {
                            if (!isComposing && !isLoadingContent) {
                                syncFormatState();
                            }
                        });
                    }
                }, 30); // 减少防抖延迟到 30ms，提高响应速度
            });

            // 键盘事件时也同步格式状态（参考 CKEditor 5）
            // 注意：在组合输入期间不触发，避免打断输入
            editor.addEventListener('keyup', function() {
                if (isLoadingContent || !isInitialized || isComposing) {
                    return;
                }
                // 延迟同步，避免频繁更新
                // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                clearTimeout(formatStateSyncTimer);
                formatStateSyncTimer = setTimeout(function() {
                    if (!isComposing) {
                        requestAnimationFrame(() => {
                            if (!isComposing && !isLoadingContent) {
                                syncFormatState();
                            }
                        });
                    }
                }, 30); // 减少防抖延迟到 30ms，提高响应速度
            });

            // 处理回车键事件
            // 注意：在组合输入期间不处理，避免打断输入
            // 使用 capture 阶段捕获事件，确保在其他处理之前执行
            editor.addEventListener('keydown', function(e) {
                if (isComposing) {
                    return; // 组合输入期间不处理
                }
                if (e.key === 'Enter' && !e.shiftKey) {
                    // 在处理回车键之前，先检查是否在 checkbox、bullet 或 order 中
                    // 如果是，立即阻止默认行为，避免浏览器创建额外的元素
                    const selection = window.getSelection();
                    if (selection && selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        let container = range.commonAncestorContainer;
                        if (container.nodeType === Node.TEXT_NODE) {
                            container = container.parentElement;
                        }
                        
                        let current = container;
                        while (current && current !== editor) {
                            if (current.classList && (
                                current.classList.contains('mi-note-checkbox') ||
                                current.classList.contains('mi-note-bullet') ||
                                current.classList.contains('mi-note-order')
                            )) {
                                // 在特殊元素中，立即阻止默认行为
                                e.preventDefault();
                                e.stopPropagation();
                                handleEnterKey(e);
                                return;
                            }
                            current = current.parentElement;
                        }
                    }
                    
                    // 不在特殊元素中，正常处理
                    handleEnterKey(e);
                }
            }, true); // 使用 capture 阶段，确保在其他处理之前执行

            // 使用 MutationObserver 监听 DOM 变化，自动修复光标位置（参考 CKEditor 5 的 Selection Post-Fixer）
            // 这确保在每次 DOM 操作后，光标位置都是有效的
            let mutationObserverTimer = null;
            const mutationObserver = new MutationObserver(function(mutations) {
                // 只在非加载内容时修复光标位置
                if (isLoadingContent || !isInitialized || isComposing) {
                    return;
                }
                
                // 防抖处理，避免频繁调用 normalizeCursorPosition
                clearTimeout(mutationObserverTimer);
                mutationObserverTimer = setTimeout(() => {
                    // 延迟修复，确保 DOM 操作完成
                    requestAnimationFrame(() => {
                        if (!isComposing && !isLoadingContent) {
                            normalizeCursorPosition();
                        }
                    });
                }, 10); // 10ms 防抖，平衡响应速度和性能
            });
            
            // 开始监听 DOM 变化
            mutationObserver.observe(editor, {
                childList: true,      // 监听子节点的添加和删除
                subtree: true,        // 监听所有后代节点
                characterData: true,  // 监听文本内容变化
                attributes: false     // 不监听属性变化（避免频繁触发）
            });

            // 初始化完成
            isInitialized = true;
            log.info(LOG_MODULES.EDITOR, '编辑器初始化完成');

            // 通知 Swift 编辑器已准备好
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                        window.webkit.messageHandlers.editorBridge.postMessage({
                    type: 'editorReady'
                });
            }
        });

        // ==================== DOM Writer（统一 DOM 操作接口）====================
        /**
         * DOM Writer 类（参考 CKEditor 5 的 writer 接口）
         * 
         * 封装所有 DOM 操作，确保：
         * 1. 操作原子性（要么全部成功，要么全部失败）
         * 2. 自动处理光标位置保存/恢复
         * 3. 自动触发状态同步
         * 4. 支持批量操作
         */
        class DOMWriter {
            constructor(editor) {
                this.editor = editor;
                this.batchMode = false;
                this.batchOperations = [];
                this.shouldSyncState = false;
                
                // 操作历史（用于撤销/重做）
                this.operationHistory = [];
                this.historyIndex = -1;
                this.maxHistorySize = 50; // 最多保存 50 个操作
                this.useIncrementalRecording = true; // 是否使用增量记录
                this.snapshotInterval = 10; // 每隔 N 个操作保存一个完整快照
                this.lastSnapshotIndex = -1; // 最后一个完整快照的索引
            }

            /**
             * 开始批量操作模式
             * 在批量操作期间，DOM 更新会延迟执行
             */
            beginBatch() {
                this.batchMode = true;
                this.batchOperations = [];
            }

            /**
             * 结束批量操作模式
             * 执行所有延迟的 DOM 操作
             * @param {Object} metadata - 批量操作的元数据（用于历史记录）
             */
            endBatch(metadata = null) {
                this.batchMode = false;
                const operations = this.batchOperations;
                this.batchOperations = [];
                
                // 记录批量操作前的状态（使用增量记录）
                const previousState = this.operationHistory.length > 0 && this.historyIndex >= 0
                    ? (this.operationHistory[this.historyIndex].afterState || this.operationHistory[this.historyIndex].beforeState)
                    : null;
                const beforeState = this._captureState(this.useIncrementalRecording, previousState);
                const savedPosition = window.MiNoteWebEditor._saveCursorPosition();
                
                // 执行所有操作
                operations.forEach(op => op());
                
                // 记录批量操作后的状态（使用增量记录）
                const afterState = this._captureState(this.useIncrementalRecording, beforeState);
                
                // 添加到历史记录（如果不是加载内容操作）
                if (!isLoadingContent && metadata !== null) {
                    this._addToHistory({
                        type: metadata.type || OPERATION_TYPES.BATCH,
                        command: metadata.command || null,
                        value: metadata.value || null,
                        format: metadata.format || null,
                        beforeState: beforeState,
                        afterState: afterState,
                        savedPosition: savedPosition,
                        timestamp: Date.now(),
                        isBatch: metadata.isBatch !== false // 批量操作默认允许合并
                    });
                }
                
                // 批量操作后，统一处理光标和状态
                if (this.shouldSyncState) {
                    requestAnimationFrame(() => {
                        if (!isComposing && !isLoadingContent) {
                            normalizeCursorPosition();
                            syncFormatState();
                        }
                    });
                    this.shouldSyncState = false;
                }
            }

            /**
             * 执行 DOM 操作（自动处理光标和状态）
             * @param {Function} operation - DOM 操作函数
             * @param {boolean} syncState - 是否同步状态（默认 true）
             * @param {Object} metadata - 操作元数据（用于历史记录）
             */
            execute(operation, syncState = true, metadata = null) {
                // 保存光标位置
                const savedPosition = window.MiNoteWebEditor._saveCursorPosition();
                
                // 记录操作前的状态（用于撤销，使用增量记录）
                const previousState = this.operationHistory.length > 0 && this.historyIndex >= 0
                    ? (this.operationHistory[this.historyIndex].afterState || this.operationHistory[this.historyIndex].beforeState)
                    : null;
                const beforeState = this._captureState(this.useIncrementalRecording, previousState);
                
                if (this.batchMode) {
                    // 批量模式：延迟执行
                    this.batchOperations.push(() => {
                        operation();
                        if (syncState) {
                            this.shouldSyncState = true;
                        }
                    });
                } else {
                    // 立即执行
                    operation();
                    
                    // 记录操作后的状态（使用增量记录）
                    const afterState = this._captureState(this.useIncrementalRecording, beforeState);
                    
                    // 添加到历史记录（如果不是加载内容操作）
                    // 注意：metadata 为 null 时表示不记录历史（如加载内容、属性变化等）
                    if (!isLoadingContent && metadata !== null) {
                        this._addToHistory({
                            type: metadata.type || OPERATION_TYPES.OTHER,
                            command: metadata.command || null,
                            value: metadata.value || null,
                            format: metadata.format || null,
                            beforeState: beforeState,
                            afterState: afterState,
                            savedPosition: savedPosition,
                            timestamp: Date.now(),
                            isBatch: metadata.isBatch || false // 是否允许合并
                        });
                    }
                    
                    // 恢复光标位置
                    if (savedPosition) {
                        requestAnimationFrame(() => {
                            window.MiNoteWebEditor._restoreCursorPosition(savedPosition);
                        });
                    }
                    
                    // 同步状态
                    if (syncState) {
                        requestAnimationFrame(() => {
                            if (!isComposing && !isLoadingContent) {
                                normalizeCursorPosition();
                                syncFormatState();
                            }
                        });
                    }
                }
            }

            /**
             * 执行操作并记录历史（便捷方法）
             * @param {Function} operation - DOM 操作函数
             * @param {string} type - 操作类型
             * @param {boolean} syncState - 是否同步状态（默认 true）
             */
            executeWithHistory(operation, type, syncState = true) {
                this.execute(operation, syncState, { type: type });
            }

            /**
             * 执行 execCommand 并记录历史
             * 由于 execCommand 是浏览器原生 API，不能直接包装，所以需要在调用前后记录状态
             * @param {string} command - execCommand 命令
             * @param {boolean} showUI - 是否显示 UI（默认 false）
             * @param {string} value - 命令值（可选）
             * @param {string} type - 操作类型（用于历史记录）
             * @returns {boolean} execCommand 的返回值
             */
            executeCommandWithHistory(command, showUI = false, value = null, type = null) {
                // 如果没有指定类型，根据 command 推断
                if (!type) {
                    // 推断操作类型
                    if (command === 'insertText' || command === 'insertHTML') {
                        type = OPERATION_TYPES.INPUT;
                    } else if (command === 'delete' || command === 'forwardDelete') {
                        type = OPERATION_TYPES.DELETE;
                    } else if (command.startsWith('format')) {
                        type = OPERATION_TYPES.FORMAT;
                    } else {
                        type = OPERATION_TYPES.OTHER;
                    }
                }
                
                // 记录操作前的状态（使用增量记录）
                const previousState = this.operationHistory.length > 0 && this.historyIndex >= 0
                    ? (this.operationHistory[this.historyIndex].afterState || this.operationHistory[this.historyIndex].beforeState)
                    : null;
                const beforeState = this._captureState(this.useIncrementalRecording, previousState);
                const savedPosition = window.MiNoteWebEditor._saveCursorPosition();
                
                // 执行 execCommand
                const result = document.execCommand(command, showUI, value);
                
                // 如果执行成功，记录操作后的状态
                if (result && !isLoadingContent) {
                    // 延迟捕获状态，确保 DOM 更新完成
                    requestAnimationFrame(() => {
                        const afterState = this._captureState(this.useIncrementalRecording, beforeState);
                        
                        // 添加到历史记录（包含操作类型和命令信息）
                        // 格式操作标记为不合并（每次都是独立的撤销步骤）
                        this._addToHistory({
                            type: type,
                            command: command,
                            value: value,
                            beforeState: beforeState,
                            afterState: afterState,
                            savedPosition: savedPosition,
                            timestamp: Date.now(),
                            isBatch: false // 格式操作不是批量操作，不合并
                        });
                        
                        // 同步状态
                        if (!isComposing && !isLoadingContent) {
                            normalizeCursorPosition();
                            syncFormatState();
                        }
                    });
                }
                
                return result;
            }

            /**
             * DOM Diff 工具类
             * 用于计算两个 DOM 状态之间的差异，实现增量记录
             */
            static DOMDiff = class {
                /**
                 * 计算两个 HTML 字符串之间的差异
                 * @param {string} oldHtml - 旧的 HTML
                 * @param {string} newHtml - 新的 HTML
                 * @returns {Object} 差异对象
                 */
                static diff(oldHtml, newHtml) {
                    // 如果完全相同，返回空差异
                    if (oldHtml === newHtml) {
                        return { type: 'no-change' };
                    }
                    
                    // 简单实现：对于小变化，记录变化位置和内容
                    // 对于大变化，仍然使用完整快照（后续可以优化）
                    const oldLength = oldHtml.length;
                    const newLength = newHtml.length;
                    
                    // 如果变化超过 50%，使用完整快照（更高效）
                    const changeRatio = Math.abs(newLength - oldLength) / Math.max(oldLength, 1);
                    if (changeRatio > 0.5) {
                        return {
                            type: 'full-snapshot',
                            html: newHtml
                        };
                    }
                    
                    // 计算差异：找到第一个不同的位置和最后一个不同的位置
                    let startDiff = 0;
                    let endDiff = Math.min(oldLength, newLength);
                    
                    // 从前面找到第一个不同的位置
                    while (startDiff < endDiff && oldHtml[startDiff] === newHtml[startDiff]) {
                        startDiff++;
                    }
                    
                    // 从后面找到最后一个不同的位置
                    let oldEnd = oldLength - 1;
                    let newEnd = newLength - 1;
                    while (oldEnd >= startDiff && newEnd >= startDiff && 
                           oldHtml[oldEnd] === newHtml[newEnd]) {
                        oldEnd--;
                        newEnd--;
                    }
                    
                    // 提取变化的部分
                    const oldChanged = oldHtml.substring(startDiff, oldEnd + 1);
                    const newChanged = newHtml.substring(startDiff, newEnd + 1);
                    
                    return {
                        type: 'incremental',
                        start: startDiff,
                        oldLength: oldChanged.length,
                        newLength: newChanged.length,
                        oldContent: oldChanged,
                        newContent: newChanged
                    };
                }
                
                /**
                 * 根据差异恢复 HTML
                 * @param {string} baseHtml - 基础 HTML
                 * @param {Object} diff - 差异对象
                 * @returns {string} 恢复后的 HTML
                 */
                static apply(baseHtml, diff) {
                    if (diff.type === 'no-change') {
                        return baseHtml;
                    }
                    
                    if (diff.type === 'full-snapshot') {
                        return diff.html;
                    }
                    
                    if (diff.type === 'incremental') {
                        const before = baseHtml.substring(0, diff.start);
                        const after = baseHtml.substring(diff.start + diff.oldLength);
                        return before + diff.newContent + after;
                    }
                    
                    // 未知类型，返回原 HTML
                    log.warn(LOG_MODULES.HISTORY, '未知的差异类型', { type: diff.type });
                    return baseHtml;
                }
            };
            
            /**
             * 捕获当前编辑器状态（用于历史记录）
             * @param {boolean} useIncremental - 是否使用增量记录（默认 false，逐步启用）
             * @param {Object} previousState - 前一个状态（用于增量记录）
             * @returns {Object} 状态快照或增量差异
             */
            _captureState(useIncremental = false, previousState = null) {
                const html = this.editor.innerHTML;
                const cursorPosition = window.MiNoteWebEditor._saveCursorPosition();
                
                // 如果使用增量记录且有前一个状态
                if (useIncremental && previousState && previousState.html) {
                    try {
                        const diff = DOMWriter.DOMDiff.diff(previousState.html, html);
                        
                        // 如果差异类型是增量，返回增量记录
                        if (diff.type === 'incremental') {
                            return {
                                type: 'incremental',
                                diff: diff,
                                cursorPosition: cursorPosition,
                                baseState: previousState // 引用基础状态
                            };
                        }
                        
                        // 如果差异太大，使用完整快照
                        if (diff.type === 'full-snapshot') {
                            return {
                                type: 'full-snapshot',
                                html: diff.html,
                                cursorPosition: cursorPosition
                            };
                        }
                    } catch (error) {
                        log.warn(LOG_MODULES.HISTORY, '增量记录失败，使用完整快照', { 
                            error: error.message 
                        });
                    }
                }
                
                // 默认使用完整快照
                return {
                    type: 'full-snapshot',
                    html: html,
                    cursorPosition: cursorPosition
                };
            }
            
            /**
             * 恢复状态（支持增量记录）
             * @param {Object} state - 状态对象（可能是完整快照或增量差异）
             * @returns {Object} 恢复后的完整状态
             */
            _restoreState(state) {
                if (state.type === 'full-snapshot') {
                    return {
                        html: state.html,
                        cursorPosition: state.cursorPosition
                    };
                }
                
                if (state.type === 'incremental' && state.baseState) {
                    // 需要先恢复基础状态
                    const baseState = this._restoreState(state.baseState);
                    const html = DOMWriter.DOMDiff.apply(baseState.html, state.diff);
                    return {
                        html: html,
                        cursorPosition: state.cursorPosition
                    };
                }
                
                // 未知类型，尝试直接使用
                log.warn(LOG_MODULES.HISTORY, '未知的状态类型，尝试直接使用', { 
                    type: state.type 
                });
                return {
                    html: state.html || '',
                    cursorPosition: state.cursorPosition
                };
            }

            /**
             * 检查两个操作是否可以合并
             * 参考 CKEditor 5 的实现：只有连续的用户输入操作才合并，格式操作不合并
             * @param {Object} op1 - 第一个操作
             * @param {Object} op2 - 第二个操作
             * @returns {boolean} 是否可以合并
             */
            _shouldMergeOperations(op1, op2) {
                // 必须相同类型
                if (op1.type !== op2.type) {
                    return false;
                }
                
                // 时间间隔检查
                const timeDiff = op2.timestamp - op1.timestamp;
                
                // 输入操作：只合并非常短时间内的连续输入（100ms）
                // 这样可以合并快速连续输入，但不会合并用户停顿后的输入
                if (op1.type === OPERATION_TYPES.INPUT) {
                    const inputMergeWindow = 100; // 100ms 内的输入可以合并
                    if (timeDiff > inputMergeWindow) {
                        return false;
                    }
                    
                    // 限制合并次数，避免无限合并（最多合并 50 次）
                    const maxMergedCount = 50;
                    if (op1.mergedCount && op1.mergedCount >= maxMergedCount) {
                        return false;
                    }
                    
                    // 检查光标位置是否变化太大（如果光标位置变化很大，可能是用户移动了光标，不应该合并）
                    if (op1.savedPosition && op2.savedPosition) {
                        // 简单检查：如果两个操作的光标位置路径长度差异很大，不合并
                        const pos1Path = op1.savedPosition.path || [];
                        const pos2Path = op2.savedPosition.path || [];
                        if (Math.abs(pos1Path.length - pos2Path.length) > 2) {
                            return false;
                        }
                    }
                    
                    return true;
                }
                
                // 删除操作：只合并短时间内的连续删除（150ms）
                if (op1.type === OPERATION_TYPES.DELETE) {
                    const deleteMergeWindow = 150; // 150ms 内的删除可以合并
                    if (timeDiff > deleteMergeWindow) {
                        return false;
                    }
                    
                    // 限制合并次数
                    const maxMergedCount = 30;
                    if (op1.mergedCount && op1.mergedCount >= maxMergedCount) {
                        return false;
                    }
                    
                    return true;
                }
                
                // 格式操作：默认不合并（每次格式操作都是独立的撤销步骤）
                // 只有在明确的批量操作模式下才合并
                if (op1.type === OPERATION_TYPES.FORMAT || op1.type === OPERATION_TYPES.FORMAT_REMOVE) {
                    // 格式操作不合并，除非是明确的批量操作
                    if (op1.isBatch && op2.isBatch) {
                        // 批量操作可以合并
                        return true;
                    }
                    return false;
                }
                
                // 其他操作：只有批量操作才合并
                if (op1.type === OPERATION_TYPES.BATCH && op2.type === OPERATION_TYPES.BATCH) {
                    // 批量操作可以合并（如果时间间隔很短）
                    const batchMergeWindow = 200;
                    return timeDiff <= batchMergeWindow;
                }
                
                // 其他操作默认不合并
                return false;
            }
            
            /**
             * 合并两个操作
             * @param {Object} op1 - 第一个操作（将被合并到）
             * @param {Object} op2 - 第二个操作（将被合并）
             * @returns {Object} 合并后的操作
             */
            _mergeOperations(op1, op2) {
                // 合并后的操作使用第一个操作的时间戳和 beforeState
                // 使用第二个操作的 afterState（最新的状态）
                return {
                    ...op1,
                    afterState: op2.afterState,
                    savedPosition: op2.savedPosition, // 使用最新的光标位置
                    mergedCount: (op1.mergedCount || 1) + 1, // 记录合并次数
                    lastTimestamp: op2.timestamp // 记录最后一次操作时间
                };
            }
            
            /**
             * 添加到操作历史（支持操作合并和增量记录）
             * @param {Object} operation - 操作记录
             */
            _addToHistory(operation) {
                // 如果当前不在历史末尾，删除后面的记录（重做分支被覆盖）
                if (this.historyIndex < this.operationHistory.length - 1) {
                    this.operationHistory = this.operationHistory.slice(0, this.historyIndex + 1);
                    // 重置快照索引
                    this.lastSnapshotIndex = Math.min(this.lastSnapshotIndex, this.historyIndex);
                }
                
                // 检查是否可以与上一个操作合并
                if (this.operationHistory.length > 0) {
                    const lastOperation = this.operationHistory[this.operationHistory.length - 1];
                    
                    if (this._shouldMergeOperations(lastOperation, operation)) {
                        // 合并操作：替换最后一个操作
                        log.debug(LOG_MODULES.HISTORY, '合并操作', { 
                            type: operation.type, 
                            mergedCount: (lastOperation.mergedCount || 1) + 1 
                        });
                        
                        const mergedOperation = this._mergeOperations(lastOperation, operation);
                        
                        // 如果使用增量记录，需要重新计算 afterState
                        if (this.useIncrementalRecording && mergedOperation.afterState) {
                            const previousState = lastOperation.beforeState;
                            mergedOperation.afterState = this._captureState(true, previousState);
                        }
                        
                        this.operationHistory[this.operationHistory.length - 1] = mergedOperation;
                        this.historyIndex = this.operationHistory.length - 1;
                        return;
                    }
                }
                
                // 如果使用增量记录，尝试使用增量状态
                if (this.useIncrementalRecording && this.operationHistory.length > 0) {
                    const lastOperation = this.operationHistory[this.operationHistory.length - 1];
                    const previousState = lastOperation.afterState || lastOperation.beforeState;
                    
                    // 计算是否需要保存完整快照（每隔 N 个操作）
                    const shouldSaveSnapshot = (this.operationHistory.length - this.lastSnapshotIndex) >= this.snapshotInterval;
                    
                    if (shouldSaveSnapshot) {
                        // 保存完整快照
                        operation.beforeState = this._captureState(false);
                        operation.afterState = this._captureState(false);
                        this.lastSnapshotIndex = this.operationHistory.length;
                        log.debug(LOG_MODULES.HISTORY, '保存完整快照', { 
                            index: this.lastSnapshotIndex 
                        });
                    } else {
                        // 使用增量记录
                        operation.beforeState = this._captureState(true, previousState);
                        operation.afterState = this._captureState(true, operation.beforeState);
                        log.debug(LOG_MODULES.HISTORY, '使用增量记录', { 
                            type: operation.type 
                        });
                    }
                } else {
                    // 不使用增量记录，使用完整快照
                    operation.beforeState = this._captureState(false);
                    operation.afterState = this._captureState(false);
                }
                
                // 不能合并，添加新操作
                this.operationHistory.push(operation);
                this.historyIndex = this.operationHistory.length - 1;
                
                // 限制历史大小
                if (this.operationHistory.length > this.maxHistorySize) {
                    this.operationHistory.shift();
                    this.historyIndex--;
                    this.lastSnapshotIndex--;
                    
                    // 如果删除了快照，需要重新计算快照位置
                    if (this.lastSnapshotIndex < 0) {
                        this._rebuildSnapshots();
                    }
                }
            }
            
            /**
             * 重建快照（当历史记录被截断时）
             * @private
             */
            _rebuildSnapshots() {
                // 找到第一个完整快照
                let firstSnapshotIndex = -1;
                for (let i = 0; i < this.operationHistory.length; i++) {
                    const op = this.operationHistory[i];
                    if (op.beforeState && op.beforeState.type === 'full-snapshot') {
                        firstSnapshotIndex = i;
                        break;
                    }
                }
                
                // 如果找到了快照，从那里开始重新计算
                if (firstSnapshotIndex >= 0) {
                    this.lastSnapshotIndex = firstSnapshotIndex;
                } else {
                    // 如果没有快照，将第一个操作设为快照
                    if (this.operationHistory.length > 0) {
                        const firstOp = this.operationHistory[0];
                        firstOp.beforeState = this._captureState(false);
                        firstOp.afterState = this._captureState(false);
                        this.lastSnapshotIndex = 0;
                    }
                }
            }

            /**
             * 撤销上一个操作（支持增量记录）
             * @returns {boolean} 是否成功撤销
             */
            undo() {
                if (this.historyIndex < 0) {
                    return false; // 没有可撤销的操作
                }
                
                const operation = this.operationHistory[this.historyIndex];
                
                // 恢复之前的状态（支持增量记录）
                const restoredState = this._restoreState(operation.beforeState);
                this.editor.innerHTML = restoredState.html;
                
                // 恢复光标位置
                if (restoredState.cursorPosition) {
                    requestAnimationFrame(() => {
                        window.MiNoteWebEditor._restoreCursorPosition(restoredState.cursorPosition);
                    });
                }
                
                this.historyIndex--;
                
                // 同步状态
                requestAnimationFrame(() => {
                    if (!isComposing && !isLoadingContent) {
                        normalizeCursorPosition();
                        syncFormatState();
                        notifyContentChanged();
                    }
                });
                
                return true;
            }

            /**
             * 重做上一个操作（支持增量记录）
             * @returns {boolean} 是否成功重做
             */
            redo() {
                if (this.historyIndex >= this.operationHistory.length - 1) {
                    return false; // 没有可重做的操作
                }
                
                this.historyIndex++;
                const operation = this.operationHistory[this.historyIndex];
                
                // 恢复之后的状态（支持增量记录）
                const restoredState = this._restoreState(operation.afterState);
                this.editor.innerHTML = restoredState.html;
                
                // 恢复光标位置
                if (restoredState.cursorPosition) {
                    requestAnimationFrame(() => {
                        window.MiNoteWebEditor._restoreCursorPosition(restoredState.cursorPosition);
                    });
                }
                
                // 同步状态
                requestAnimationFrame(() => {
                    if (!isComposing && !isLoadingContent) {
                        normalizeCursorPosition();
                        syncFormatState();
                        notifyContentChanged();
                    }
                });
                
                return true;
            }

            /**
             * 清空操作历史
             */
            clearHistory() {
                this.operationHistory = [];
                this.historyIndex = -1;
            }

            /**
             * 检查是否可以撤销
             * @returns {boolean}
             */
            canUndo() {
                return this.historyIndex >= 0;
            }

            /**
             * 检查是否可以重做
             * @returns {boolean}
             */
            canRedo() {
                return this.historyIndex < this.operationHistory.length - 1;
            }

            /**
             * 插入节点
             * @param {Node} node - 要插入的节点
             * @param {Node} referenceNode - 参考节点
             * @param {boolean} before - 是否插入到参考节点之前（默认 false，插入之后）
             */
            insertNode(node, referenceNode, before = false) {
                this.execute(() => {
                    const parent = referenceNode.parentNode;
                    if (!parent) {
                        log.warn(LOG_MODULES.DOM_WRITER, '参考节点没有父节点，无法插入');
                        return;
                    }
                    
                    if (before) {
                        parent.insertBefore(node, referenceNode);
                    } else {
                        if (referenceNode.nextSibling) {
                            parent.insertBefore(node, referenceNode.nextSibling);
                        } else {
                            parent.appendChild(node);
                        }
                    }
                });
            }

            /**
             * 移除节点
             * @param {Node} node - 要移除的节点
             */
            removeNode(node) {
                this.execute(() => {
                    if (node.parentNode) {
                        node.parentNode.removeChild(node);
                    }
                });
            }

            /**
             * 替换节点
             * @param {Node} oldNode - 旧节点
             * @param {Node} newNode - 新节点
             */
            replaceNode(oldNode, newNode) {
                this.execute(() => {
                    if (oldNode.parentNode) {
                        oldNode.parentNode.replaceChild(newNode, oldNode);
                    }
                });
            }

            /**
             * 设置元素属性
             * @param {Element} element - 元素
             * @param {string} name - 属性名
             * @param {string} value - 属性值
             */
            setAttribute(element, name, value) {
                this.execute(() => {
                    element.setAttribute(name, value);
                }, false); // 属性变化不需要立即同步状态
            }

            /**
             * 移除元素属性
             * @param {Element} element - 元素
             * @param {string} name - 属性名
             */
            removeAttribute(element, name) {
                this.execute(() => {
                    element.removeAttribute(name);
                }, false);
            }

            /**
             * 设置元素类名
             * @param {Element} element - 元素
             * @param {string} className - 类名
             * @param {boolean} add - true 添加，false 移除
             */
            setClass(element, className, add) {
                this.execute(() => {
                    if (add) {
                        element.classList.add(className);
                    } else {
                        element.classList.remove(className);
                    }
                });
            }

            /**
             * 设置元素样式
             * @param {Element} element - 元素
             * @param {string} property - 样式属性
             * @param {string} value - 样式值
             */
            setStyle(element, property, value) {
                this.execute(() => {
                    element.style[property] = value;
                }, false);
            }

            /**
             * 设置元素内容
             * @param {Element} element - 元素
             * @param {string} content - 内容（HTML 字符串）
             */
            setContent(element, content) {
                this.execute(() => {
                    element.innerHTML = content;
                });
            }

            /**
             * 增量更新 DOM（只更新变化的部分）
             * 参考 CKEditor 5 的增量更新机制
             * @param {string} newHtml - 新的 HTML 内容
             * @param {string} oldHtml - 旧的 HTML 内容（可选，如果不提供则使用当前内容）
             * @returns {boolean} 是否成功更新
             */
            incrementalUpdate(newHtml, oldHtml = null) {
                if (!oldHtml) {
                    oldHtml = this.editor.innerHTML;
                }

                // 如果内容完全相同，不需要更新
                if (oldHtml === newHtml) {
                    return false;
                }

                // 简单的增量更新策略：
                // 1. 如果内容差异很大（超过 50%），完全重新加载
                // 2. 否则，尝试只更新变化的部分

                const oldLength = oldHtml.length;
                const newLength = newHtml.length;
                const lengthDiff = Math.abs(newLength - oldLength) / Math.max(oldLength, newLength, 1);

                // 如果差异超过 50%，完全重新加载
                if (lengthDiff > 0.5) {
                    this.execute(() => {
                        this.editor.innerHTML = newHtml;
                    }, true, null); // 不记录历史（因为是外部加载）
                    return true;
                }

                // 尝试增量更新：比较新旧内容的差异
                // 简化策略：如果内容结构相似，尝试保留光标位置附近的节点
                try {
                    // 创建临时容器来解析新 HTML
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = newHtml;

                    // 比较子节点数量
                    const oldChildren = Array.from(this.editor.children);
                    const newChildren = Array.from(tempDiv.children);

                    // 如果子节点数量相同，尝试逐个更新
                    if (oldChildren.length === newChildren.length) {
                        let hasChanges = false;
                        this.beginBatch();

                        for (let i = 0; i < oldChildren.length; i++) {
                            const oldChild = oldChildren[i];
                            const newChild = newChildren[i];

                            // 比较节点的 outerHTML
                            if (oldChild.outerHTML !== newChild.outerHTML) {
                                // 节点不同，替换它
                                this.replaceNode(oldChild, newChild.cloneNode(true));
                                hasChanges = true;
                            }
                        }

                        this.endBatch(null); // 不记录历史

                        if (hasChanges) {
                            return true;
                        }
                    }

                    // 如果增量更新失败，回退到完全重新加载
                    this.execute(() => {
                        this.editor.innerHTML = newHtml;
                    }, true, null); // 不记录历史
                    return true;
                } catch (e) {
                    log.warn(LOG_MODULES.DOM_WRITER, '增量更新失败，回退到完全重新加载', { error: e.message });
                    // 回退到完全重新加载
                    this.execute(() => {
                        this.editor.innerHTML = newHtml;
                    }, true, null); // 不记录历史
                    return true;
                }
            }

            /**
             * 设置光标位置
             * @param {Node} node - 节点
             * @param {number} offset - 偏移量
             */
            setSelection(node, offset) {
                this.execute(() => {
                    const selection = window.getSelection();
                    const range = document.createRange();
                    range.setStart(node, offset);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }, false); // 设置光标不需要同步状态
            }
        }

        // 全局 DOM Writer 实例
        let domWriter = null;

        /**
         * 从元素获取缩进级别
         * @param {HTMLElement} element - 元素
         * @returns {string} 缩进级别
         */
        function getIndentFromElement(element) {
            if (!element) return '1';
            
            // 先检查类名中的 indent-X
            const classMatch = element.className.match(/indent-(\d+)/);
            if (classMatch) {
                return classMatch[1];
            }
            
            // 再检查 style 中的 padding-left
            const style = element.getAttribute('style') || '';
            const match = style.match(/padding-left:\s*(\d+)px/);
            if (match) {
                const paddingLeft = parseInt(match[1], 10);
                const indent = Math.floor(paddingLeft / 20) + 1;
                return indent.toString();
            }
            return '1';
        }
        
        /**
         * 设置元素的缩进级别
         * @param {HTMLElement} element - 元素
         * @param {number} indent - 缩进级别（1-5）
         */
        function setIndentForElement(element, indent) {
            if (!element) return;
            
            // 限制缩进级别在 1-5 之间
            indent = Math.max(1, Math.min(5, indent));
            
            if (element.classList.contains('mi-note-text')) {
                // 文本元素：使用类名
                // 移除所有 indent-X 类
                element.className = element.className.replace(/\s*indent-\d+/g, '');
                // 添加新的 indent 类
                if (indent > 1) {
                    element.classList.add(`indent-${indent}`);
                }
            } else if (element.classList.contains('mi-note-bullet') || 
                       element.classList.contains('mi-note-order') || 
                       element.classList.contains('mi-note-checkbox')) {
                // 列表和待办项：使用 padding-left
                const paddingLeft = (indent - 1) * 20;
                const currentStyle = element.getAttribute('style') || '';
                // 移除现有的 padding-left
                const newStyle = currentStyle.replace(/padding-left:\s*\d+px;?/g, '').trim();
                // 添加新的 padding-left
                element.setAttribute('style', newStyle + (newStyle ? ' ' : '') + `padding-left: ${paddingLeft}px;`);
            }
        }

        // ==================== window.MiNoteWebEditor 接口 ====================
        window.MiNoteWebEditor = {
            /**
             * 保存当前光标位置（参考 CKEditor 5 的光标管理）
             * 改进：使用文本内容作为锚点，更可靠
             * @returns {Object|null} 保存的光标位置信息
             */
            _saveCursorPosition: function() {
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return null;
                }

                const range = selection.getRangeAt(0);
                const editor = document.getElementById('editor-content');
                if (!editor || !editor.contains(range.commonAncestorContainer)) {
                    return null;
                }

                try {
                    // 方法1：保存文本锚点（最可靠的方法，参考 CKEditor 5 的文本位置标记）
                    // 在光标前后保存一些文本内容作为锚点，用于恢复时定位
                    const startNode = range.startContainer;
                    const endNode = range.endContainer;
                    
                    // 获取光标前后的文本内容作为锚点
                    let startAnchorText = '';
                    let endAnchorText = '';
                    let startAnchorOffset = 0;
                    let endAnchorOffset = 0;
                    
                    if (startNode.nodeType === Node.TEXT_NODE) {
                        const text = startNode.textContent || '';
                        const offset = range.startOffset;
                        // 保存光标前 20 个字符和后 20 个字符作为锚点
                        const beforeText = text.substring(Math.max(0, offset - 20), offset);
                        const afterText = text.substring(offset, Math.min(text.length, offset + 20));
                        startAnchorText = beforeText + '|' + afterText; // 使用 | 标记光标位置
                        startAnchorOffset = beforeText.length;
                    } else {
                        // 如果不是文本节点，尝试获取父文本节点
                        const textNode = this._findTextNode(startNode, range.startOffset);
                        if (textNode) {
                            const text = textNode.textContent || '';
                            const offset = textNode === startNode ? range.startOffset : 0;
                            const beforeText = text.substring(Math.max(0, offset - 20), offset);
                            const afterText = text.substring(offset, Math.min(text.length, offset + 20));
                            startAnchorText = beforeText + '|' + afterText;
                            startAnchorOffset = beforeText.length;
                        }
                    }
                    
                    if (endNode.nodeType === Node.TEXT_NODE) {
                        const text = endNode.textContent || '';
                        const offset = range.endOffset;
                        const beforeText = text.substring(Math.max(0, offset - 20), offset);
                        const afterText = text.substring(offset, Math.min(text.length, offset + 20));
                        endAnchorText = beforeText + '|' + afterText;
                        endAnchorOffset = beforeText.length;
                    } else {
                        const textNode = this._findTextNode(endNode, range.endOffset);
                        if (textNode) {
                            const text = textNode.textContent || '';
                            const offset = textNode === endNode ? range.endOffset : 0;
                            const beforeText = text.substring(Math.max(0, offset - 20), offset);
                            const afterText = text.substring(offset, Math.min(text.length, offset + 20));
                            endAnchorText = beforeText + '|' + afterText;
                            endAnchorOffset = beforeText.length;
                        }
                    }

                    // 方法2：保存路径信息（作为备用）
                    const startPath = this._getNodePath(range.startContainer, editor);
                    const endPath = this._getNodePath(range.endContainer, editor);
                    
                    return {
                        // 文本锚点（主要方法）
                        startAnchorText: startAnchorText,
                        startAnchorOffset: startAnchorOffset,
                        endAnchorText: endAnchorText,
                        endAnchorOffset: endAnchorOffset,
                        // 路径信息（备用方法）
                        startPath: startPath,
                        startOffset: range.startOffset,
                        endPath: endPath,
                        endOffset: range.endOffset,
                        collapsed: range.collapsed,
                        // 原始节点引用（如果 DOM 没变可以直接使用）
                        startContainer: range.startContainer,
                        endContainer: range.endContainer
                    };
                } catch (e) {
                    log.warn(LOG_MODULES.CURSOR, '保存光标位置失败', { error: e.message });
                    return null;
                }
            },

            /**
             * 查找文本节点（用于光标位置保存）
             * @param {Node} node - 起始节点
             * @param {number} offset - 偏移量
             * @returns {Node|null} 文本节点
             */
            _findTextNode: function(node, offset) {
                if (node.nodeType === Node.TEXT_NODE) {
                    return node;
                }
                
                // 如果是元素节点，根据偏移量查找子节点
                if (node.nodeType === Node.ELEMENT_NODE && node.childNodes.length > 0) {
                    if (offset < node.childNodes.length) {
                        const child = node.childNodes[offset];
                        if (child.nodeType === Node.TEXT_NODE) {
                            return child;
                        }
                        // 递归查找
                        return this._findTextNode(child, 0);
                    }
                }
                
                return null;
            },

            /**
             * 获取节点在编辑器中的路径（用于恢复光标位置）
             * 参考 CKEditor 5 的路径保存机制
             * @param {Node} node - 节点
             * @param {HTMLElement} root - 根元素
             * @returns {Array|null} 节点路径
             */
            _getNodePath: function(node, root) {
                const path = [];
                let current = node;

                while (current && current !== root && current !== document.body) {
                    // 计算当前节点在父节点中的索引
                    let index = 0;
                    let sibling = current;
                    while (sibling.previousSibling) {
                        sibling = sibling.previousSibling;
                        index++;
                    }
                    path.unshift(index);
                    current = current.parentNode;
                }

                return path.length > 0 ? path : null;
            },

            /**
             * 恢复光标位置（参考 CKEditor 5 的光标管理）
             * @param {Object} savedPosition - 保存的光标位置信息
             */
            _restoreCursorPosition: function(savedPosition) {
                if (!savedPosition) {
                    return;
                }

                const selection = window.getSelection();
                const editor = document.getElementById('editor-content');
                if (!editor || !selection) {
                    return;
                }

                try {
                    // 方法1：使用文本锚点恢复（最可靠，即使 DOM 结构变化也能恢复）
                    if (savedPosition.startAnchorText) {
                        const anchorText = savedPosition.startAnchorText;
                        const parts = anchorText.split('|');
                        if (parts.length === 2) {
                            const beforeText = parts[0];
                            const afterText = parts[1];
                            
                            // 在整个编辑器中搜索匹配的文本
                            const editorText = editor.textContent || editor.innerText || '';
                            const searchText = beforeText + afterText;
                            const index = editorText.indexOf(searchText);
                            
                            if (index !== -1) {
                                // 找到匹配的文本，计算光标位置
                                const targetOffset = index + beforeText.length;
                                
                                // 找到对应的文本节点和偏移量
                                const walker = document.createTreeWalker(
                                    editor,
                                    NodeFilter.SHOW_TEXT,
                                    null
                                );
                                
                                let currentOffset = 0;
                                let targetNode = null;
                                let targetNodeOffset = 0;
                                
                                let node = walker.nextNode();
                                while (node) {
                                    const nodeLength = node.textContent.length;
                                    if (currentOffset + nodeLength >= targetOffset) {
                                        targetNode = node;
                                        targetNodeOffset = targetOffset - currentOffset;
                                        break;
                                    }
                                    currentOffset += nodeLength;
                                    node = walker.nextNode();
                                }
                                
                                if (targetNode) {
                                    const range = document.createRange();
                                    range.setStart(targetNode, Math.min(targetNodeOffset, targetNode.textContent.length));
                                    range.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(range);
                                    return;
                                }
                            }
                        }
                    }

                    // 方法2：使用路径恢复（如果 DOM 结构没变）
                    if (savedPosition.startPath && savedPosition.endPath) {
                        const startNode = this._getNodeByPath(savedPosition.startPath, editor);
                        const endNode = this._getNodeByPath(savedPosition.endPath, editor);

                        if (startNode && endNode) {
                            try {
                                const range = document.createRange();
                                const startOffset = Math.min(savedPosition.startOffset || 0, 
                                    startNode.nodeType === Node.TEXT_NODE ? startNode.textContent.length : 0);
                                const endOffset = Math.min(savedPosition.endOffset || 0,
                                    endNode.nodeType === Node.TEXT_NODE ? endNode.textContent.length : 0);
                                
                                range.setStart(startNode, startOffset);
                                range.setEnd(endNode, endOffset);
                                
                                selection.removeAllRanges();
                                selection.addRange(range);
                                return;
                            } catch (e) {
                                // 路径恢复失败，继续尝试其他方法
                            }
                        }
                    }

                    // 方法3：使用保存的容器恢复（如果 DOM 结构完全没变）
                    if (savedPosition.startContainer && savedPosition.endContainer) {
                        try {
                            const range = document.createRange();
                            const startOffset = Math.min(savedPosition.startOffset || 0,
                                savedPosition.startContainer.nodeType === Node.TEXT_NODE 
                                    ? savedPosition.startContainer.textContent.length : 0);
                            const endOffset = Math.min(savedPosition.endOffset || 0,
                                savedPosition.endContainer.nodeType === Node.TEXT_NODE 
                                    ? savedPosition.endContainer.textContent.length : 0);
                            
                            range.setStart(savedPosition.startContainer, startOffset);
                            range.setEnd(savedPosition.endContainer, endOffset);
                            
                            selection.removeAllRanges();
                            selection.addRange(range);
                            return;
                        } catch (e) {
                            // 节点已不存在，继续尝试其他方法
                        }
                    }

                    // 方法4：回退到文档末尾（避免光标跳到开头）
                    const walker = document.createTreeWalker(
                        editor,
                        NodeFilter.SHOW_TEXT,
                        null
                    );
                    let lastTextNode = null;
                    let textNode = walker.nextNode();
                    while (textNode) {
                        lastTextNode = textNode;
                        textNode = walker.nextNode();
                    }
                    if (lastTextNode) {
                        const range = document.createRange();
                        const offset = Math.min(savedPosition.startOffset || 0, lastTextNode.textContent.length);
                        range.setStart(lastTextNode, offset);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                } catch (e) {
                    log.warn(LOG_MODULES.CURSOR, '恢复光标位置失败', { error: e.message });
                    // 最后的回退：将光标放到文档末尾
                    try {
                        const range = document.createRange();
                        range.selectNodeContents(editor);
                        range.collapse(false);
                        selection.removeAllRanges();
                        selection.addRange(range);
                    } catch (e2) {
                        log.error(LOG_MODULES.CURSOR, '回退光标位置也失败', { error: e2.message });
                    }
                }
            },

            /**
             * 根据路径获取节点（参考 CKEditor 5 的路径恢复机制）
             * @param {Array} path - 节点路径
             * @param {HTMLElement} root - 根元素
             * @returns {Node|null} 节点
             */
            _getNodeByPath: function(path, root) {
                let current = root;
                
                for (let i = 0; i < path.length; i++) {
                    const index = path[i];
                    
                    if (!current || !current.childNodes || index >= current.childNodes.length) {
                        return null;
                    }
                    
                    current = current.childNodes[index];
                }
                
                return current;
            },

            /**
             * 加载 XML 内容到编辑器
             * @param {string} xmlContent - 小米笔记 XML 格式内容
             * @returns {string} 状态信息
             */
            loadContent: function(xmlContent) {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    log.error(LOG_MODULES.EDITOR, '无法找到编辑器元素');
                    return '编辑器元素不存在';
                }

                // 如果正在组合输入，延迟加载（避免打断输入）
                if (isComposing) {
                    log.debug(LOG_MODULES.EDITOR, '正在组合输入，延迟加载');
                    // 延迟到组合输入结束后再加载
                    setTimeout(() => {
                        if (!isComposing) {
                            this.loadContent(xmlContent);
                        }
                    }, 100);
                    return '延迟加载（组合输入中）';
                }

                log.debug(LOG_MODULES.EDITOR, '开始加载内容', { xmlLength: xmlContent ? xmlContent.length : 0 });

                // 如果内容没有实际变化，不需要重新加载（避免光标位置丢失）
                if (currentContent === xmlContent) {
                    log.debug(LOG_MODULES.EDITOR, '内容未变化，跳过加载');
                    return '内容未变化';
                }

                // 检查当前编辑器内容是否与要加载的内容相同（避免不必要的重新加载）
                // 改进：更严格的内容比较，避免误判
                const currentHtml = editor.innerHTML;
                // 排除占位符
                if (currentHtml && !currentHtml.includes('开始输入...') && !currentHtml.includes('placeholder')) {
                    try {
                        // 先比较 XML 内容（更快）
                        if (currentContent === xmlContent) {
                            log.debug(LOG_MODULES.EDITOR, 'XML 内容相同，跳过加载');
                            // 清除待恢复的光标位置（因为不需要重新加载）
                            window._pendingCursorPosition = null;
                            window._hasPendingCursorPosition = false;
                            return '内容已是最新';
                        }
                        
                        // 如果 XML 不同，再比较转换后的 HTML（更准确但更慢）
                        // 注意：在比较前，先保存当前光标位置，因为转换可能会影响 DOM
                        const savedPositionBeforeCompare = window.MiNoteWebEditor._saveCursorPosition();
                        const currentXml = htmlToXmlConverter.convert(currentHtml);
                        
                        // 规范化比较：去除末尾的空行差异（可能是转换导致的微小差异）
                        const normalizedCurrentXml = currentXml.replace(/\n+$/, '');
                        const normalizedXmlContent = xmlContent.replace(/\n+$/, '');
                        
                        if (normalizedCurrentXml === normalizedXmlContent) {
                            log.debug(LOG_MODULES.EDITOR, '编辑器内容与要加载的内容相同（规范化比较），跳过加载');
                            currentContent = xmlContent; // 更新 currentContent，但不重新加载
                            // 清除待恢复的光标位置（因为不需要重新加载）
                            window._pendingCursorPosition = null;
                            window._hasPendingCursorPosition = false;
                            
                            // 如果之前保存了光标位置，恢复它（因为转换可能影响了 DOM）
                            if (savedPositionBeforeCompare) {
                                requestAnimationFrame(() => {
                                    window.MiNoteWebEditor._restoreCursorPosition(savedPositionBeforeCompare);
                                });
                            }
                            
                            return '内容已是最新';
                        }
                    } catch (e) {
                        // 转换失败，继续加载
                        log.warn(LOG_MODULES.CONVERTER, '检查内容是否相同时转换失败', { error: e.message });
                    }
                }

                // 保存当前光标位置（在重新加载前）
                // 优先使用全局保存的位置（来自 notifyContentChanged），如果没有则保存当前位置
                const savedPosition = window._pendingCursorPosition || this._saveCursorPosition();
                // 清除全局保存的位置，避免重复使用
                window._pendingCursorPosition = null;

                // 设置加载标志
                isLoadingContent = true;
                currentContent = xmlContent;
                
                // 清空操作历史（因为这是外部加载，不是用户操作）
                if (domWriter) {
                    domWriter.clearHistory();
                }

                // 如果内容为空，显示占位符
                if (!xmlContent || xmlContent.trim() === '') {
                    editor.innerHTML = '<div class="placeholder">开始输入...</div>';
                    isLoadingContent = false;
                    isInitialized = true;
                    return '内容已加载（空内容）';
                }

                // 转换为 HTML
                try {
                    // 错误边界检查：确保转换器已初始化
                    if (!xmlToHtmlConverter) {
                        throw new Error('XML 到 HTML 转换器未初始化');
                    }
                    
                    const html = xmlToHtmlConverter.convert(xmlContent);
                    
                    // 错误边界检查：验证转换结果
                    if (typeof html !== 'string') {
                        throw new Error('转换结果不是字符串类型');
                    }
                    
                    if (!html || html.trim() === '') {
                        editor.innerHTML = '<div class="placeholder">开始输入...</div>';
                    } else {
                        // 尝试增量更新（减少 DOM 重新加载）
                        const currentHtml = editor.innerHTML;
                        try {
                            if (domWriter && currentHtml && !currentHtml.includes('开始输入...') && !currentHtml.includes('placeholder')) {
                                // 使用增量更新
                                const updated = domWriter.incrementalUpdate(html, currentHtml);
                                if (updated) {
                                    log.debug(LOG_MODULES.DOM_WRITER, '使用增量更新', { htmlLength: html.length });
                                } else {
                                    log.debug(LOG_MODULES.DOM_WRITER, '内容未变化（增量更新检查）', { htmlLength: html.length });
                                }
                            } else {
                                // 完全重新加载
                                editor.innerHTML = html;
                                log.debug(LOG_MODULES.EDITOR, '完全重新加载', { htmlLength: html.length });
                            }
                        } catch (updateError) {
                            // 增量更新失败，回退到完全重新加载
                            log.warn(LOG_MODULES.DOM_WRITER, '增量更新失败，回退到完全重新加载', { error: updateError.message });
                            try {
                                editor.innerHTML = html;
                                log.debug(LOG_MODULES.EDITOR, '回退：完全重新加载', { htmlLength: html.length });
                            } catch (fallbackError) {
                                // 如果完全重新加载也失败，显示错误信息
                                log.error(LOG_MODULES.EDITOR, '完全重新加载也失败', { error: fallbackError.message });
                                editor.innerHTML = '<div class="placeholder">内容加载失败，请重试</div>';
                                isLoadingContent = false;
                                return '内容加载失败: ' + fallbackError.message;
                            }
                        }
                    }
                    isInitialized = true;
                    
                    // 恢复光标位置（在 DOM 更新后）
                    // 改进：使用双重 requestAnimationFrame 确保 DOM 完全渲染
                    if (savedPosition) {
                        try {
                            // 第一帧：等待 DOM 更新完成
                            requestAnimationFrame(() => {
                                try {
                                    // 第二帧：确保浏览器完成渲染后再恢复光标
                                    requestAnimationFrame(() => {
                                        try {
                                            this._restoreCursorPosition(savedPosition);
                                            // 恢复后清除标志
                                            window._hasPendingCursorPosition = false;
                                        } catch (restoreError) {
                                            log.warn(LOG_MODULES.CURSOR, '恢复光标位置失败', { error: restoreError.message });
                                            // 最后的回退：将光标放到文档末尾
                                            try {
                                                const selection = window.getSelection();
                                                const range = document.createRange();
                                                range.selectNodeContents(editor);
                                                range.collapse(false);
                                                selection.removeAllRanges();
                                                selection.addRange(range);
                                            } catch (finalError) {
                                                log.error(LOG_MODULES.CURSOR, '回退光标位置也失败', { error: finalError.message });
                                            }
                                        }
                                    });
                                } catch (frameError) {
                                    log.error(LOG_MODULES.CURSOR, 'requestAnimationFrame 失败', { error: frameError.message });
                                }
                            });
                        } catch (scheduleError) {
                            log.error(LOG_MODULES.CURSOR, '调度光标恢复失败', { error: scheduleError.message });
                        }
                    } else {
                        // 如果没有待恢复的位置，清除标志
                        window._hasPendingCursorPosition = false;
                    }
                } catch (error) {
                    log.error(LOG_MODULES.CONVERTER, '转换失败', { 
                        error: error.message, 
                        stack: error.stack 
                    });
                    
                    // 错误恢复：尝试显示原始内容或错误提示
                    try {
                        // 如果可能，尝试保留当前内容
                        const currentHtml = editor.innerHTML;
                        if (currentHtml && !currentHtml.includes('开始输入...') && !currentHtml.includes('placeholder')) {
                            log.info(LOG_MODULES.EDITOR, '转换失败，保留当前内容');
                            // 保留当前内容，但标记为未初始化
                            isInitialized = false;
                        } else {
                            editor.innerHTML = '<div class="placeholder">内容加载失败，请重试</div>';
                        }
                    } catch (recoveryError) {
                        log.error(LOG_MODULES.EDITOR, '错误恢复也失败', { error: recoveryError.message });
                        editor.innerHTML = '<div class="placeholder">内容加载失败，请重试</div>';
                    }
                } finally {
                    isLoadingContent = false;
                }

                return '内容已加载';
            },

            /**
             * 获取当前编辑器的内容并转换为 XML
             * @returns {string} 小米笔记 XML 格式内容
             */
            getContent: function() {
                try {
                    const editor = document.getElementById('editor-content');
                    if (!editor) {
                        log.error(LOG_MODULES.EDITOR, '无法找到编辑器元素');
                        return '';
                    }

                    const htmlContent = editor.innerHTML;
                    
                    // 检查是否是占位符或空内容
                    if (!htmlContent || 
                        htmlContent.trim() === '' || 
                        htmlContent.includes('开始输入...') ||
                        htmlContent.trim() === '<div class="placeholder">开始输入...</div>') {
                        return '';
                    }

                    // 错误边界检查：确保转换器已初始化
                    if (!htmlToXmlConverter) {
                        log.error(LOG_MODULES.CONVERTER, 'HTML 到 XML 转换器未初始化');
                        return '';
                    }

                    try {
                        const xmlContent = htmlToXmlConverter.convert(htmlContent);
                        
                        // 错误边界检查：验证转换结果
                        if (typeof xmlContent !== 'string') {
                            log.error(LOG_MODULES.CONVERTER, '转换结果不是字符串类型');
                            return '';
                        }
                        
                        log.debug(LOG_MODULES.CONVERTER, '转换完成', { xmlLength: xmlContent.length });
                        return xmlContent;
                    } catch (error) {
                        log.error(LOG_MODULES.CONVERTER, '转换失败', { 
                            error: error.message, 
                            stack: error.stack 
                        });
                        
                        // 错误恢复：尝试返回一个基本的 XML 结构
                        try {
                            // 如果转换失败，尝试提取纯文本并返回基本的 XML
                            const textContent = editor.textContent || editor.innerText || '';
                            if (textContent.trim()) {
                                log.warn(LOG_MODULES.CONVERTER, '转换失败，返回纯文本 XML');
                                return `<text>${textContent.trim()}</text>`;
                            }
                        } catch (recoveryError) {
                            log.error(LOG_MODULES.CONVERTER, '错误恢复也失败', { error: recoveryError.message });
                        }
                        
                        return '';
                    }
                } catch (error) {
                    // 最外层错误处理：捕获所有未预期的错误
                    log.error(LOG_MODULES.EDITOR, '未预期的错误', { 
                        error: error.message, 
                        stack: error.stack 
                    });
                    return '';
                }
            },

            /**
             * 强制立即保存当前内容
             * @returns {string} 状态信息
             */
            forceSaveContent: function() {
                log.debug(LOG_MODULES.EDITOR, '强制保存当前内容');
                notifyContentChanged();
                return '内容已强制保存';
            },

            /**
             * 撤销上一个操作
             * @returns {string} 状态信息
             */
            undo: function() {
                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }
                
                if (domWriter.undo()) {
                    return '已撤销';
                } else {
                    return '没有可撤销的操作';
                }
            },

            /**
             * 重做上一个操作
             * @returns {string} 状态信息
             */
            redo: function() {
                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }
                
                if (domWriter.redo()) {
                    return '已重做';
                } else {
                    return '没有可重做的操作';
                }
            },

            /**
             * 检查是否可以撤销
             * @returns {boolean}
             */
            canUndo: function() {
                return domWriter ? domWriter.canUndo() : false;
            },

            /**
             * 检查是否可以重做
             * @returns {boolean}
             */
            canRedo: function() {
                return domWriter ? domWriter.canRedo() : false;
            },
            
            /**
             * 设置颜色方案（深色/浅色模式）
             * @param {string} scheme - 'light' 或 'dark'
             * @returns {string} 状态信息
             */
            setColorScheme: function(scheme) {
                log.debug(LOG_MODULES.EDITOR, '设置颜色方案', { scheme });
                
                const root = document.documentElement;
                const body = document.body;
                
                if (scheme === 'dark') {
                    root.setAttribute('data-color-scheme', 'dark');
                    if (body) {
                        body.setAttribute('data-color-scheme', 'dark');
                    }
                    log.debug(LOG_MODULES.EDITOR, '已设置为深色模式');
                } else {
                    root.setAttribute('data-color-scheme', 'light');
                    if (body) {
                        body.setAttribute('data-color-scheme', 'light');
                    }
                    log.debug(LOG_MODULES.EDITOR, '已设置为浅色模式');
                }
                
                return '颜色方案已设置为: ' + scheme;
            },
            
            /**
             * 执行格式操作
             * @param {string} action - 操作类型
             * @param {string} value - 操作值（可选）
             * @returns {string} 状态信息
             */
            executeFormatAction: function(action, value) {
                log.debug(LOG_MODULES.FORMAT, '执行格式操作', { action, value });
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    log.error(LOG_MODULES.FORMAT, '无法找到编辑器元素');
                    return '编辑器元素不存在';
                }

                // 确保编辑器有焦点
                editor.focus();

                try {
                    switch (action) {
                        case 'bold':
                            return this.applyFormat('bold');
                        case 'italic':
                            return this.applyFormat('italic');
                        case 'underline':
                            return this.applyFormat('underline');
                        case 'strikethrough':
                            return this.applyFormat('strikethrough');
                        case 'highlight':
                            return this.applyFormat('highlight');
                        case 'heading':
                            return this.applyHeading(value ? parseInt(value, 10) : 0);
                        case 'textAlignment':
                            return this.applyAlignment(value || 'left');
                        case 'bulletList':
                            return this.insertBulletList();
                        case 'orderList':
                            return this.insertOrderList();
                        case 'quote':
                            return this.insertQuote();
                        case 'checkbox':
                            return this.insertCheckbox();
                        case 'horizontalRule':
                            return this.insertHorizontalRule();
                        case 'indent':
                            if (value === 'increase') {
                                return this.increaseIndent();
                            } else if (value === 'decrease') {
                                return this.decreaseIndent();
                            }
                            return '无效的缩进操作';
                        default:
                            log.warn(LOG_MODULES.FORMAT, '未实现的操作', { action });
                            return '操作暂未实现: ' + action;
                    }
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '执行失败', { 
                        action, 
                        value, 
                        error: error.message, 
                        stack: error.stack 
                    });
                    return '操作执行失败: ' + error.message;
                }
            },

            /**
             * 应用文本格式（加粗、斜体、下划线、删除线、高亮）
             * @param {string} format - 格式类型
             * @returns {string} 状态信息
             */
            applyFormat: function(format) {
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return '请先选中文本';
                }

                const range = selection.getRangeAt(0);
                
                try {
                    // 检查当前格式状态
                    const isCurrentlyFormatted = this._checkFormatStateInternal(range, format);
                    
                    let tagName = '';
                    let className = '';
                    
                    switch (format) {
                        case 'bold':
                            tagName = 'b';
                            break;
                        case 'italic':
                            tagName = 'i';
                            break;
                        case 'underline':
                            tagName = 'u';
                            break;
                        case 'strikethrough':
                            tagName = 's';
                            break;
                        case 'highlight':
                            className = 'mi-note-highlight';
                            break;
                    }

                    if (range.collapsed) {
                        // 光标位置：切换格式（参考 CKEditor 5 的 AttributeCommand.execute）
                        // CKEditor 5 对于折叠选择使用 writer.setSelectionAttribute/writer.removeSelectionAttribute
                        // 我们使用 execCommand 来实现类似效果
                        if (isCurrentlyFormatted) {
                            // 当前已应用格式，需要清除（类似 writer.removeSelectionAttribute）
                            this.clearFormatAtCursor(range, format, tagName, className);
                        } else {
                            // 当前未应用格式，需要应用（类似 writer.setSelectionAttribute）
                            // 参考 CKEditor 5：对于折叠选择，直接设置选择属性，后续输入会自动继承
                            
                            if (tagName) {
                                // 对于下划线和删除线，需要特殊处理以确保它们可以共存
                                // execCommand 可能会清除其他 text-decoration 格式
                                if (format === 'underline' || format === 'strikethrough') {
                                    // 检查是否已经有另一种格式
                                    const otherFormat = format === 'underline' ? 'strikethrough' : 'underline';
                                    const hasOtherFormat = this._checkFormatStateInternal(range, otherFormat);
                                    
                                    if (hasOtherFormat) {
                                        // 如果已经有另一种格式，需要手动处理以确保两种格式共存
                                        // 找到包含另一种格式的元素
                                        let container = range.commonAncestorContainer;
                                        if (container.nodeType === Node.TEXT_NODE) {
                                            container = container.parentElement;
                                        }
                                        
                                        let otherFormatElement = null;
                                        let current = container;
                                        const otherTagName = format === 'underline' ? 's' : 'u';
                                        
                                        while (current && current !== document.body) {
                                            if (current.nodeType === Node.ELEMENT_NODE) {
                                                const tag = current.tagName ? current.tagName.toLowerCase() : '';
                                                if (tag === otherTagName || 
                                                    (otherTagName === 's' && (tag === 'strike' || tag === 'del'))) {
                                                    otherFormatElement = current;
                                                    break;
                                                }
                                            }
                                            current = current.parentElement || current.parentNode;
                                        }
                                        
                                        if (otherFormatElement) {
                                            // 在已有格式元素内创建新格式元素
                                            const newFormatElement = document.createElement(tagName);
                                            newFormatElement.innerHTML = '\u200B';
                                            
                                            // 在格式元素内插入
                                            if (otherFormatElement.firstChild) {
                                                otherFormatElement.insertBefore(newFormatElement, otherFormatElement.firstChild);
                                            } else {
                                                otherFormatElement.appendChild(newFormatElement);
                                            }
                                            
                                            // 移动光标到新格式元素内
                                            const newRange = document.createRange();
                                            newRange.setStart(newFormatElement.firstChild, 0);
                                            newRange.collapse(true);
                                            selection.removeAllRanges();
                                            selection.addRange(newRange);
                                        } else {
                                            // 没有其他格式，使用 execCommand（记录历史）
                                            if (domWriter) {
                                                domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                            } else {
                                                document.execCommand(format, false, null);
                                            }
                                        }
                                    } else {
                                        // 没有其他格式，使用 execCommand（记录历史）
                                        if (domWriter) {
                                            domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                        } else {
                                            document.execCommand(format, false, null);
                                        }
                                    }
                                } else {
                                    // 其他格式（bold, italic），直接使用 execCommand（记录历史）
                                    if (domWriter) {
                                        domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                    } else {
                                        document.execCommand(format, false, null);
                                    }
                                }
                            } else if (className) {
                                // 高亮：需要特殊处理（execCommand 不支持自定义类名）
                                // 创建高亮 span 等待输入
                                const highlightSpan = document.createElement('span');
                                highlightSpan.className = className;
                                highlightSpan.style.backgroundColor = 'rgba(154, 255, 232, 0.69)';
                                highlightSpan.innerHTML = '\u200B';
                                
                                // 确保在正确的位置插入
                                range.insertNode(highlightSpan);
                                
                                // 移动光标到 span 内
                                const newRange = document.createRange();
                                newRange.setStart(highlightSpan, 0);
                                newRange.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(newRange);
                            }
                        }
                    } else {
                        // 有选中文本：切换格式（参考 CKEditor 5 的 AttributeCommand.execute）
                        // CKEditor 5 对于非折叠选择使用 writer.setAttribute/writer.removeAttribute 在范围内操作
                        if (isCurrentlyFormatted) {
                            // 当前已应用格式，需要清除（类似 writer.removeAttribute）
                            this.removeFormatFromSelection(range, format, tagName, className);
                        } else {
                            // 当前未应用格式，需要应用（类似 writer.setAttribute）
                            if (tagName) {
                                // 对于下划线和删除线，需要特殊处理以确保它们可以共存
                                if (format === 'underline' || format === 'strikethrough') {
                                    // 检查是否已经有另一种格式
                                    const otherFormat = format === 'underline' ? 'strikethrough' : 'underline';
                                    const hasOtherFormat = this._checkFormatStateInternal(range, otherFormat);
                                    
                                    if (hasOtherFormat) {
                                        // 如果已经有另一种格式，需要手动处理以确保两种格式共存
                                        // 获取选中文本
                                        const selectedText = range.extractContents();
                                        
                                        // 创建新格式元素，并将选中文本放入其中
                                        const newFormatElement = document.createElement(tagName);
                                        
                                        // 检查选中内容是否已经在另一种格式元素内
                                        let container = range.commonAncestorContainer;
                                        if (container.nodeType === Node.TEXT_NODE) {
                                            container = container.parentElement;
                                        }
                                        
                                        let otherFormatElement = null;
                                        let current = container;
                                        const otherTagName = format === 'underline' ? 's' : 'u';
                                        
                                        while (current && current !== document.body) {
                                            if (current.nodeType === Node.ELEMENT_NODE) {
                                                const tag = current.tagName ? current.tagName.toLowerCase() : '';
                                                if (tag === otherTagName || 
                                                    (otherTagName === 's' && (tag === 'strike' || tag === 'del'))) {
                                                    otherFormatElement = current;
                                                    break;
                                                }
                                            }
                                            current = current.parentElement || current.parentNode;
                                        }
                                        
                                        if (otherFormatElement) {
                                            // 在已有格式元素内创建新格式元素
                                            newFormatElement.appendChild(selectedText);
                                            otherFormatElement.appendChild(newFormatElement);
                                            
                                            // 恢复选择
                                            const newRange = document.createRange();
                                            newRange.selectNodeContents(newFormatElement);
                                            selection.removeAllRanges();
                                            selection.addRange(newRange);
                                        } else {
                                            // 没有其他格式，使用 execCommand（记录历史）
                                            range.insertNode(selectedText);
                                            if (domWriter) {
                                                domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                            } else {
                                                document.execCommand(format, false, null);
                                            }
                                        }
                                    } else {
                                        // 没有其他格式，使用 execCommand（记录历史）
                                        if (domWriter) {
                                            domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                        } else {
                                            document.execCommand(format, false, null);
                                        }
                                    }
                                } else {
                                    // 其他格式（bold, italic），直接使用 execCommand（记录历史）
                                    if (domWriter) {
                                        domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                    } else {
                                        document.execCommand(format, false, null);
                                    }
                                }
                            } else if (className) {
                                // 高亮：需要特殊处理
                                const selectedText = range.toString();
                                const highlightSpan = document.createElement('span');
                                highlightSpan.className = className;
                                highlightSpan.style.backgroundColor = 'rgba(154, 255, 232, 0.69)';
                                highlightSpan.textContent = selectedText;
                                range.deleteContents();
                                range.insertNode(highlightSpan);
                                
                                // 恢复选择（保持选中状态，类似 CKEditor 5 的行为）
                                selection.removeAllRanges();
                                const newRange = document.createRange();
                                newRange.selectNodeContents(highlightSpan);
                                selection.addRange(newRange);
                            }
                        }
                    }

                    notifyContentChanged();
                    // 格式操作后立即同步状态（参考 CKEditor 5）
                    // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                    requestAnimationFrame(() => {
                        if (!isComposing && !isLoadingContent) {
                            syncFormatState();
                        }
                    });
                    return format + ' 格式已' + (isCurrentlyFormatted ? '清除' : '应用');
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '应用格式失败', { format, error: error.message });
                    return '应用格式失败: ' + error.message;
                }
            },

            /**
             * 检查当前格式状态（供外部调用）
             * @param {Range} range - 选择范围（可选，如果不提供则使用当前选择）
             * @param {string} format - 格式类型
             * @returns {boolean} 是否已应用格式
             */
            checkFormatState: function(range, format) {
                // 如果没有提供 range，使用当前选择
                if (!range) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        return false;
                    }
                    range = selection.getRangeAt(0);
                }
                
                return this._checkFormatStateInternal(range, format);
            },

            /**
             * 检查标题级别（参考 CKEditor 5 的 heading command value）
             * @param {Range} range - 选择范围（可选）
             * @returns {number|null} 标题级别 (1=大标题, 2=二级标题, 3=三级标题, null=正文)
             */
            checkHeadingLevel: function(range) {
                if (!range) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        return null;
                    }
                    range = selection.getRangeAt(0);
                }

                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                // 向上查找标题元素
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const className = current.className || '';
                        // 检查标题类名
                        if (className.includes('mi-note-size')) {
                            return 1; // 大标题 <size>
                        } else if (className.includes('mi-note-mid-size')) {
                            return 2; // 二级标题 <mid-size>
                        } else if (className.includes('mi-note-h3-size')) {
                            return 3; // 三级标题 <h3-size>
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                return null; // 正文
            },

            /**
             * 检查列表类型（参考 CKEditor 5 的 list command value）
             * @param {Range} range - 选择范围（可选）
             * @returns {string|null} 列表类型 ('bullet'=无序列表, 'order'=有序列表, null=非列表)
             */
            checkListType: function(range) {
                if (!range) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        return null;
                    }
                    range = selection.getRangeAt(0);
                }

                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                // 向上查找列表元素
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const className = current.className || '';
                        // 检查列表类名
                        if (className.includes('mi-note-bullet')) {
                            return 'bullet'; // 无序列表 <bullet>
                        } else if (className.includes('mi-note-order')) {
                            return 'order'; // 有序列表 <order>
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                return null; // 非列表
            },

            /**
             * 检查文本对齐方式（参考 CKEditor 5 的 alignment command value）
             * @param {Range} range - 选择范围（可选）
             * @returns {string} 对齐方式 ('left', 'center', 'right')
             */
            checkTextAlignment: function(range) {
                if (!range) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        return 'left';
                    }
                    range = selection.getRangeAt(0);
                }

                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                // 向上查找文本元素（mi-note-text）
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const className = current.className || '';
                        // 检查对齐类名
                        if (className.includes('mi-note-text')) {
                            // 检查是否有对齐样式（使用 center 和 right 类名）
                            if (current.classList.contains('center')) {
                                return 'center'; // 居中 <center>
                            } else if (current.classList.contains('right')) {
                                return 'right'; // 居右 <right>
                            }
                            return 'left'; // 默认左对齐
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                return 'left'; // 默认左对齐
            },

            /**
             * 检查是否在引用块中（参考 CKEditor 5 的 blockQuote command value）
             * @param {Range} range - 选择范围（可选）
             * @returns {boolean} 是否在引用块中
             */
            checkQuoteState: function(range) {
                if (!range) {
                    const selection = window.getSelection();
                    if (!selection.rangeCount) {
                        return false;
                    }
                    range = selection.getRangeAt(0);
                }

                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                // 向上查找引用块元素
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const className = current.className || '';
                        // 检查引用块类名
                        if (className.includes('mi-note-quote')) {
                            return true; // 在引用块中 <quote>
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                return false; // 不在引用块中
            },

            /**
             * 内部方法：检查当前格式状态
             * @param {Range} range - 选择范围
             * @param {string} format - 格式类型
             * @returns {boolean} 是否已应用格式
             */
            _checkFormatStateInternal: function(range, format) {
                let tagName = '';
                let className = '';
                
                switch (format) {
                    case 'bold':
                        tagName = 'b';
                        break;
                    case 'italic':
                        tagName = 'i';
                        break;
                    case 'underline':
                        tagName = 'u';
                        break;
                    case 'strikethrough':
                        tagName = 's';
                        break;
                    case 'highlight':
                        className = 'mi-note-highlight';
                        break;
                }

                // 方法1：优先使用 document.queryCommandState（最准确，类似 CKEditor 5 的 selection.hasAttribute）
                // 这是最接近 CKEditor 5 实现的方法
                try {
                    if (tagName) {
                        const state = document.queryCommandState(format);
                        // 确保返回值是有效的布尔值
                        if (state !== undefined && state !== null) {
                            return Boolean(state);
                        }
                    }
                } catch (e) {
                    // queryCommandState 可能不支持某些格式，继续使用 DOM 检查
                }

                // 方法2：使用 DOM 检查格式状态（参考 CKEditor 5 的 _getValueFromFirstAllowedNode）
                // CKEditor 5 会检查选择范围内的第一个允许该属性的节点
                let container = range.commonAncestorContainer;
                
                // 如果是文本节点，检查其父元素
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }

                // 向上查找格式标签（支持所有可能的标签变体）
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const tag = current.tagName ? current.tagName.toLowerCase() : '';
                        // 检查所有可能的格式标签变体（类似 CKEditor 5 的处理）
                        if (tagName) {
                            if (tag === tagName || 
                                (tag === 'strong' && tagName === 'b') || 
                                (tag === 'em' && tagName === 'i') ||
                                (tag === 'strike' && tagName === 's') ||
                                (tag === 'del' && tagName === 's')) {
                                return true;
                            }
                        }
                        if (className && current.classList && current.classList.contains(className)) {
                            return true;
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                // 方法3：对于非折叠选择，检查选中文本是否包含格式（参考 CKEditor 5 的 range.getItems）
                // CKEditor 5 会遍历选择范围内的所有节点
                if (!range.collapsed) {
                    try {
                        const contents = range.cloneContents();
                        // 检查克隆内容中是否包含格式元素
                        if (tagName) {
                            // 检查所有可能的格式标签变体
                            const formatElements = contents.querySelectorAll(
                                tagName + ', strong, em, strike, del, s'
                            );
                            if (formatElements.length > 0) {
                                // 检查是否所有文本都在格式元素内
                                // 如果选中文本完全在格式元素内，返回 true
                                const allTextInFormat = Array.from(formatElements).some(el => {
                                    const elText = el.textContent || '';
                                    const rangeText = range.toString();
                                    return elText.includes(rangeText) || rangeText.includes(elText);
                                });
                                if (allTextInFormat) {
                                    return true;
                                }
                            }
                        }
                        if (className) {
                            const formatElements = contents.querySelectorAll('.' + className);
                            if (formatElements.length > 0) {
                                return true;
                            }
                        }
                    } catch (e) {
                        // 忽略错误
                    }
                }

                return false;
            },

            /**
             * 清除光标位置的格式（优化版，参考 CKEditor 5 的 AttributeCommand 实现）
             * 
             * CKEditor 5 的核心思路：
             * - 对于折叠选择，使用 writer.removeSelectionAttribute（类似 execCommand 的 removeFormat）
             * - 自动处理光标位置，确保后续输入不继承格式
             * 
             * @param {Range} range - 选择范围
             * @param {string} format - 格式类型
             * @param {string} tagName - 标签名
             * @param {string} className - 类名
             */
            clearFormatAtCursor: function(range, format, tagName, className) {
                const selection = window.getSelection();
                
                // 方法1：优先使用 execCommand（最可靠，类似 CKEditor 5 的 writer.removeSelectionAttribute）
                // 但只对 execCommand 支持的格式（bold, italic, underline, strikethrough）使用
                // 高亮等自定义格式直接使用手动方法
                if (tagName && !className) {
                    try {
                        const isFormatted = document.queryCommandState(format);
                        if (isFormatted) {
                            // 检查光标是否在格式元素末尾
                            let container = range.commonAncestorContainer;
                            let formatElement = null;
                            let isAtEnd = false;
                            
                            // 向上查找格式元素
                            let current = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                            while (current && current !== document.body) {
                                if (current.nodeType === Node.ELEMENT_NODE) {
                                    const tag = current.tagName ? current.tagName.toLowerCase() : '';
                                    if (tagName && (
                                        tag === tagName || 
                                        (tag === 'strong' && tagName === 'b') || 
                                        (tag === 'em' && tagName === 'i') ||
                                        (tag === 'strike' && tagName === 's') ||
                                        (tag === 'del' && tagName === 's')
                                    )) {
                                        formatElement = current;
                                        // 检查光标是否在格式元素末尾
                                        if (container.nodeType === Node.TEXT_NODE) {
                                            const textNode = container;
                                            const lastTextNode = this.getLastTextNode(formatElement);
                                            if (textNode === lastTextNode && range.startOffset === textNode.textContent.length) {
                                                isAtEnd = true;
                                            }
                                        }
                                        break;
                                    }
                                }
                                current = current.parentElement || current.parentNode;
                            }
                            
                            // 如果光标在格式元素末尾，先移出再清除格式（避免光标跳到开头）
                            if (isAtEnd && formatElement) {
                                const parent = formatElement.parentElement;
                                if (parent) {
                                    // 在格式元素后查找或创建文本节点
                                    let nextTextNode = formatElement.nextSibling;
                                    while (nextTextNode && nextTextNode.nodeType !== Node.TEXT_NODE) {
                                        if (nextTextNode.nodeType === Node.ELEMENT_NODE) {
                                            const walker = document.createTreeWalker(
                                                nextTextNode,
                                                NodeFilter.SHOW_TEXT,
                                                null
                                            );
                                            const firstText = walker.nextNode();
                                            if (firstText) {
                                                nextTextNode = firstText;
                                                break;
                                            }
                                        }
                                        nextTextNode = nextTextNode.nextSibling;
                                    }
                                    
                                    if (!nextTextNode || nextTextNode.nodeType !== Node.TEXT_NODE) {
                                        // 创建新文本节点
                                        nextTextNode = document.createTextNode('');
                                        if (formatElement.nextSibling) {
                                            parent.insertBefore(nextTextNode, formatElement.nextSibling);
                                        } else {
                                            parent.appendChild(nextTextNode);
                                        }
                                    }
                                    
                                    // 移动光标到格式元素后的文本节点
                                    const newRange = document.createRange();
                                    newRange.setStart(nextTextNode, 0);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                    
                                    // 现在清除格式（光标已经在格式元素外）
                                    if (domWriter) {
                                        domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                    } else {
                                        document.execCommand(format, false, null);
                                    }
                                    return;
                                }
                            }
                            
                            // 使用 execCommand 切换格式（会清除当前格式）（记录历史）
                            if (domWriter) {
                                domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                            } else {
                                document.execCommand(format, false, null);
                            }
                            
                            // 验证格式是否已清除
                            const stillFormatted = document.queryCommandState(format);
                            if (!stillFormatted) {
                                // 格式已清除，execCommand 已经处理了光标位置
                                return;
                            }
                        }
                    } catch (e) {
                        // execCommand 可能不支持，继续使用手动方法
                        log.warn(LOG_MODULES.FORMAT, 'execCommand 清除格式失败，使用手动方法', { error: e.message });
                    }
                }
                
                // 方法2：手动清除（当 execCommand 不可用或失败时，或自定义格式如高亮）
                // 参考 CKEditor 5 的思路：找到格式元素，将光标移出并移除格式元素
                // 关键：如果光标在格式元素末尾，清除格式后光标应该在格式元素后（不是开头）
                let container = range.commonAncestorContainer;
                let formatElement = null;
                
                // 向上查找格式标签（支持所有变体）
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const tag = current.tagName ? current.tagName.toLowerCase() : '';
                        // 检查是否是目标格式元素（支持所有变体）
                        if (tagName) {
                            if (tag === tagName || 
                                (tag === 'strong' && tagName === 'b') || 
                                (tag === 'em' && tagName === 'i') ||
                                (tag === 'strike' && tagName === 's') ||
                                (tag === 'del' && tagName === 's')) {
                                formatElement = current;
                                break;
                            }
                        }
                        if (className && current.classList && current.classList.contains(className)) {
                            formatElement = current;
                            break;
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                if (formatElement) {
                    // 光标在格式元素内，需要移出并移除格式元素（参考 CKEditor 5 的光标管理）
                    const parent = formatElement.parentElement;
                    if (!parent) {
                        // 如果没有父元素，尝试使用 execCommand（仅对支持的格式）
                        if (tagName) {
                            try {
                                if (domWriter) {
                                    domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                                } else {
                                    document.execCommand(format, false, null);
                                }
                            } catch (e) {
                                log.warn(LOG_MODULES.FORMAT, 'execCommand 清除格式失败', { format, error: e.message });
                            }
                        }
                        return;
                    }

                    // 确定光标是否在格式元素的末尾
                    let cursorIsAtEnd = false;
                    if (container.nodeType === Node.TEXT_NODE) {
                        const textNode = container;
                        const lastTextNode = this.getLastTextNode(formatElement);
                        if (textNode === lastTextNode && range.startOffset === textNode.textContent.length) {
                            cursorIsAtEnd = true;
                        }
                    }

                    // 对于自定义格式（如高亮），需要特殊处理
                    // 关键：如果光标在格式元素末尾，只移出光标，不展开整个元素（与加粗逻辑一致）
                    // 但是，移出光标后，高亮格式已经被"清除"（因为光标不在高亮元素内了）
                    // 这与加粗的逻辑一致：移出光标后，execCommand 会清除格式
                    if (className) {
                        if (cursorIsAtEnd) {
                            // 光标在高亮元素末尾，只移出光标，保留高亮元素内容
                            // 在格式元素后查找或创建文本节点
                            let nextTextNode = formatElement.nextSibling;
                            while (nextTextNode && nextTextNode.nodeType !== Node.TEXT_NODE) {
                                if (nextTextNode.nodeType === Node.ELEMENT_NODE) {
                                    const walker = document.createTreeWalker(
                                        nextTextNode,
                                        NodeFilter.SHOW_TEXT,
                                        null
                                    );
                                    const firstText = walker.nextNode();
                                    if (firstText) {
                                        nextTextNode = firstText;
                                        break;
                                    }
                                }
                                nextTextNode = nextTextNode.nextSibling;
                            }
                            
                            if (!nextTextNode || nextTextNode.nodeType !== Node.TEXT_NODE) {
                                // 创建新文本节点
                                nextTextNode = document.createTextNode('');
                                if (formatElement.nextSibling) {
                                    parent.insertBefore(nextTextNode, formatElement.nextSibling);
                                } else {
                                    parent.appendChild(nextTextNode);
                                }
                            }
                            
                            // 移动光标到格式元素后的文本节点
                            // 注意：光标移出后，高亮格式已经被"清除"（因为光标不在高亮元素内了）
                            // 这与加粗的逻辑一致：移出光标后，execCommand 会清除格式
                            const newRange = document.createRange();
                            newRange.setStart(nextTextNode, 0);
                            newRange.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(newRange);
                            
                            // 验证：确保光标不在高亮元素内
                            // 如果光标仍然在高亮元素内，需要进一步处理
                            const currentContainer = newRange.commonAncestorContainer;
                            let currentParent = currentContainer.nodeType === Node.TEXT_NODE ? currentContainer.parentElement : currentContainer;
                            let stillInHighlight = false;
                            while (currentParent && currentParent !== document.body) {
                                if (currentParent.classList && currentParent.classList.contains(className)) {
                                    stillInHighlight = true;
                                    break;
                                }
                                currentParent = currentParent.parentElement || currentParent.parentNode;
                            }
                            
                            // 如果光标仍然在高亮元素内，说明移出失败，需要展开高亮元素
                            if (stillInHighlight) {
                                // 展开高亮元素的内容
                                const fragment = document.createDocumentFragment();
                                while (formatElement.firstChild) {
                                    fragment.appendChild(formatElement.firstChild);
                                }
                                
                                // 在格式元素后插入内容
                                if (formatElement.nextSibling) {
                                    parent.insertBefore(fragment, formatElement.nextSibling);
                                } else {
                                    parent.appendChild(fragment);
                                }
                                
                                // 移除格式元素
                                parent.removeChild(formatElement);
                                
                                // 移动光标到展开内容后的位置
                                if (fragment.childNodes.length > 0) {
                                    const lastNode = fragment.lastChild;
                                    if (lastNode.nodeType === Node.TEXT_NODE) {
                                        const finalRange = document.createRange();
                                        finalRange.setStart(lastNode, lastNode.textContent.length);
                                        finalRange.collapse(true);
                                        selection.removeAllRanges();
                                        selection.addRange(finalRange);
                                    } else {
                                        const lastTextNode = this.getLastTextNode(fragment);
                                        if (lastTextNode) {
                                            const finalRange = document.createRange();
                                            finalRange.setStart(lastTextNode, lastTextNode.textContent.length);
                                            finalRange.collapse(true);
                                            selection.removeAllRanges();
                                            selection.addRange(finalRange);
                                        }
                                    }
                                } else {
                                    const newTextNode = document.createTextNode('');
                                    if (formatElement.nextSibling) {
                                        parent.insertBefore(newTextNode, formatElement.nextSibling);
                                    } else {
                                        parent.appendChild(newTextNode);
                                    }
                                    const finalRange = document.createRange();
                                    finalRange.setStart(newTextNode, 0);
                                    finalRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(finalRange);
                                }
                            }
                            
                            return;
                        } else {
                            // 光标不在末尾，需要展开格式元素的内容
                            const fragment = document.createDocumentFragment();
                            while (formatElement.firstChild) {
                                fragment.appendChild(formatElement.firstChild);
                            }
                            
                            // 在格式元素后插入内容
                            if (formatElement.nextSibling) {
                                parent.insertBefore(fragment, formatElement.nextSibling);
                            } else {
                                parent.appendChild(fragment);
                            }
                            
                            // 移除格式元素
                            parent.removeChild(formatElement);
                            
                            // 移动光标到展开内容后的位置
                            if (fragment.childNodes.length > 0) {
                                const lastNode = fragment.lastChild;
                                if (lastNode.nodeType === Node.TEXT_NODE) {
                                    const newRange = document.createRange();
                                    newRange.setStart(lastNode, lastNode.textContent.length);
                                    newRange.collapse(true);
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                } else {
                                    // 如果最后一个节点不是文本节点，查找最后一个文本节点
                                    const lastTextNode = this.getLastTextNode(fragment);
                                    if (lastTextNode) {
                                        const newRange = document.createRange();
                                        newRange.setStart(lastTextNode, lastTextNode.textContent.length);
                                        newRange.collapse(true);
                                        selection.removeAllRanges();
                                        selection.addRange(newRange);
                                    }
                                }
                            } else {
                                // 如果格式元素为空，在格式元素位置创建文本节点
                                const newTextNode = document.createTextNode('');
                                if (formatElement.nextSibling) {
                                    parent.insertBefore(newTextNode, formatElement.nextSibling);
                                } else {
                                    parent.appendChild(newTextNode);
                                }
                                const newRange = document.createRange();
                                newRange.setStart(newTextNode, 0);
                                newRange.collapse(true);
                                selection.removeAllRanges();
                                selection.addRange(newRange);
                            }
                            return;
                        }
                    }

                    // 对于 execCommand 支持的格式，检查格式元素后是否已有文本节点
                    let nextTextNode = null;
                    let nextSibling = formatElement.nextSibling;
                    
                    // 查找格式元素后的第一个文本节点
                    while (nextSibling) {
                        if (nextSibling.nodeType === Node.TEXT_NODE) {
                            nextTextNode = nextSibling;
                            break;
                        } else if (nextSibling.nodeType === Node.ELEMENT_NODE) {
                            // 查找子元素中的第一个文本节点
                            const walker = document.createTreeWalker(
                                nextSibling,
                                NodeFilter.SHOW_TEXT,
                                null
                            );
                            const firstText = walker.nextNode();
                            if (firstText) {
                                nextTextNode = firstText;
                                break;
                            }
                        }
                        nextSibling = nextSibling.nextSibling;
                    }
                    
                    // 如果格式元素后已有文本节点，直接移动光标到那里（避免创建新节点）
                    if (nextTextNode) {
                        const newRange = document.createRange();
                        newRange.setStart(nextTextNode, 0);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    } else {
                        // 如果没有文本节点，创建一个
                        const newTextNode = document.createTextNode('');
                        if (formatElement.nextSibling) {
                            parent.insertBefore(newTextNode, formatElement.nextSibling);
                        } else {
                            parent.appendChild(newTextNode);
                        }
                        
                        // 移动光标到新文本节点
                        const newRange = document.createRange();
                        newRange.setStart(newTextNode, 0);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                } else {
                    // 光标不在格式元素内，直接使用 execCommand 清除（仅对支持的格式）
                    if (tagName) {
                        try {
                            if (domWriter) {
                                domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                            } else {
                                document.execCommand(format, false, null);
                            }
                        } catch (e) {
                            log.warn(LOG_MODULES.FORMAT, 'execCommand 清除格式失败', { format, error: e.message });
                        }
                    }
                }
            },

            /**
             * 获取元素的最后一个文本节点
             * @param {Node} element - 元素
             * @returns {Node|null} 最后一个文本节点
             */
            getLastTextNode: function(element) {
                if (!element) return null;
                
                // 深度优先搜索最后一个文本节点
                const walker = document.createTreeWalker(
                    element,
                    NodeFilter.SHOW_TEXT,
                    null
                );
                
                let lastTextNode = null;
                let node = walker.nextNode();
                while (node) {
                    lastTextNode = node;
                    node = walker.nextNode();
                }
                
                return lastTextNode;
            },

            /**
             * 确保光标不在格式元素内（应用格式前调用）
             * 
             * 参考 CKEditor 5 的思路：当应用格式时，如果光标在其他格式元素内，
             * 应该将光标移出，确保新应用的格式不会与其他格式冲突。
             * 
             * 注意：对于 execCommand 支持的格式（bold, italic, underline, strikethrough），
             * execCommand 会自动处理，这个方法主要用于高亮等自定义格式。
             * 
             * @param {Range} range - 选择范围
             * @param {string} format - 格式类型
             * @param {string} tagName - 标签名
             * @param {string} className - 类名
             */
            ensureCursorOutsideFormatElements: function(range, format, tagName, className) {
                // 对于 execCommand 支持的格式，不需要手动处理
                // execCommand 会自动处理光标位置和格式应用
                if (tagName && ['bold', 'italic', 'underline', 'strikethrough'].includes(format)) {
                    return;
                }
                
                // 只对自定义格式（如高亮）需要手动处理
                const selection = window.getSelection();
                let container = range.commonAncestorContainer;
                let formatElement = null;
                
                // 向上查找所有可能的格式标签
                let current = container;
                while (current && current !== document.body) {
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        const tag = current.tagName ? current.tagName.toLowerCase() : '';
                        const hasClass = current.classList || false;
                        
                        // 检查是否是任何格式元素
                        const isFormatElement = 
                            tag === 'b' || tag === 'strong' ||  // 加粗
                            tag === 'i' || tag === 'em' ||      // 斜体
                            tag === 'u' ||                       // 下划线
                            tag === 's' || tag === 'strike' || tag === 'del' ||  // 删除线
                            (hasClass && current.classList.contains('mi-note-highlight'));  // 高亮
                        
                        if (isFormatElement) {
                            formatElement = current;
                            break;
                        }
                    }
                    current = current.parentElement || current.parentNode;
                }

                if (formatElement) {
                    // 光标在格式元素内，需要移出
                    const parent = formatElement.parentElement;
                    if (parent) {
                        // 在格式元素后插入文本节点
                        const textNode = document.createTextNode('');
                        if (formatElement.nextSibling) {
                            parent.insertBefore(textNode, formatElement.nextSibling);
                        } else {
                            parent.appendChild(textNode);
                        }
                        
                        // 移动光标到文本节点
                        const newRange = document.createRange();
                        newRange.setStart(textNode, 0);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            },

            /**
             * 从选中文本中移除格式（参考 CKEditor 5 的 RemoveFormatCommand）
             * 
             * CKEditor 5 使用 writer.removeAttribute 在范围内移除格式属性
             * 我们使用 execCommand 实现类似效果
             * 
             * @param {Range} range - 选择范围
             * @param {string} format - 格式类型
             * @param {string} tagName - 标签名
             * @param {string} className - 类名
             */
            removeFormatFromSelection: function(range, format, tagName, className) {
                const selection = window.getSelection();
                
                // 方法1：优先使用 execCommand（最可靠，类似 CKEditor 5 的 writer.removeAttribute）
                // 但只对 execCommand 支持的格式（bold, italic, underline, strikethrough）使用
                if (tagName && !className) {
                    try {
                        // execCommand 会自动处理选中文本的格式移除（记录历史）
                        if (domWriter) {
                            domWriter.executeCommandWithHistory(format, false, null, 'format-' + format);
                        } else {
                            document.execCommand(format, false, null);
                        }
                        return;
                    } catch (e) {
                        log.warn(LOG_MODULES.FORMAT, 'execCommand 失败，使用手动方法', { error: e.message });
                    }
                }
                
                // 方法2：手动移除格式（当 execCommand 不可用或失败时，或自定义格式如高亮）
                // 主要用于高亮等自定义格式
                try {
                    const contents = range.extractContents();
                    const walker = document.createTreeWalker(
                        contents,
                        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
                        null
                    );

                    const fragment = document.createDocumentFragment();
                    let node = walker.nextNode();
                    while (node) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const tag = node.tagName ? node.tagName.toLowerCase() : '';
                            const nodeClassName = node.className || '';
                            // 检查是否是目标格式元素（支持所有变体）
                            if (tagName && (
                                tag === tagName || 
                                (tag === 'strong' && tagName === 'b') || 
                                (tag === 'em' && tagName === 'i') ||
                                (tag === 'strike' && tagName === 's') ||
                                (tag === 'del' && tagName === 's')
                            )) {
                                // 移除格式标签，保留内容（类似 CKEditor 5 的 unwrap）
                                while (node.firstChild) {
                                    fragment.appendChild(node.firstChild);
                                }
                            } else if (className && node.classList && node.classList.contains(className)) {
                                // 移除高亮，保留内容
                                while (node.firstChild) {
                                    fragment.appendChild(node.firstChild);
                                }
                            } else {
                                // 保留其他元素，但递归处理其子元素
                                const clonedNode = node.cloneNode(false);
                                const childFragment = document.createDocumentFragment();
                                let childNode = walker.nextNode();
                                while (childNode && childNode.parentNode === node) {
                                    if (childNode.nodeType === Node.TEXT_NODE) {
                                        childFragment.appendChild(childNode.cloneNode(true));
                                    } else if (childNode.nodeType === Node.ELEMENT_NODE) {
                                        // 递归处理子元素
                                        const childTag = childNode.tagName ? childNode.tagName.toLowerCase() : '';
                                        if (tagName && (
                                            childTag === tagName || 
                                            (childTag === 'strong' && tagName === 'b') || 
                                            (childTag === 'em' && tagName === 'i')
                                        )) {
                                            while (childNode.firstChild) {
                                                childFragment.appendChild(childNode.firstChild);
                                            }
                                        } else {
                                            childFragment.appendChild(childNode.cloneNode(true));
                                        }
                                    }
                                    childNode = walker.nextNode();
                                }
                                clonedNode.appendChild(childFragment);
                                fragment.appendChild(clonedNode);
                            }
                        } else {
                            fragment.appendChild(node.cloneNode(true));
                        }
                        node = walker.nextNode();
                    }

                    range.deleteContents();
                    range.insertNode(fragment);
                    
                    // 恢复选择（保持选中状态）
                    selection.removeAllRanges();
                    const newRange = document.createRange();
                    newRange.setStartBefore(fragment);
                    newRange.setEndAfter(fragment);
                    selection.addRange(newRange);
                } catch (e) {
                    log.error(LOG_MODULES.FORMAT, '手动移除格式失败', { error: e.message });
                }
            },

            /**
             * 应用标题格式
             * @param {number} level - 标题级别 (0=清除, 1=大标题, 2=二级标题, 3=三级标题)
             * @returns {string} 状态信息
             */
            applyHeading: function(level) {
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return '请先选中文本或定位光标';
                }

                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }

                const range = selection.getRangeAt(0);
                
                try {
                    // 使用 DOMWriter 批量操作模式
                    domWriter.beginBatch();
                    
                    // 查找包含选中文本的文本元素
                    let textElement = range.commonAncestorContainer;
                    if (textElement.nodeType === Node.TEXT_NODE) {
                        textElement = textElement.parentElement;
                    }

                    // 向上查找 mi-note-text 元素
                    while (textElement && !textElement.classList.contains('mi-note-text')) {
                        textElement = textElement.parentElement;
                    }

                    let targetNode = null;
                    let targetOffset = 0;

                    if (textElement && textElement.classList.contains('mi-note-text')) {
                        // 在文本元素中应用标题格式
                        if (level === 0) {
                            // 清除标题格式：移除所有标题 span
                            const titleSpans = textElement.querySelectorAll('.mi-note-size, .mi-note-mid-size, .mi-note-h3-size');
                            titleSpans.forEach(span => {
                                const parent = span.parentNode;
                                while (span.firstChild) {
                                    parent.insertBefore(span.firstChild, span);
                                }
                                domWriter.removeNode(span);
                            });
                            // 光标位置：移动到文本元素开头
                            targetNode = textElement;
                            targetOffset = 0;
                        } else {
                            // 应用标题格式
                            let className = '';
                            if (level === 1) {
                                className = 'mi-note-size'; // 大标题 <size>
                            } else if (level === 2) {
                                className = 'mi-note-mid-size'; // 二级标题 <mid-size>
                            } else if (level === 3) {
                                className = 'mi-note-h3-size'; // 三级标题 <h3-size>
                            }

                            if (className && !range.collapsed) {
                                // 有选中文本，包装选中文本
                                const selectedText = range.toString();
                                const titleSpan = document.createElement('span');
                                titleSpan.className = className;
                                titleSpan.textContent = selectedText;
                                range.deleteContents();
                                domWriter.execute(() => {
                                    range.insertNode(titleSpan);
                                }, true, { type: 'apply-heading' });
                                targetNode = titleSpan;
                                targetOffset = 0;
                            } else if (className) {
                                // 光标位置，在文本元素开头插入标题 span
                                const titleSpan = document.createElement('span');
                                titleSpan.className = className;
                                titleSpan.innerHTML = '\u200B';
                                domWriter.insertNode(titleSpan, textElement, true);
                                targetNode = titleSpan;
                                targetOffset = 0;
                            }
                        }
                    } else {
                        // 如果没有文本元素，创建新的文本元素并应用标题格式
                        const editor = document.getElementById('editor-content');
                        const textDiv = document.createElement('div');
                        textDiv.className = 'mi-note-text indent-1';
                        
                        if (level > 0) {
                            let className = '';
                            if (level === 1) {
                                className = 'mi-note-size';
                            } else if (level === 2) {
                                className = 'mi-note-mid-size';
                            } else if (level === 3) {
                                className = 'mi-note-h3-size';
                            }
                            
                            if (className) {
                                const titleSpan = document.createElement('span');
                                titleSpan.className = className;
                                titleSpan.innerHTML = '\u200B';
                                textDiv.appendChild(titleSpan);
                                targetNode = titleSpan;
                                targetOffset = 0;
                            } else {
                                textDiv.innerHTML = '\u200B';
                                targetNode = textDiv;
                                targetOffset = 0;
                            }
                        } else {
                            textDiv.innerHTML = '\u200B';
                            targetNode = textDiv;
                            targetOffset = 0;
                        }

                        if (range.collapsed) {
                            domWriter.execute(() => {
                                range.insertNode(textDiv);
                            }, true, { type: 'apply-heading' });
                        } else {
                            domWriter.execute(() => {
                                range.deleteContents();
                                range.insertNode(textDiv);
                            }, true, { type: 'apply-heading' });
                        }
                    }

                    // 结束批量操作
                    domWriter.endBatch({ type: 'apply-heading' });
                    
                    // 设置光标位置
                    if (targetNode) {
                        requestAnimationFrame(() => {
                            const range2 = document.createRange();
                            range2.setStart(targetNode, targetOffset);
                            range2.collapse(true);
                            selection.removeAllRanges();
                            selection.addRange(range2);
                            
                            notifyContentChanged();
                            syncFormatState();
                        });
                    } else {
                        notifyContentChanged();
                        requestAnimationFrame(() => {
                            if (!isComposing && !isLoadingContent) {
                                syncFormatState();
                            }
                        });
                    }
                    
                    return '标题格式已应用';
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '应用标题格式失败', { level, error: error.message });
                    return '应用标题格式失败: ' + error.message;
                }
            },

            /**
             * 应用对齐方式
             * @param {string} alignment - 对齐方式 (left, center, right)
             * @returns {string} 状态信息
             */
            applyAlignment: function(alignment) {
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return '没有选中文本';
                }

                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }

                const range = selection.getRangeAt(0);
                
                // 查找包含选中文本的文本元素
                let textElement = range.commonAncestorContainer;
                if (textElement.nodeType === Node.TEXT_NODE) {
                    textElement = textElement.parentElement;
                }

                // 向上查找 mi-note-text 元素
                while (textElement && !textElement.classList.contains('mi-note-text')) {
                    textElement = textElement.parentElement;
                }

                if (!textElement || !textElement.classList.contains('mi-note-text')) {
                    return '请选中文本元素';
                }

                try {
                    // 使用 DOMWriter 批量操作模式
                    domWriter.beginBatch();
                    
                    // 移除现有的对齐类
                    domWriter.setClass(textElement, 'center', false);
                    domWriter.setClass(textElement, 'right', false);
                    
                    // 应用新的对齐方式
                    if (alignment === 'center') {
                        domWriter.setClass(textElement, 'center', true);
                    } else if (alignment === 'right') {
                        domWriter.setClass(textElement, 'right', true);
                    }

                    // 结束批量操作
                    domWriter.endBatch({ type: 'apply-alignment' });
                    
                    notifyContentChanged();
                    // 格式操作后立即同步状态
                    // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                    requestAnimationFrame(() => {
                        if (!isComposing && !isLoadingContent) {
                            syncFormatState();
                        }
                    });
                    return '对齐方式已应用: ' + alignment;
                } catch (error) {
                    log.error(LOG_MODULES.FORMAT, '应用对齐方式失败', { alignment, error: error.message });
                    return '应用对齐方式失败: ' + error.message;
                }
            },

            /**
             * 插入无序列表
             * @returns {string} 状态信息
             */
            insertBulletList: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }

                const selection = window.getSelection();
                let range = null;

                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                } else {
                    range = document.createRange();
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 检查光标是否在文本元素中
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                let textElement = null;
                let hasContent = false;
                let contentHTML = '';
                
                if (container && container.classList && container.classList.contains('mi-note-text')) {
                    textElement = container;
                    const text = container.textContent || container.innerText || '';
                    const trimmedText = text.replace(/\u200B/g, '').trim();
                    hasContent = trimmedText !== '';
                    if (hasContent) {
                        // 提取内容（保留格式）
                        contentHTML = container.innerHTML;
                        // 清理零宽度空格
                        contentHTML = contentHTML.replace(/\u200B/g, '');
                    }
                }

                // 使用 DOMWriter 批量操作模式
                domWriter.beginBatch();
                
                // 创建无序列表元素
                const bulletDiv = document.createElement('div');
                bulletDiv.className = 'mi-note-bullet';
                bulletDiv.style.paddingLeft = '0px'; // indent 1
                
                if (hasContent && textElement) {
                    // 如果有内容，将内容放入列表项
                    bulletDiv.innerHTML = contentHTML || '\u200B';
                    // 替换文本元素
                    domWriter.replaceNode(textElement, bulletDiv);
                } else if (textElement) {
                    // 空文本元素，直接替换
                    bulletDiv.innerHTML = '\u200B';
                    domWriter.replaceNode(textElement, bulletDiv);
                } else {
                    // 不在文本元素中，插入新元素
                    bulletDiv.innerHTML = '\u200B';
                    const referenceNode = range.startContainer.nodeType === Node.TEXT_NODE 
                        ? range.startContainer.parentElement 
                        : range.startContainer;
                    if (referenceNode && referenceNode.parentNode) {
                        domWriter.insertNode(bulletDiv, referenceNode, false);
                    } else {
                        domWriter.execute(() => {
                            range.insertNode(bulletDiv);
                        }, true, { type: 'insert-bullet-list' });
                    }
                }

                // 移动光标到列表项内（如果有内容，移动到末尾；否则在开头）
                let targetNode = null;
                let targetOffset = 0;
                
                if (hasContent && bulletDiv.lastChild) {
                    // 有内容，移动到末尾
                    if (bulletDiv.lastChild.nodeType === Node.TEXT_NODE) {
                        targetNode = bulletDiv.lastChild;
                        targetOffset = bulletDiv.lastChild.textContent.length;
                    } else {
                        targetNode = bulletDiv;
                        targetOffset = bulletDiv.childNodes.length;
                    }
                } else {
                    // 无内容，移动到开头
                    if (bulletDiv.firstChild && bulletDiv.firstChild.nodeType === Node.TEXT_NODE) {
                        targetNode = bulletDiv.firstChild;
                        targetOffset = 0;
                    } else {
                        const textNode = document.createTextNode('\u200B');
                        bulletDiv.appendChild(textNode);
                        targetNode = textNode;
                        targetOffset = 0;
                    }
                }
                
                // 结束批量操作（会自动处理光标和状态同步）
                domWriter.endBatch({ type: 'insert-bullet-list' });
                
                // 设置光标位置
                requestAnimationFrame(() => {
                    const selection2 = window.getSelection();
                    const range2 = document.createRange();
                    range2.setStart(targetNode, targetOffset);
                    range2.collapse(true);
                    selection2.removeAllRanges();
                    selection2.addRange(range2);
                    
                    notifyContentChanged();
                    syncFormatState();
                });

                return '无序列表已插入';
            },

            /**
             * 插入有序列表
             * @returns {string} 状态信息
             */
            insertOrderList: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }

                const selection = window.getSelection();
                let range = null;

                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                } else {
                    range = document.createRange();
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 检查光标是否在文本元素中
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                let textElement = null;
                let hasContent = false;
                let contentHTML = '';
                
                if (container && container.classList && container.classList.contains('mi-note-text')) {
                    textElement = container;
                    const text = container.textContent || container.innerText || '';
                    const trimmedText = text.replace(/\u200B/g, '').trim();
                    hasContent = trimmedText !== '';
                    if (hasContent) {
                        // 提取内容（保留格式）
                        contentHTML = container.innerHTML;
                        // 清理零宽度空格
                        contentHTML = contentHTML.replace(/\u200B/g, '');
                    }
                }

                // 使用 DOMWriter 批量操作模式
                domWriter.beginBatch();
                
                // 创建有序列表元素
                const orderDiv = document.createElement('div');
                orderDiv.className = 'mi-note-order';
                orderDiv.setAttribute('data-number', '1');
                orderDiv.style.paddingLeft = '0px'; // indent 1
                
                if (hasContent && textElement) {
                    // 如果有内容，将内容放入列表项
                    orderDiv.innerHTML = contentHTML || '\u200B';
                    // 替换文本元素
                    domWriter.replaceNode(textElement, orderDiv);
                } else if (textElement) {
                    // 空文本元素，直接替换
                    orderDiv.innerHTML = '\u200B';
                    domWriter.replaceNode(textElement, orderDiv);
                } else {
                    // 不在文本元素中，插入新元素
                    orderDiv.innerHTML = '\u200B';
                    const referenceNode = range.startContainer.nodeType === Node.TEXT_NODE 
                        ? range.startContainer.parentElement 
                        : range.startContainer;
                    if (referenceNode && referenceNode.parentNode) {
                        domWriter.insertNode(orderDiv, referenceNode, false);
                    } else {
                        domWriter.execute(() => {
                            range.insertNode(orderDiv);
                        }, true, { type: 'insert-order-list' });
                    }
                }

                // 移动光标到列表项内（如果有内容，移动到末尾；否则在开头）
                let targetNode = null;
                let targetOffset = 0;
                
                if (hasContent && orderDiv.lastChild) {
                    // 有内容，移动到末尾
                    if (orderDiv.lastChild.nodeType === Node.TEXT_NODE) {
                        targetNode = orderDiv.lastChild;
                        targetOffset = orderDiv.lastChild.textContent.length;
                    } else {
                        targetNode = orderDiv;
                        targetOffset = orderDiv.childNodes.length;
                    }
                } else {
                    // 无内容，移动到开头
                    if (orderDiv.firstChild && orderDiv.firstChild.nodeType === Node.TEXT_NODE) {
                        targetNode = orderDiv.firstChild;
                        targetOffset = 0;
                    } else {
                        const textNode = document.createTextNode('\u200B');
                        orderDiv.appendChild(textNode);
                        targetNode = textNode;
                        targetOffset = 0;
                    }
                }
                
                // 结束批量操作（会自动处理光标和状态同步）
                domWriter.endBatch({ type: 'insert-order-list' });
                
                // 设置光标位置
                requestAnimationFrame(() => {
                    const selection2 = window.getSelection();
                    const range2 = document.createRange();
                    range2.setStart(targetNode, targetOffset);
                    range2.collapse(true);
                    selection2.removeAllRanges();
                    selection2.addRange(range2);
                    
                    notifyContentChanged();
                    syncFormatState();
                });

                return '有序列表已插入';
            },

            /**
             * 插入引用块
             * @returns {string} 状态信息
             */
            insertQuote: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                const selection = window.getSelection();
                let range = null;

                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                } else {
                    range = document.createRange();
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 创建引用块元素
                const quoteDiv = document.createElement('div');
                quoteDiv.className = 'mi-note-quote';

                // 创建引用块内的文本元素
                const textDiv = document.createElement('div');
                textDiv.className = 'mi-note-text indent-1';
                textDiv.innerHTML = '\u200B';
                quoteDiv.appendChild(textDiv);

                // 插入元素
                range.insertNode(quoteDiv);

                // 移动光标到引用块内
                range.selectNodeContents(textDiv);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);

                notifyContentChanged();
                // 格式操作后立即同步状态
                // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
                requestAnimationFrame(() => {
                    if (!isComposing && !isLoadingContent) {
                        syncFormatState();
                    }
                });
                return '引用块已插入';
            },

            /**
             * 插入复选框
             * @returns {string} 状态信息
             */
            insertCheckbox: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }

                const selection = window.getSelection();
                let range = null;

                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                } else {
                    range = document.createRange();
                    // 如果编辑器为空，直接添加到末尾
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        // 清空占位符
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 检查光标是否在文本元素中
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                let textElement = null;
                let hasContent = false;
                let contentHTML = '';
                
                if (container && container.classList && container.classList.contains('mi-note-text')) {
                    textElement = container;
                    const text = container.textContent || container.innerText || '';
                    const trimmedText = text.replace(/\u200B/g, '').trim();
                    hasContent = trimmedText !== '';
                    if (hasContent) {
                        // 提取内容（保留格式）
                        contentHTML = container.innerHTML;
                        // 清理零宽度空格
                        contentHTML = contentHTML.replace(/\u200B/g, '');
                    }
                }

                // 使用 DOMWriter 批量操作模式
                domWriter.beginBatch();
                
                // 创建复选框元素
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'mi-note-checkbox';
                checkboxDiv.setAttribute('data-level', '3');
                checkboxDiv.style.paddingLeft = '0px'; // indent 1

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkboxDiv.appendChild(checkbox);

                const span = document.createElement('span');
                if (hasContent && textElement) {
                    // 如果有内容，将内容放入 span
                    span.innerHTML = contentHTML || '\u200B';
                } else {
                    span.innerHTML = '\u200B'; // 零宽度空格，确保光标可见
                }
                checkboxDiv.appendChild(span);

                if (textElement) {
                    // 替换文本元素
                    domWriter.replaceNode(textElement, checkboxDiv);
                } else {
                    // 不在文本元素中，插入新元素
                    const referenceNode = range.startContainer.nodeType === Node.TEXT_NODE 
                        ? range.startContainer.parentElement 
                        : range.startContainer;
                    if (referenceNode && referenceNode.parentNode) {
                        domWriter.insertNode(checkboxDiv, referenceNode, false);
                    } else {
                        domWriter.execute(() => {
                            range.insertNode(checkboxDiv);
                        }, true, { type: 'insert-checkbox' });
                    }
                }

                // 移动光标到复选框的 span 内（如果有内容，移动到末尾；否则在开头）
                let targetNode = null;
                let targetOffset = 0;
                
                if (hasContent && span.lastChild) {
                    // 有内容，移动到末尾
                    if (span.lastChild.nodeType === Node.TEXT_NODE) {
                        targetNode = span.lastChild;
                        targetOffset = span.lastChild.textContent.length;
                    } else {
                        targetNode = span;
                        targetOffset = span.childNodes.length;
                    }
                } else {
                    // 无内容，移动到开头
                    if (span.firstChild && span.firstChild.nodeType === Node.TEXT_NODE) {
                        targetNode = span.firstChild;
                        targetOffset = 0;
                    } else {
                        const textNode = document.createTextNode('\u200B');
                        span.appendChild(textNode);
                        targetNode = textNode;
                        targetOffset = 0;
                    }
                }
                
                // 结束批量操作（会自动处理光标和状态同步）
                domWriter.endBatch({ type: 'insert-checkbox' });
                
                // 设置光标位置
                requestAnimationFrame(() => {
                    const selection2 = window.getSelection();
                    const range2 = document.createRange();
                    range2.setStart(targetNode, targetOffset);
                    range2.collapse(true);
                    selection2.removeAllRanges();
                    selection2.addRange(range2);
                    
                    notifyContentChanged();
                    syncFormatState();
                });

                return '复选框已插入';
            },

            /**
             * 插入分割线
             * @returns {string} 状态信息
             */
            insertHorizontalRule: function() {
            const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                const selection = window.getSelection();
                let range = null;
                
                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                        } else {
                    range = document.createRange();
                    // 如果编辑器为空，直接添加到末尾
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        // 清空占位符
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 创建分割线元素
                const hr = document.createElement('hr');
                hr.className = 'mi-note-hr';

                // 插入元素
                range.insertNode(hr);

                // 在分割线后插入换行，确保可以继续输入
                const br = document.createElement('br');
                range.setStartAfter(hr);
                range.insertNode(br);

                // 移动光标到分割线后
                range.setStartAfter(br);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        // 通知内容变化
                            notifyContentChanged();
                return '分割线已插入';
            },

            /**
             * 插入图片
             * @param {string} imageUrl - 图片 URL
             * @param {string} altText - 替代文本（可选）
             * @returns {string} 状态信息
             */
            insertImage: function(imageUrl, altText) {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }

                if (!imageUrl) {
                    return '图片 URL 不能为空';
                }

                const selection = window.getSelection();
                let range = null;

                if (selection.rangeCount > 0) {
                    range = selection.getRangeAt(0);
                } else {
                    range = document.createRange();
                    // 如果编辑器为空，直接添加到末尾
                    if (editor.childNodes.length === 0 || 
                        (editor.childNodes.length === 1 && editor.childNodes[0].classList && 
                         editor.childNodes[0].classList.contains('placeholder'))) {
                        // 清空占位符
                        editor.innerHTML = '';
                    }
                    range.selectNodeContents(editor);
                    range.collapse(false);
                }

                // 检查光标是否在列表项或待办项中
                let container = range.commonAncestorContainer;
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                // 向上查找，检查是否在列表项（mi-note-bullet, mi-note-order）或待办项（mi-note-checkbox）中
                let listItem = null;
                let currentNode = container;
                while (currentNode && currentNode !== editor) {
                    if (currentNode.classList) {
                        if (currentNode.classList.contains('mi-note-bullet') ||
                            currentNode.classList.contains('mi-note-order') ||
                            currentNode.classList.contains('mi-note-checkbox')) {
                            listItem = currentNode;
                            break;
                        }
                    }
                    currentNode = currentNode.parentElement;
                }

                // 如果在列表项或待办项中，需要先退出
                if (listItem) {
                    // 在列表项/待办项之后插入图片
                    // 创建一个新的范围，定位到列表项之后
                    let newRange = document.createRange();
                    if (listItem.nextSibling) {
                        // 如果列表项后面有兄弟节点，在兄弟节点之前插入
                        newRange.setStartBefore(listItem.nextSibling);
                        newRange.collapse(true);
                        range = newRange;
                    } else if (listItem.parentNode) {
                        // 如果列表项是最后一个，在父节点末尾插入
                        newRange.setStartAfter(listItem);
                        newRange.collapse(true);
                        range = newRange;
                    }
                    // 如果无法设置新范围（不应该发生），继续使用原来的 range
                }

                // 创建图片容器（使用 div 确保单独一行）
                const imageContainer = document.createElement('div');
                imageContainer.className = 'mi-note-image-container';
                imageContainer.style.margin = '8px 0'; // 添加上下边距，确保单独一行

                // 创建图片元素
                const img = document.createElement('img');
                img.src = imageUrl;
                img.alt = altText || '图片';
                img.className = 'mi-note-image';
                
                // 如果是 data URL，可以在这里处理
                // data URL 格式: data:image/png;base64,...
                if (imageUrl.startsWith('data:')) {
                    // data URL 可以直接使用，不需要额外处理
                    log.debug(LOG_MODULES.IMAGE, '插入 data URL 图片');
                } else if (imageUrl.startsWith('minote://')) {
                    // 小米笔记的图片 URL 格式
                        log.debug(LOG_MODULES.IMAGE, '插入小米笔记图片', { imageUrl });
                }

                imageContainer.appendChild(img);

                // 插入图片容器
                range.insertNode(imageContainer);

                // 在图片后插入换行，确保可以继续输入
                const br = document.createElement('br');
                range.setStartAfter(imageContainer);
                range.insertNode(br);

                // 移动光标到图片后
                range.setStartAfter(br);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
                
                    // 通知内容变化
                        notifyContentChanged();
                return '图片已插入';
            },
            
            /**
             * 增加缩进
             * @returns {string} 状态信息
             */
            increaseIndent: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }
                
                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }
                
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return '请先选择内容';
                }
                
                const range = selection.getRangeAt(0);
                let container = range.commonAncestorContainer;
                
                // 如果是文本节点，获取父元素
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                // 向上查找，找到可缩进的元素（文本、列表、待办项）
                let targetElement = null;
                let currentNode = container;
                while (currentNode && currentNode !== editor) {
                    if (currentNode.classList) {
                        if (currentNode.classList.contains('mi-note-text') ||
                            currentNode.classList.contains('mi-note-bullet') ||
                            currentNode.classList.contains('mi-note-order') ||
                            currentNode.classList.contains('mi-note-checkbox')) {
                            targetElement = currentNode;
                            break;
                        }
                    }
                    currentNode = currentNode.parentElement;
                }
                
                if (!targetElement) {
                    return '无法找到可缩进的元素';
                }
                
                // 获取当前缩进级别
                const currentIndent = parseInt(getIndentFromElement(targetElement), 10);
                if (currentIndent >= 5) {
                    return '已达到最大缩进级别';
                }
                
                // 使用 DOMWriter 批量操作
                domWriter.beginBatch();
                
                // 增加缩进
                setIndentForElement(targetElement, currentIndent + 1);
                
                // 结束批量操作
                domWriter.endBatch({ type: 'increase-indent' });
                
                // 通知内容变化
                notifyContentChanged();
                
                return '缩进已增加';
            },
            
            /**
             * 减少缩进
             * @returns {string} 状态信息
             */
            decreaseIndent: function() {
                const editor = document.getElementById('editor-content');
                if (!editor) {
                    return '编辑器元素不存在';
                }
                
                if (!domWriter) {
                    return 'DOMWriter 未初始化';
                }
                
                const selection = window.getSelection();
                if (!selection.rangeCount) {
                    return '请先选择内容';
                }
                
                const range = selection.getRangeAt(0);
                let container = range.commonAncestorContainer;
                
                // 如果是文本节点，获取父元素
                if (container.nodeType === Node.TEXT_NODE) {
                    container = container.parentElement;
                }
                
                // 向上查找，找到可缩进的元素（文本、列表、待办项）
                let targetElement = null;
                let currentNode = container;
                while (currentNode && currentNode !== editor) {
                    if (currentNode.classList) {
                        if (currentNode.classList.contains('mi-note-text') ||
                            currentNode.classList.contains('mi-note-bullet') ||
                            currentNode.classList.contains('mi-note-order') ||
                            currentNode.classList.contains('mi-note-checkbox')) {
                            targetElement = currentNode;
                            break;
                        }
                    }
                    currentNode = currentNode.parentElement;
                }
                
                if (!targetElement) {
                    return '无法找到可缩进的元素';
                }
                
                // 获取当前缩进级别
                const currentIndent = parseInt(getIndentFromElement(targetElement), 10);
                if (currentIndent <= 1) {
                    return '已达到最小缩进级别';
                }
                
                // 使用 DOMWriter 批量操作
                domWriter.beginBatch();
                
                // 减少缩进
                setIndentForElement(targetElement, currentIndent - 1);
                
                // 结束批量操作
                domWriter.endBatch({ type: 'decrease-indent' });
                
                // 通知内容变化
                notifyContentChanged();
                
                return '缩进已减少';
            }
        };

        // ==================== 回车键处理 ====================
        /**
         * 处理回车键事件
         * @param {KeyboardEvent} e - 键盘事件
         */
        function handleEnterKey(e) {
            // 如果正在组合输入，不处理回车键（避免打断输入）
            if (isComposing) {
                return;
            }
            
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                return;
            }

            const range = selection.getRangeAt(0);
            const container = range.commonAncestorContainer;
            
            // 查找当前所在的元素
            let currentNode = container;
            if (container.nodeType === Node.TEXT_NODE) {
                currentNode = container.parentElement;
            } else if (container.nodeType === Node.ELEMENT_NODE) {
                currentNode = container;
            }

            // 向上查找 checkbox、bullet 或 order 元素
            let checkboxElement = null;
            let bulletElement = null;
            let orderElement = null;
            let current = currentNode;
            
            while (current && current !== editor) {
                if (current.classList && current.classList.contains('mi-note-checkbox')) {
                    checkboxElement = current;
                    break;
                }
                if (current.classList && current.classList.contains('mi-note-bullet')) {
                    bulletElement = current;
                    break;
                }
                if (current.classList && current.classList.contains('mi-note-order')) {
                    orderElement = current;
                    break;
                }
                current = current.parentElement;
            }

            // 处理 checkbox 回车
            if (checkboxElement) {
                e.preventDefault();
                e.stopPropagation(); // 阻止事件冒泡，确保不会触发其他处理
                e.stopImmediatePropagation(); // 立即停止事件传播
                
                // 检查是否为空，如果为空则转换为普通正文
                if (isCheckboxEmpty(checkboxElement)) {
                    convertCheckboxToText(checkboxElement);
                } else {
                    createNewCheckbox(checkboxElement);
                }
                return false; // 确保返回 false，进一步阻止默认行为
            }

            // 处理无序列表回车
            if (bulletElement) {
                e.preventDefault();
                // 检查是否为空，如果为空则转换为普通正文
                if (isBulletEmpty(bulletElement)) {
                    convertBulletToText(bulletElement);
                } else {
                    createNewBullet(bulletElement);
                }
                return;
            }

            // 处理有序列表回车
            if (orderElement) {
                e.preventDefault();
                // 检查是否为空，如果为空则转换为普通正文
                if (isOrderEmpty(orderElement)) {
                    convertOrderToText(orderElement);
                } else {
                    createNewOrder(orderElement);
                }
                return;
            }
        }

        /**
         * 创建新的 checkbox
         * @param {HTMLElement} currentCheckbox - 当前的 checkbox 元素
         */
        function createNewCheckbox(currentCheckbox) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            // 检查是否已经有下一个 checkbox（防止重复创建）
            // 如果下一个兄弟节点已经是 checkbox，说明可能已经创建过了
            if (currentCheckbox.nextSibling && 
                currentCheckbox.nextSibling.classList && 
                currentCheckbox.nextSibling.classList.contains('mi-note-checkbox')) {
                // 已经有下一个 checkbox，直接移动光标到那里
                const nextCheckbox = currentCheckbox.nextSibling;
                const nextSpan = nextCheckbox.querySelector('span');
                if (nextSpan) {
                    const selection = window.getSelection();
                    const range = document.createRange();
                    if (nextSpan.firstChild && nextSpan.firstChild.nodeType === Node.TEXT_NODE) {
                        range.setStart(nextSpan.firstChild, 0);
                    } else {
                        range.selectNodeContents(nextSpan);
                    }
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
                return;
            }
            
            const indent = getIndentFromElement(currentCheckbox);
            const level = currentCheckbox.getAttribute('data-level') || '3';

            // 创建新的 checkbox
            const newCheckbox = document.createElement('div');
            newCheckbox.className = 'mi-note-checkbox';
            newCheckbox.setAttribute('data-level', level);
            newCheckbox.style.paddingLeft = currentCheckbox.style.paddingLeft || '0px';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            newCheckbox.appendChild(checkbox);

            const span = document.createElement('span');
            span.innerHTML = '\u200B';
            newCheckbox.appendChild(span);

            // 插入到当前 checkbox 之后
            if (currentCheckbox.nextSibling) {
                editor.insertBefore(newCheckbox, currentCheckbox.nextSibling);
            } else {
                editor.appendChild(newCheckbox);
            }

            // 立即设置光标到新 checkbox，避免浏览器默认行为
            // 使用双重 requestAnimationFrame 确保 DOM 更新完成后再设置光标
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const selection = window.getSelection();
                    if (!selection) return;
                    
                    const range = document.createRange();
                    // 确保选择 span 内的文本节点，而不是整个 span
                    if (span.firstChild && span.firstChild.nodeType === Node.TEXT_NODE) {
                        range.setStart(span.firstChild, 0);
                    } else {
                        range.selectNodeContents(span);
                    }
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    // 延迟通知内容变化，确保光标位置已设置
                    setTimeout(() => {
                        notifyContentChanged();
                    }, 0);
                });
            });
        }

        /**
         * 创建新的无序列表项
         * @param {HTMLElement} currentBullet - 当前的无序列表项
         */
        function createNewBullet(currentBullet) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            const indent = getIndentFromElement(currentBullet);

            // 创建新的 bullet
            const newBullet = document.createElement('div');
            newBullet.className = 'mi-note-bullet';
            newBullet.style.paddingLeft = currentBullet.style.paddingLeft || '0px';
            newBullet.innerHTML = '\u200B';

            // 插入到当前 bullet 之后
            if (currentBullet.nextSibling) {
                editor.insertBefore(newBullet, currentBullet.nextSibling);
                            } else {
                editor.appendChild(newBullet);
            }

            // 设置光标到新 bullet
            const selection = window.getSelection();
                        const range = document.createRange();
            range.selectNodeContents(newBullet);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);

            notifyContentChanged();
        }

        /**
         * 创建新的有序列表项
         * @param {HTMLElement} currentOrder - 当前的有序列表项
         */
        function createNewOrder(currentOrder) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            const indent = getIndentFromElement(currentOrder);
            const currentNumber = parseInt(currentOrder.getAttribute('data-number') || '1', 10);
            const nextNumber = currentNumber + 1;

            // 创建新的 order
            const newOrder = document.createElement('div');
            newOrder.className = 'mi-note-order';
            newOrder.setAttribute('data-number', nextNumber.toString());
            newOrder.style.paddingLeft = currentOrder.style.paddingLeft || '0px';
            newOrder.innerHTML = '\u200B';

            // 插入到当前 order 之后
            if (currentOrder.nextSibling) {
                editor.insertBefore(newOrder, currentOrder.nextSibling);
                } else {
                editor.appendChild(newOrder);
            }

            // 设置光标到新 order 的内容区域（确保可以正常输入和换行）
            const selection = window.getSelection();
            const range = document.createRange();
            // 直接选择列表项的内容，而不是整个节点
            if (newOrder.firstChild && newOrder.firstChild.nodeType === Node.TEXT_NODE) {
                range.setStart(newOrder.firstChild, 0);
                range.collapse(true);
            } else {
                // 如果没有文本节点，创建一个
                const textNode = document.createTextNode('\u200B');
                newOrder.appendChild(textNode);
                range.setStart(textNode, 0);
                range.collapse(true);
            }
            selection.removeAllRanges();
            selection.addRange(range);
            
            notifyContentChanged();
        }

        /**
         * 检查 checkbox 是否为空
         * @param {HTMLElement} checkboxElement - checkbox 元素
         * @returns {boolean} 是否为空
         */
        function isCheckboxEmpty(checkboxElement) {
            // 查找 span 元素（checkbox 的内容在 span 中）
            const span = checkboxElement.querySelector('span');
            if (!span) {
                return true;
            }
            
            // 获取文本内容，去除零宽空格和空白字符
            const text = span.textContent || span.innerText || '';
            const trimmedText = text.replace(/\u200B/g, '').trim();
            
            return trimmedText === '';
        }

        /**
         * 检查无序列表项是否为空
         * @param {HTMLElement} bulletElement - 无序列表项元素
         * @returns {boolean} 是否为空
         */
        function isBulletEmpty(bulletElement) {
            // 获取文本内容，去除零宽空格和空白字符
            const text = bulletElement.textContent || bulletElement.innerText || '';
            const trimmedText = text.replace(/\u200B/g, '').trim();
            
            return trimmedText === '';
        }

        /**
         * 检查有序列表项是否为空
         * @param {HTMLElement} orderElement - 有序列表项元素
         * @returns {boolean} 是否为空
         */
        function isOrderEmpty(orderElement) {
            // 获取文本内容，去除零宽空格和空白字符
            const text = orderElement.textContent || orderElement.innerText || '';
            const trimmedText = text.replace(/\u200B/g, '').trim();
            
            return trimmedText === '';
        }

        /**
         * 将 checkbox 转换为普通正文
         * @param {HTMLElement} checkboxElement - checkbox 元素
         */
        function convertCheckboxToText(checkboxElement) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            // 获取缩进级别
            const indent = getIndentFromElement(checkboxElement);
            
            // 创建普通正文元素
            const textDiv = document.createElement('div');
            textDiv.className = 'mi-note-text indent-' + indent;
            textDiv.innerHTML = '\u200B';
            
            // 替换 checkbox 元素
            if (checkboxElement.nextSibling) {
                editor.insertBefore(textDiv, checkboxElement.nextSibling);
            } else {
                editor.appendChild(textDiv);
            }
            editor.removeChild(checkboxElement);
            
            // 设置光标到新文本元素
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(textDiv);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            notifyContentChanged();
        }

        /**
         * 将无序列表项转换为普通正文
         * @param {HTMLElement} bulletElement - 无序列表项元素
         */
        function convertBulletToText(bulletElement) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            // 获取缩进级别
            const indent = getIndentFromElement(bulletElement);
            
            // 创建普通正文元素
            const textDiv = document.createElement('div');
            textDiv.className = 'mi-note-text indent-' + indent;
            textDiv.innerHTML = '\u200B';
            
            // 替换 bullet 元素
            if (bulletElement.nextSibling) {
                editor.insertBefore(textDiv, bulletElement.nextSibling);
            } else {
                editor.appendChild(textDiv);
            }
            editor.removeChild(bulletElement);
            
            // 设置光标到新文本元素
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(textDiv);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            notifyContentChanged();
        }

        /**
         * 将有序列表项转换为普通正文
         * @param {HTMLElement} orderElement - 有序列表项元素
         */
        function convertOrderToText(orderElement) {
            const editor = document.getElementById('editor-content');
            if (!editor) return;
            
            // 获取缩进级别
            const indent = getIndentFromElement(orderElement);
            
            // 创建普通正文元素
            const textDiv = document.createElement('div');
            textDiv.className = 'mi-note-text indent-' + indent;
            textDiv.innerHTML = '\u200B';
            
            // 替换 order 元素
            if (orderElement.nextSibling) {
                editor.insertBefore(textDiv, orderElement.nextSibling);
            } else {
                editor.appendChild(textDiv);
            }
            editor.removeChild(orderElement);
            
            // 设置光标到新文本元素
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(textDiv);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
            
            notifyContentChanged();
        }

        // ==================== 光标位置修复 ====================
        /**
         * 规范化光标位置（参考 CKEditor 5 的 selection post-fixer）
         * 
         * CKEditor 5 使用 selection post-fixer 确保光标位置正确：
         * - 折叠选择必须在允许文本的位置（使用 schema.getNearestSelectionRange）
         * - 非折叠选择不能跨越 limit 元素边界
         * 
         * 我们实现类似的机制来修复光标位置，避免光标"乱跑"
         */
        function normalizeCursorPosition() {
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                return;
            }

            const range = selection.getRangeAt(0);
            const editor = document.getElementById('editor-content');
            if (!editor) {
                return;
            }

            // 如果选择不在编辑器内，不需要修复
            if (!editor.contains(range.commonAncestorContainer)) {
                return;
            }

            try {
                // 对于折叠选择，找到最近的有效文本位置（类似 CKEditor 5 的 getNearestSelectionRange）
                if (range.collapsed) {
                    let container = range.commonAncestorContainer;
                    let needsFix = false;
                    let fixedNode = null;
                    let fixedOffset = 0;

                    // 检查光标是否在不可编辑的元素内（如 checkbox、hr、image 等）
                    let current = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
                    while (current && current !== editor) {
                        const className = current.className || '';
                        const tagName = current.tagName ? current.tagName.toLowerCase() : '';
                        
                        // 如果光标在特殊元素内，需要移出
                        if (className.includes('mi-note-checkbox') || 
                            className.includes('mi-note-hr') ||
                            className.includes('mi-note-image') ||
                            tagName === 'hr' ||
                            tagName === 'img') {
                            needsFix = true;
                            // 在元素后查找或创建文本节点
                            const parent = current.parentElement;
                            if (parent) {
                                // 查找元素后的第一个文本节点
                                let nextNode = current.nextSibling;
                                while (nextNode) {
                                    if (nextNode.nodeType === Node.TEXT_NODE) {
                                        fixedNode = nextNode;
                                        fixedOffset = 0;
                                        break;
                                    } else if (nextNode.nodeType === Node.ELEMENT_NODE) {
                                        // 查找子元素中的第一个文本节点
                                        const walker = document.createTreeWalker(
                                            nextNode,
                                            NodeFilter.SHOW_TEXT,
                                            null
                                        );
                                        const firstText = walker.nextNode();
                                        if (firstText) {
                                            fixedNode = firstText;
                                            fixedOffset = 0;
                                            break;
                                        }
                                    }
                                    nextNode = nextNode.nextSibling;
                                }
                                
                                // 如果没找到文本节点，创建一个
                                if (!fixedNode) {
                                    const textNode = document.createTextNode('');
                                    if (current.nextSibling) {
                                        parent.insertBefore(textNode, current.nextSibling);
                                    } else {
                                        parent.appendChild(textNode);
                                    }
                                    fixedNode = textNode;
                                    fixedOffset = 0;
                                }
                            }
                            break;
                        }
                        current = current.parentElement;
                    }

                    // 如果光标在空文本节点中（只有零宽度空格），尝试移动到最近的文本节点
                    if (!needsFix && container.nodeType === Node.TEXT_NODE) {
                        const textNode = container;
                        if (textNode.textContent === '\u200B' || 
                            (textNode.textContent.trim() === '' && textNode.textContent.length > 0)) {
                            // 尝试移动到相邻的非空文本节点
                            let nextNode = textNode.nextSibling;
                            let prevNode = textNode.previousSibling;
                            
                            // 优先移动到下一个文本节点
                            while (nextNode) {
                                if (nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent.trim() !== '') {
                                    fixedNode = nextNode;
                                    fixedOffset = 0;
                                    needsFix = true;
                                    break;
                                } else if (nextNode.nodeType === Node.ELEMENT_NODE) {
                                    // 查找子元素中的第一个文本节点
                                    const walker = document.createTreeWalker(
                                        nextNode,
                                        NodeFilter.SHOW_TEXT,
                                        null
                                    );
                                    let node = walker.nextNode();
                                    while (node) {
                                        if (node.textContent.trim() !== '') {
                                            fixedNode = node;
                                            fixedOffset = 0;
                                            needsFix = true;
                                            break;
                                        }
                                        node = walker.nextNode();
                                    }
                                    if (needsFix) break;
                                }
                                nextNode = nextNode.nextSibling;
                            }
                            
                            // 如果下一个节点没找到，尝试上一个节点
                            if (!needsFix) {
                                while (prevNode) {
                                    if (prevNode.nodeType === Node.TEXT_NODE && prevNode.textContent.trim() !== '') {
                                        fixedNode = prevNode;
                                        fixedOffset = prevNode.textContent.length;
                                        needsFix = true;
                                        break;
                                    } else if (prevNode.nodeType === Node.ELEMENT_NODE) {
                                        // 查找子元素中的最后一个文本节点
                                        const walker = document.createTreeWalker(
                                            prevNode,
                                            NodeFilter.SHOW_TEXT,
                                            null
                                        );
                                        let lastText = null;
                                        let node = walker.nextNode();
                                        while (node) {
                                            if (node.textContent.trim() !== '') {
                                                lastText = node;
                                            }
                                            node = walker.nextNode();
                                        }
                                        if (lastText) {
                                            fixedNode = lastText;
                                            fixedOffset = lastText.textContent.length;
                                            needsFix = true;
                                            break;
                                        }
                                    }
                                    prevNode = prevNode.previousSibling;
                                }
                            }
                            
                            // 如果都没找到，尝试移动到父元素的下一个文本节点
                            if (!needsFix && textNode.parentElement) {
                                const parent = textNode.parentElement;
                                let sibling = parent.nextSibling;
                                while (sibling) {
                                    if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent.trim() !== '') {
                                        fixedNode = sibling;
                                        fixedOffset = 0;
                                        needsFix = true;
                                        break;
                                    }
                                    sibling = sibling.nextSibling;
                                }
                            }
                        }
                    }

                    // 如果需要修复，更新选择
                    if (needsFix && fixedNode) {
                        const newRange = document.createRange();
                        newRange.setStart(fixedNode, fixedOffset);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }
            } catch (e) {
                // 忽略修复过程中的错误，避免影响正常编辑
                log.warn(LOG_MODULES.CURSOR, '修复光标位置失败', { error: e.message });
            }
        }

        // ==================== 格式状态同步 ====================
        /**
         * 同步格式状态到 Swift（用于更新格式菜单）
         * 参考 CKEditor 5 的实现：统一检查所有格式状态，包括文本格式、标题、列表、对齐方式
         * 注意：在组合输入期间不触发，避免打断输入
         */
        /**
         * 同步格式状态到 Swift（用于更新格式菜单）
         * 参考 CKEditor 5 的实现：统一检查所有格式状态，包括文本格式、标题、列表、对齐方式
         * 改进：使用命令系统获取状态，支持状态缓存
         * 注意：在组合输入期间不触发，避免打断输入
         */
        function syncFormatState() {
            if (isComposing) {
                return;
            }
            
            const selection = window.getSelection();
            if (!selection.rangeCount) {
                return;
            }

            const range = selection.getRangeAt(0);
            
            // 如果命令管理器可用，优先使用命令系统获取状态
            let formatState = {};
            
            if (commandManager) {
                // 使用命令系统批量获取格式状态
                const formatCommandNames = [
                    'format:bold',
                    'format:italic',
                    'format:underline',
                    'format:strikethrough',
                    'format:highlight'
                ];
                
                const commandStates = commandManager.getStates(formatCommandNames, { range });
                
                formatState = {
                    isBold: commandStates['format:bold']?.active || false,
                    isItalic: commandStates['format:italic']?.active || false,
                    isUnderline: commandStates['format:underline']?.active || false,
                    isStrikethrough: commandStates['format:strikethrough']?.active || false,
                    isHighlighted: commandStates['format:highlight']?.active || false
                };
            } else {
                // 回退到原有方法
                formatState = {
                    isBold: window.MiNoteWebEditor.checkFormatState(range, 'bold'),
                    isItalic: window.MiNoteWebEditor.checkFormatState(range, 'italic'),
                    isUnderline: window.MiNoteWebEditor.checkFormatState(range, 'underline'),
                    isStrikethrough: window.MiNoteWebEditor.checkFormatState(range, 'strikethrough'),
                    isHighlighted: window.MiNoteWebEditor.checkFormatState(range, 'highlight')
                };
            }
            
            // 检查其他状态（标题、列表、对齐、引用）
            formatState.headingLevel = window.MiNoteWebEditor.checkHeadingLevel(range);
            formatState.listType = window.MiNoteWebEditor.checkListType(range);
            formatState.textAlignment = window.MiNoteWebEditor.checkTextAlignment(range);
            formatState.isInQuote = window.MiNoteWebEditor.checkQuoteState(range);
            
            // 如果命令管理器可用，检查命令可执行性
            if (commandManager) {
                const formatCommandNames = [
                    'format:bold',
                    'format:italic',
                    'format:underline',
                    'format:strikethrough',
                    'format:highlight'
                ];
                
                const canExecuteStates = commandManager.canExecuteBatch(formatCommandNames, { range });
                formatState.canExecute = canExecuteStates;
            }

            // 通知 Swift 更新格式状态
            if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                window.webkit.messageHandlers.editorBridge.postMessage({
                    type: 'formatStateChanged',
                    formatState: formatState
                });
            }
        }

        // ==================== 内容变化通知 ====================
        /**
         * 通知内容已变化
         * 注意：在组合输入期间不触发，避免打断输入
         */
        function notifyContentChanged() {
            if (isLoadingContent || !isInitialized || isComposing) {
                return;
            }

            // 在获取内容前保存光标位置（防止后续重新加载时丢失）
            // 这很重要，因为 Swift 端可能会在保存后重新加载内容
            const savedPosition = window.MiNoteWebEditor._saveCursorPosition();
            
            const xmlContent = window.MiNoteWebEditor.getContent();
            
            // 更新当前内容
            if (currentContent !== xmlContent) {
                currentContent = xmlContent;
                
                // 如果内容变化了，保存光标位置到全局变量（供 loadContent 使用）
                // 这样即使 Swift 端重新加载内容，也能恢复光标位置
                // 但只在确实需要时才保存（避免不必要的保存）
                if (savedPosition) {
                    window._pendingCursorPosition = savedPosition;
                    // 设置一个标志，表示有待恢复的光标位置
                    window._hasPendingCursorPosition = true;
                }
                
                // 通知 Swift
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                    window.webkit.messageHandlers.editorBridge.postMessage({
                        type: 'contentChanged',
                        content: xmlContent
                    });
                }
            } else {
                // 如果内容没有变化，清除待恢复的光标位置（避免使用过期的位置）
                window._pendingCursorPosition = null;
                window._hasPendingCursorPosition = false;
            }
            
            // 同步格式状态
            // 使用 requestAnimationFrame 确保状态检查在 DOM 更新后执行
            requestAnimationFrame(() => {
                if (!isComposing && !isLoadingContent) {
                    syncFormatState();
                }
            });
        }

        // ==================== 日志重定向 ====================
        // 重写 console 方法以发送日志到 Swift
        (function() {
            const originalLog = console.log;
            const originalWarn = console.warn;
            const originalError = console.error;

            function createLogSender(level, original) {
                return function(...args) {
                    original.apply(console, args);
                    const message = args.map(arg => {
                        if (typeof arg === 'object') {
                            try { 
                                return JSON.stringify(arg); 
                            } catch(e) { 
                                return String(arg); 
                            }
                        }
                        return String(arg);
                    }).join(' ');
                    
                    if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.editorBridge) {
                        window.webkit.messageHandlers.editorBridge.postMessage({
                            type: 'log',
                            level: level,
                            message: message
                        });
                    }
                };
            }

            console.log = createLogSender('log', originalLog);
            console.warn = createLogSender('warn', originalWarn);
            console.error = createLogSender('error', originalError);
        })();
    </script>
</body>
</html>
