# 保存流程完整分析

## 完整保存流程步骤

### 1. 用户修改内容（JavaScript 端）
- **触发点**: 用户在编辑器中输入/删除/修改内容
- **事件**: `input` 事件触发
- **处理**: `setupEditor()` → `editor.addEventListener('input')`
- **检查**: 
  - 检查 `isComposing`（输入法组合状态）
  - 检查 `isEnterInput`（换行输入）
- **调用**: `debounceContentChange()`（防抖 500ms）

### 2. 防抖处理（JavaScript 端）
- **函数**: `debounceContentChange()`
- **延迟**: 500ms
- **检查**: 
  - 再次检查 `isComposing`
  - 如果不在组合输入状态，调用 `notifyContentChanged()`

### 3. 通知内容变化（JavaScript 端）
- **函数**: `notifyContentChanged()`
- **检查**:
  1. `isInitialized` - 编辑器是否已初始化
  2. `isLoadingContent` - 是否正在加载内容（**关键检查点**）
  3. `xmlContent === currentContent` - 内容是否真的变化了（**关键检查点**）
- **操作**:
  1. 调用 `window.MiNoteWebEditor.getContent()` 获取当前 XML 内容
  2. 更新 `currentContent = xmlContent`
  3. 通过 `editorBridge.postMessage` 发送 `contentChanged` 消息到 Swift

### 4. Swift 接收消息（Swift 端）
- **位置**: `EditorMessageHandler.userContentController(_:didReceive:)`
- **消息类型**: `contentChanged`
- **操作**:
  1. 设置 `coordinator.isUpdatingFromWeb = true`
  2. 设置 `coordinator.lastContent = content`
  3. 调用 `onContentChanged(content)` 回调

### 5. 内容变化回调（Swift 端）
- **位置**: `NoteDetailView.onContentChange`
- **检查**: `isInitializing` - 是否正在初始化
- **操作**:
  1. 将 XML 转换为 `AttributedString`
  2. 更新 `editedAttributedText`
  3. 调用 `saveToLocalOnly(for: note)`
  4. 调用 `scheduleCloudUpload(for: note)`

### 6. 保存到本地（Swift 端）
- **函数**: `saveToLocalOnly(for:)`
- **步骤**:
  1. 验证笔记 ID (`note.id == currentEditingNoteId`)
  2. 防止并发保存 (`isSavingLocally`)
  3. **调用 `getLatestContentFromEditor()` 获取最新内容**（**关键步骤**）
  4. 检查内容是否变化 (`hasContentChanged`)
  5. 构建更新的笔记对象
  6. 保存到数据库 (`LocalStorageService.shared.saveNote`)
  7. 更新保存状态 (`updateSaveState`)
  8. 延迟更新 ViewModel

### 7. 获取最新内容（Swift 端）
- **函数**: `getLatestContentFromEditor()`
- **步骤**:
  1. 调用 `getCurrentEditorContent()` 从编辑器获取 XML
  2. 如果成功，转换为 `AttributedString` 并返回
  3. 如果失败，使用 `editedAttributedText` 作为后备，转换为 XML

### 8. 从编辑器获取内容（Swift → JavaScript）
- **函数**: `getCurrentEditorContent()`
- **调用**: `webEditorContext.getCurrentContent { }`
- **JavaScript**: `window.MiNoteWebEditor.getContent()`
- **返回**: XML 内容字符串

### 9. 检查内容变化（Swift 端）
- **函数**: `hasContentChanged(xmlContent:)`
- **比较**: `lastSavedXMLContent == xmlContent`
- **如果相同**: 检查标题是否变化
- **如果不同**: 返回 `true`（有变化）

### 10. 保存到数据库（Swift 端）
- **服务**: `LocalStorageService.shared.saveNote(updatedNote)`
- **操作**: 更新 SQLite 数据库

### 11. 更新保存状态（Swift 端）
- **函数**: `updateSaveState(xmlContent:attributedText:)`
- **操作**:
  1. `lastSavedXMLContent = xmlContent`
  2. `originalTitle = editedTitle`
  3. `originalAttributedText = attributedText`

### 12. 安排云端上传（Swift 端）
- **函数**: `scheduleCloudUpload(for:)`
- **检查**: `viewModel.isOnline && viewModel.isLoggedIn`
- **防抖**: 根据内容大小智能调整延迟时间
- **操作**: 延迟后调用 `SyncService` 上传

## 潜在问题点

### 问题 1: `isLoadingContent` 标志阻止保存
- **位置**: `notifyContentChanged()` 中检查 `isLoadingContent`
- **问题**: 如果 `isLoadingContent` 为 `true`，内容变化通知会被跳过
- **影响**: 用户在加载内容后立即修改，修改可能无法保存

### 问题 2: 内容比较逻辑
- **位置**: `notifyContentChanged()` 中 `xmlContent === currentContent`
- **问题**: 如果内容相同，不会发送通知
- **影响**: 如果 `currentContent` 没有及时更新，可能导致修改丢失

### 问题 3: 双重获取内容
- **位置**: 
  1. `onContentChange` 回调中收到 `newContent`
  2. `saveToLocalOnly` 中再次调用 `getLatestContentFromEditor()`
- **问题**: 两次获取的内容可能不一致
- **影响**: 保存的内容可能不是用户最后修改的内容

### 问题 4: `lastSavedXMLContent` 更新时机
- **位置**: `updateSaveState` 在 `saveToLocalOnly` 中调用
- **问题**: 如果保存失败或跳过，`lastSavedXMLContent` 不会更新
- **影响**: 下次保存时可能误判为内容未变化

### 问题 5: `isLoadingContent` 重置时机
- **位置**: `loadContent` 中延迟 100ms 重置 `isLoadingContent`
- **问题**: 如果用户在 100ms 内修改，修改会被忽略
- **影响**: 切换笔记后立即修改可能无法保存

## 建议修复

1. **优化 `isLoadingContent` 逻辑**: 在 `forceNotifyContentChanged` 中不检查 `isLoadingContent`
2. **直接使用回调中的内容**: 在 `saveToLocalOnly` 中直接使用 `onContentChange` 收到的内容，而不是再次获取
3. **改进内容比较**: 使用更精确的内容比较方法
4. **添加重试机制**: 如果保存失败，记录并重试
5. **优化时序**: 确保 `isLoadingContent` 在合适的时机重置

